<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>镜像中的时区问题</title>
    <url>/2021/02/05/docker/timezone/</url>
    <content><![CDATA[<p>在容器的使用过程中，尤其是基础镜像，很多都是以UTC为准，但是再实际使用过程中，在获取时间时，通过调用系统时钟获取当前时间，统一在环境中把时间改为CST时间</p>
<a id="more"></a>

<h2 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a>alpha</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM alpine:3.9</span><br><span class="line"></span><br><span class="line"># 设置时区为上海</span><br><span class="line">RUN apk add tzdata &amp;&amp; \</span><br><span class="line">    cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime &amp;&amp; \</span><br><span class="line">    echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>踩坑遇雷</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 核心点</title>
    <url>/2021/01/08/k8s/kube/</url>
    <content><![CDATA[<p>kubernetes 中常见的问题总结</p>
<a id="more"></a>


<h1 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h1><p>默认情况下，如果容器重启，kubelet 会保留被终止的容器日志。<br>如果 Pod 在工作节点被驱逐，该 Pod 中所有的容器也会被驱逐，包括容器日志。</p>
<p>节点级日志记录中，需要重点考虑实现日志的轮转，以此来保证日志不会消耗节点上全部可用空间。 Kubernetes 并不负责轮转日志，而是通过部署工具建立一个解决问题的方案。</p>
<h1 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h1><h2 id="更新（反向更新，从大到小）"><a href="#更新（反向更新，从大到小）" class="headerlink" title="更新（反向更新，从大到小）"></a>更新（反向更新，从大到小）</h2><p>StatefulSet 里的 Pod 采用和序号相反的顺序更新。在更新下一个 Pod 前，StatefulSet 控制器终止每个 Pod 并等待它们变成 Running 和 Ready。请注意，虽然在顺序后继者变成 Running 和 Ready 之前 StatefulSet 控制器不会更新下一个 Pod，但它仍然会重建任何在更新过程中发生故障的 Pod，使用的是它们当前的版本。已经接收到更新请求的 Pod 将会被恢复为更新的版本，没有收到请求的 Pod 则会被恢复为之前的版本。像这样，控制器尝试继续使应用保持健康并在出现间歇性故障时保持更新的一致性。</p>
<h3 id="分段更新"><a href="#分段更新" class="headerlink" title="分段更新"></a>分段更新</h3><p>使用 <code>RollingUpdate</code> 更新策略的 <code>partition</code> 参数来分段更新一个 StatefulSet。分段的更新将会使 StatefulSet 中的其余所有 Pod 保持当前版本的同时仅允许改变 StatefulSet 的 <code>.spec.template</code></p>
<h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><h2 id="删除-序号从小到大依次删除，创建删除都是如此顺序"><a href="#删除-序号从小到大依次删除，创建删除都是如此顺序" class="headerlink" title="删除(序号从小到大依次删除，创建删除都是如此顺序)"></a>删除(序号从小到大依次删除，创建删除都是如此顺序)</h2><h3 id="非级联删除"><a href="#非级联删除" class="headerlink" title="非级联删除"></a>非级联删除</h3><p>使用 kubectl delete 删除 StatefulSet。请确保提供了<code>--cascade=false</code> 参数给命令。这个参数告诉 Kubernetes 只删除 StatefulSet 而不要删除它的任何 Pod。</p>
<p><code>kubectl delete statefulset web --cascade=false</code></p>
<p><font color=red><strong>pod 依旧存在</strong></font></p>
<h2 id="并发管理"><a href="#并发管理" class="headerlink" title="并发管理"></a>并发管理</h2><p>将<code>.spec.podManagementPolicy</code> 设置成了 <code>Parallel</code></p>
<blockquote>
<p>创建、删除操作都会并发执行</p>
</blockquote>
<blockquote>
<p>更新依旧逆序执行</p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>互联网词汇</title>
    <url>/2020/12/29/others/internet_words/</url>
    <content><![CDATA[<p>你还在为怎么更高逼格描述自己做的东西发愁吗？<br>你还在为怎么做晋级评委发愁吗？<br>你还在为怎么做项目评审发愁吗？</p>
<p>记录一些互联网常用的 <code>ppt</code> 词汇</p>
<a id="more"></a>

<h1 id="二字动词"><a href="#二字动词" class="headerlink" title="二字动词"></a>二字动词</h1><p>复盘,赋能,沉淀,倒逼,落地,串联,协同,反哺,兼容,包装,重组,履约,响应,量化,发力,布局,联动,细分,梳理,输出,加速,共建,支撑,融合,聚合,解藕,集成,对齐,对标,对焦,抓手,拆解,拉通,抽象,摸索,提炼,打通,打透,吃透,迁移,分发,分层,分装,穿梭,辐射,围绕,复用,渗透,扩展,开拓,</p>
<h1 id="二字名词"><a href="#二字名词" class="headerlink" title="二字名词"></a>二字名词</h1><p>漏斗,中台,闭环,打法,拉通,纽带,矩阵,刺激,规模,场景,聚焦,维度,格局,形态,生态,话术,体系,认知,玩法,体感,感知,调性,心智,战役,合力,心力,赛道,因子,模型,载体,横向,通道,补位,链路,试点</p>
<h1 id="三字名词"><a href="#三字名词" class="headerlink" title="三字名词"></a>三字名词</h1><p>颗粒度,感知度,方法论,组合拳,引爆点,点线面,精细化,差异化,平台化,结构化,影响力,耦合性,易用性,一致性,端到端,短平快</p>
<h1 id="四字名词"><a href="#四字名词" class="headerlink" title="四字名词"></a>四字名词</h1><p>生命周期,价值转化,强化认知,资源倾斜,完善逻辑,拙离透传,复用打法,商业模式,快速响应,定性定量,关键路径,去中心化,结果导向,垂直领域,如何收口,归因分析,体验度量,信息屏障</p>
<h1 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h1><blockquote>
<p>你写这个东西的底层逻辑是什么？<br>顶层设计在哪？<br>最终交付价值是什么？<br>过程的抓手在哪里？<br>如何保证结果的闭环？<br>你比别人的亮点在哪里？<br>优势在哪里？<br>你的思考和沉淀在哪里？<br>你有形成自己的方法论吗？<br>你这个东西换别人来做是否会不一样？</p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
        <category>概念描述</category>
      </categories>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 总结</title>
    <url>/2020/12/01/golang/interview/</url>
    <content><![CDATA[<p>总结一些go使用过程中遇到的一些问题</p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1>]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>harbor登录切换</title>
    <url>/2020/11/19/harbor/login/</url>
    <content><![CDATA[<p>harbor 在设置完 ldap 登录之后，ldap 会出现响应超时情况，所以想改回数据库模式，但是在页面上不能再设置为其他认证方式。</p>
<a id="more"></a>

<p>通过阅读 <code>harbor</code> 的源码，发现其中的限制为以下代码：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AuthModeCanBeModified determines whether auth mode can be</span></span><br><span class="line"><span class="comment">// modified or not. Auth mode can modified when there is only admin</span></span><br><span class="line"><span class="comment">// user in database.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthModeCanBeModified</span><span class="params">()</span> <span class="params">(<span class="keyword">bool</span>, error)</span></span> &#123;</span><br><span class="line">	c, err := GetOrmer().QueryTable(&amp;models.User&#123;&#125;).Count()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// admin and anonymous</span></span><br><span class="line">	<span class="keyword">return</span> c == <span class="number">2</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以看出来，只有在数据库<code>registry</code>-&gt;<code>harbor_user</code> 中的数量为<code>2</code>时，才可以修改，所以需要进入<code>psql</code>中，将多余的用户删除掉，只保留<code>anonymous</code> 和 <code>admin</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> harbor_user <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><em>执行<code>DELETE</code>语句时可能会遇到外键不允许删除，需要把<code>registry</code>-&gt;<code>project</code>中的<code>owner_id</code> 设置为<code>admin</code>的 <code>1</code></em></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>harbor</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables四个表与五个链</title>
    <url>/2020/11/12/linux/iptables/</url>
    <content><![CDATA[<p>netfilter/iptables IP 信息包过滤系统是一种功能强大的工具，可用于添加、编辑和除去规则，这些规则是在做信息包过滤决定时，防火墙所遵循和组成的规则。这些规则存储在专用的信息包过滤表中，而这些表集成在 Linux 内核中。在信息包过滤表中，规则被分组放在我们所谓的链（chain）中。<br> <a id="more"></a></p>
<h1 id="netfilter和iptables"><a href="#netfilter和iptables" class="headerlink" title="netfilter和iptables"></a>netfilter和iptables</h1><blockquote>
<p>netfilter 组件也称为内核空间（kernelspace），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。</p>
</blockquote>
<blockquote>
<p>iptables 组件是一种工具，也称为用户空间（userspace），它使插入、修改和除去信息包过滤表中的规则变得容易。</p>
</blockquote>
<p>iptables包含4个表，5个链。其中表是按照对数据包的操作区分的，链是按照不同的Hook点来区分的，表和链实际上是netfilter的两个维度。</p>
<h2 id="4个表"><a href="#4个表" class="headerlink" title="4个表"></a>4个表</h2><p>默认表是filter（没有指定表的时候就是filter表）。</p>
<blockquote>
<p>表的处理优先级：raw&gt;mangle&gt;nat&gt;filter。</p>
</blockquote>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>一般的过滤功能</p>
<h3 id="nat"><a href="#nat" class="headerlink" title="nat"></a>nat</h3><p>用于nat功能（端口映射，地址映射等）</p>
<h3 id="mangle"><a href="#mangle" class="headerlink" title="mangle"></a>mangle</h3><p>用于对特定数据包的修改</p>
<h3 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h3><p>有限级最高，设置raw时一般是为了不再让iptables做数据包的链接跟踪处理，提高性能</p>
<p>RAW 表只使用在PREROUTING链和OUTPUT链上,因为优先级最高，从而可以对收到的数据包在连接跟踪前进行处理。一但用户使用了RAW表,在某个链 上,RAW表处理完后,将跳过NAT表和 ip_conntrack处理,即不再做地址转换和数据包的链接跟踪处理了。</p>
<p>RAW表可以应用在那些不需要做nat的情况下，以提高性能。如大量访问的web服务器，可以让80端口不再让iptables做数据包的链接跟踪处理，以提高用户的访问速度。</p>
<h2 id="5个链"><a href="#5个链" class="headerlink" title="5个链"></a>5个链</h2><h3 id="PREROUTING"><a href="#PREROUTING" class="headerlink" title="PREROUTING"></a>PREROUTING</h3><p>数据包进入路由表之前</p>
<h3 id="INPUT"><a href="#INPUT" class="headerlink" title="INPUT"></a>INPUT</h3><p>通过路由表后目的地为本机</p>
<h3 id="FORWARDING"><a href="#FORWARDING" class="headerlink" title="FORWARDING"></a>FORWARDING</h3><p>通过路由表后，目的地不为本机</p>
<h3 id="OUTPUT"><a href="#OUTPUT" class="headerlink" title="OUTPUT"></a>OUTPUT</h3><p>由本机产生，向外转发</p>
<h3 id="POSTROUTIONG"><a href="#POSTROUTIONG" class="headerlink" title="POSTROUTIONG"></a>POSTROUTIONG</h3><p>发送到网卡接口之前。</p>
<p><img src="/images/linux/iptables/iptable-1.png" alt="流量走向"></p>
<h2 id="iptables的数据包的流程是怎样的？"><a href="#iptables的数据包的流程是怎样的？" class="headerlink" title="iptables的数据包的流程是怎样的？"></a>iptables的数据包的流程是怎样的？</h2><p><img src="/images/linux/iptables/iptable-2.png" alt="流量走向"></p>
<p>基本步骤如下： </p>
<ol>
<li>数据包到达网络接口，比如 eth0。 </li>
<li>进入 raw 表的 PREROUTING 链，这个链的作用是赶在连接跟踪之前处理数据包。 </li>
<li>如果进行了连接跟踪，在此处理。 </li>
<li>进入 mangle 表的 PREROUTING 链，在此可以修改数据包，比如 TOS 等。 </li>
<li>进入 nat 表的 PREROUTING 链，可以在此做DNAT，但不要做过滤。 </li>
<li>决定路由，看是交给本地主机还是转发给其它主机。 </li>
</ol>
<p>到了这里我们就得分两种不同的情况进行讨论了，一种情况就是数据包要转发给其它主机，这时候它会依次经过：<br>7. 进入 mangle 表的 FORWARD 链，这里也比较特殊，这是在第一次路由决定之后，在进行最后的路由决定之前，我们仍然可以对数据包进行某些修改。<br>8. 进入 filter 表的 FORWARD 链，在这里我们可以对所有转发的数据包进行过滤。需要注意的是：经过这里的数据包是转发的，方向是双向的。<br>9. 进入 mangle 表的 POSTROUTING 链，到这里已经做完了所有的路由决定，但数据包仍然在本地主机，我们还可以进行某些修改。<br>10. 进入 nat 表的 POSTROUTING 链，在这里一般都是用来做 SNAT ，不要在这里进行过滤。<br>11. 进入出去的网络接口。完毕。 </p>
<p>另一种情况是，数据包就是发给本地主机的，那么它会依次穿过：<br>7. 进入 mangle 表的 INPUT 链，这里是在路由之后，交由本地主机之前，我们也可以进行一些相应的修改。<br>8. 进入 filter 表的 INPUT 链，在这里我们可以对流入的所有数据包进行过滤，无论它来自哪个网络接口。<br>9. 交给本地主机的应用程序进行处理。<br>10. 处理完毕后进行路由决定，看该往那里发出。<br>11. 进入 raw 表的 OUTPUT 链，这里是在连接跟踪处理本地的数据包之前。<br>12. 连接跟踪对本地的数据包进行处理。<br>13. 进入 mangle 表的 OUTPUT 链，在这里我们可以修改数据包，但不要做过滤。<br>14. 进入 nat 表的 OUTPUT 链，可以对防火墙自己发出的数据做 NAT 。<br>15. 再次进行路由决定。<br>16. 进入 filter 表的 OUTPUT 链，可以对本地出去的数据包进行过滤。<br>17. 进入 mangle 表的 POSTROUTING 链，同上一种情况的第9步。注意，这里不光对经过防火墙的数据包进行处理，还对防火墙自己产生的数据包进行处理。<br>18. 进入 nat 表的 POSTROUTING 链，同上一种情况的第10步。<br>19. 进入出去的网络接口。完毕。</p>
<h2 id="iptables-raw表的使用"><a href="#iptables-raw表的使用" class="headerlink" title="iptables raw表的使用"></a>iptables raw表的使用</h2><p>增加raw表，在其他表处理之前，-j NOTRACK跳过其它表处理<br>状态除了以前的四个还增加了一个UNTRACKED</p>
<p>例如：<br>可以使用 “NOTRACK” target 允许规则指定80端口的包不进入链接跟踪/NAT子系统</p>
<p>iptables -t raw -A PREROUTING -d 1.2.3.4 -p tcp –dport 80 -j NOTRACK<br>iptables -t raw -A PREROUTING -s 1.2.3.4 -p tcp –sport 80 -j NOTRACK<br>iptables -A FORWARD -m state –state UNTRACKED -j ACCEPT</p>
<h2 id="解决ip-conntrack-table-full-dropping-packet的问题"><a href="#解决ip-conntrack-table-full-dropping-packet的问题" class="headerlink" title="解决ip_conntrack: table full, dropping packet的问题"></a>解决ip_conntrack: table full, dropping packet的问题</h2><p>在启用了iptables web服务器上，流量高的时候经常会出现下面的错误：</p>
<p>ip_conntrack: table full, dropping packet</p>
<p>这个问题的原因是由于web服务器收到了大量的连接，在启用了iptables的情况下，iptables会把所有的连接都做链接跟踪处理，这样iptables就会有一个链接跟踪表，当这个表满的时候，就会出现上面的错误。</p>
<p>iptables的链接跟踪表最大容量为/proc/sys/net/ipv4/ip_conntrack_max，链接碰到各种状态的超时后就会从表中删除。</p>
<p>所以解決方法一般有两个：</p>
<p>(1) 加大 ip_conntrack_max 值</p>
<p>vi /etc/sysctl.conf</p>
<p>net.ipv4.ip_conntrack_max = 393216<br>net.ipv4.netfilter.ip_conntrack_max = 393216</p>
<p>(2): 降低 ip_conntrack timeout时间</p>
<p>vi /etc/sysctl.conf</p>
<p>net.ipv4.netfilter.ip_conntrack_tcp_timeout_established = 300<br>net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait = 120<br>net.ipv4.netfilter.ip_conntrack_tcp_timeout_close_wait = 60<br>net.ipv4.netfilter.ip_conntrack_tcp_timeout_fin_wait = 120</p>
<p>上面两种方法打个比喻就是烧水水开的时候，换一个大锅。一般情况下都可以解决问题，但是在极端情况下，还是不够用，怎么办？</p>
<p>这样就得反其道而行，用釜底抽薪的办法。iptables的raw表是不做数据包的链接跟踪处理的，我们就把那些连接量非常大的链接加入到iptables raw表。</p>
<p>如一台web服务器可以这样：</p>
<p>iptables -t raw -A PREROUTING -d 1.2.3.4 -p tcp –dport 80 -j NOTRACK<br>iptables -A FORWARD -m state –state UNTRACKED -j ACCEPT</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-scheduler 的扩展</title>
    <url>/2020/11/08/k8s/kube-scheduler-extend/</url>
    <content><![CDATA[<p>k8s官方默认的scheduler包含了一些调度算法，但是有些时候不能很好的满足需求。<br>比如：一台物理机多个虚拟机，每个虚拟机是一个<code>node</code>节点，相同的服务调度时，希望尽量分散在不同的物理机上。<br>这时候，我们需要将scheduler进行扩展，通过自定义算法，进一步控制调度逻辑、节点score。</p>
<a id="more"></a>

<h2 id="扩展方案"><a href="#扩展方案" class="headerlink" title="扩展方案"></a>扩展方案</h2><p>目前Kubernetes支持四种方式实现客户自定义的调度算法(预选&amp;优选)，如下：</p>
<ol>
<li><p>default-scheduler recoding:直接在Kubernetes默认scheduler基础上进行添加，然后重新编译kube-scheduler</p>
</li>
<li><p>standalone:实现一个与kube-scheduler平行的custom scheduler，单独或者和默认kube-scheduler一起运行在集群中</p>
</li>
<li><p>scheduler extender:实现一个”scheduler extender”，kube-scheduler会调用它(http/https)作为默认调度算法(预选&amp;优选&amp;bind)的补充</p>
</li>
<li><p>scheduler framework:实现scheduler framework plugins，重新编译kube-scheduler，类似于第一种方案，但是更加标准化，插件化</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>在访问etcd时发生了啥</title>
    <url>/2020/11/05/etcd/how_did_it_run/</url>
    <content><![CDATA[<p>etcd 通过 raft 协议来实现 leader 选举、配置变更以及保证数据读写的一致性。那么在客户端发送或接受数据的时候发生了啥</p>
<a id="more"></a>

<h1 id="写数据流程："><a href="#写数据流程：" class="headerlink" title="写数据流程："></a>写数据流程：</h1><ol>
<li>etcd 任一节点的 etcd server 模块收到 Client 写请求（如果是 follower 节点，会先通过 Raft 模块将请求转发至 leader 节点处理）。</li>
<li>etcd server 将请求封装为 Raft 请求，然后提交给 Raft 模块处理。</li>
<li>leader 通过 Raft 协议与集群中 follower 节点进行交互，将消息复制到follower 节点，于此同时，并行将日志持久化到 WAL。</li>
<li>follower 节点对该请求进行响应，回复自己是否同意该请求。</li>
<li>当集群中超过半数节点（(n/2)+1 members ）同意接收这条日志数据时，表示该请求可以被Commit，Raft 模块通知 etcd server 该日志数据已经 Commit，可以进行 Apply。</li>
<li>各个节点的 etcd server 的 applierV3 模块异步进行 Apply 操作，并通过 MVCC 模块写入后端存储 BoltDB。</li>
<li>当 client 所连接的节点数据 apply 成功后，会返回给客户端 apply 的结果。</li>
</ol>
<h1 id="读数据流程："><a href="#读数据流程：" class="headerlink" title="读数据流程："></a>读数据流程：</h1><ol>
<li>etcd 的任一节点的etcd server 模块接收到客户端发送的请求（Range请求）</li>
<li>判断请求的类型，如果是串行化读（serializable）则直接进入 Apply 流程</li>
<li>如果是线性一致性读（linearizable）则进入 Raft 模块</li>
<li>Raft 模块向 leader 发出 ReadIndex 请求，获取当前集群已经提交的最新数据 Index</li>
<li>等待本地 AppliedIndex 大于或等于 ReadIndex 获取的 CommittedIndex 时，进入 Apply 流程</li>
</ol>
<blockquote>
<p>Apply 流程：通过 Key 名从 KV Index 模块获取 Key 最新的 Revision，再通过 Revision 从 BoltDB 获取对应的 Key 和 Value。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>client-go</title>
    <url>/2020/10/27/k8s/client_go/</url>
    <content><![CDATA[<h1 id="client-go-机制"><a href="#client-go-机制" class="headerlink" title="client-go 机制"></a>client-go 机制</h1><p>在k8s中，都是通过<code>client-go</code>与<code>apiserver</code>进行交互</p>
<a id="more"></a>

<p><img src="/images/k8s/client-go-controller-interaction.jpeg" alt="client-go"></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p><code>client-go</code> 主要由三个部分组成</p>
<ul>
<li><a class="link" href="https://github.com/kubernetes/client-go/blob/master/tools/cache/reflector.go">Reflector<i class="fas fa-external-link-alt"></i></a> ：会watch<code>apiserver</code>，并将接收到的对象推入<code>DeltaFIFO</code>队列中的<code>watchHandler</code> 函数</li>
<li><a class="link" href="https://github.com/kubernetes/client-go/blob/master/tools/cache/controller.go">Informer<i class="fas fa-external-link-alt"></i></a> ：通过<code>processLoop</code>函数将对象从<code>DeltaFIFO</code>队列中弹出，并存入控制器中</li>
<li><a class="link" href="https://github.com/kubernetes/client-go/blob/master/tools/cache/index.go">Indexer<i class="fas fa-external-link-alt"></i></a>：索引器可以基于几个索引功能来维护索引。索引器使用线程安全的数据存储来存储对象及其键。在包高速缓存 中的存储类型中定义了一个名为MetaNamespaceKeyFunc的默认函数，该函数生成对象的密钥作为该对象的组合。<code>&lt;namespace&gt;/&lt;name&gt;</code></li>
</ul>
<h2 id="编写时"><a href="#编写时" class="headerlink" title="编写时"></a>编写时</h2><p><code>Client-Go</code>中的基本控制器提供了<code>NewIndexerInformer</code>函数来创建<code>Informer</code>和<code>Indexer</code>。可以<a class="link" href="https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go#L174">直接调用函数<i class="fas fa-external-link-alt"></i></a>或者<a class="link" href="https://github.com/kubernetes/sample-controller/blob/master/main.go#L61">使用工厂函数<i class="fas fa-external-link-alt"></i></a>创建</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link" href="https://github.com/kubernetes/sample-controller/blob/master/docs/controller-client-go.md">controller-client-go<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-scheduler 源码阅读</title>
    <url>/2020/09/14/k8s/kube-schdeuler/</url>
    <content><![CDATA[<h1 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h1><p>自动调度是云原生最重要的环节之一，kube-scheduler是Kubernetes中的关键模块，扮演管家的角色遵从一套机制为Pod提供调度服务，例如基于资源的公平调度、调度Pod到指定节点、或者通信频繁的Pod调度到同一节点等。</p>
<a id="more"></a>

<p>容器调度本身是一件比较复杂的事，因为要确保以下几个目标：</p>
<ol>
<li>公平性：在调度Pod时需要公平的进行决策，每个节点都有被分配资源的机会，调度器需要对不同节点的使用作出平衡决策。</li>
<li>资源高效利用：最大化群集所有资源的利用率，使有限的CPU、内存等资源服务尽可能更多的Pod。</li>
<li>效率问题：能快速的完成对大批量Pod的调度工作，在集群规模扩增的情况下，依然保证调度过程的性能。</li>
<li>灵活性：在实际运作中，用户往往希望Pod的调度策略是可控的，从而处理大量复杂的实际问题。因此平台要允许多个调度器并行工作，同时支持自定义调度器。</li>
</ol>
<p>为达到上述目标，kube-scheduler通过结合Node资源、负载情况、数据位置等各种因素进行调度判断，确保在满足场景需求的同时将Pod分配到最优节点。</p>
<h2 id="预选和优选"><a href="#预选和优选" class="headerlink" title="预选和优选"></a>预选和优选</h2><p>kube-scheduler的根本工作任务是根据各种调度算法将Pod绑定（bind）到最合适的工作节点，整个调度流程分为两个阶段：预选策略（Predicates）和优选策略（Priorities）。</p>
<p>预选（Predicates）：输入是所有节点，输出是满足预选条件的节点。kube-scheduler根据预选策略过滤掉不满足策略的Nodes。例如，如果某节点的资源不足或者不满足预选策略的条件如“Node的label必须与Pod的Selector一致”时则无法通过预选。<br>优选（Priorities）：输入是预选阶段筛选出的节点，优选会根据优先策略为通过预选的Nodes进行打分排名，选择得分最高的Node。例如，资源越富裕、负载越小的Node可能具有越高的排名。</p>
<p>通俗点说，调度的过程就是在回答两个问题：1. 候选有哪些？2. 其中最适合的是哪个？</p>
<p>值得一提的是，如果在预选阶段没有节点满足条件，Pod会一直处在Pending状态直到出现满足的节点，在此期间调度器会不断的进行重试。</p>
<h3 id="预选策略（Predicates）"><a href="#预选策略（Predicates）" class="headerlink" title="预选策略（Predicates）"></a>预选策略（Predicates）</h3><h4 id="基于存储卷数量的判断"><a href="#基于存储卷数量的判断" class="headerlink" title="基于存储卷数量的判断"></a>基于存储卷数量的判断</h4><blockquote>
<p>MaxEBSVolumeCount：确保已挂载的EBS存储卷数量不超过设置的最大值（默认39），调度器会检查直接或及间接使用这种类型存储的PVC，累加总数，如果卷数目超过设最大值限制，则不能调度新Pod到这个节点上。</p>
</blockquote>
<blockquote>
<p>MaxGCEPDVolumeCount：同上，确保已挂载的GCE存储卷数量不超过预设的最大值（默认16）。</p>
</blockquote>
<blockquote>
<p>MaxAzureDiskVolumeCount：同上，确保已挂载的Azure存储卷不超过设置的最大值（默认16）。</p>
</blockquote>
<h4 id="基于资源压力状态的判断"><a href="#基于资源压力状态的判断" class="headerlink" title="基于资源压力状态的判断"></a>基于资源压力状态的判断</h4><blockquote>
<p>CheckNodeMemoryPressure：判断节点是否已经进入到内存压力状态，如果是则只允许调度内存为0标记的Pod。</p>
</blockquote>
<blockquote>
<p>CheckNodeDiskPressure：判断节点是否已经进入到磁盘压力状态，如果是，则不能调度新的Pod。</p>
</blockquote>
<h4 id="基于卷冲突的判断"><a href="#基于卷冲突的判断" class="headerlink" title="基于卷冲突的判断"></a>基于卷冲突的判断</h4><blockquote>
<p>NoDiskConflict：卷冲突判断，即如果该节点已经挂载了某个卷，其它同样使用相同卷的Pod将不能再调度到该节点。</p>
</blockquote>
<blockquote>
<p>NoVolumeZoneConflict：对于给定的某块区域，判断如果在此区域的节点上部署Pod是否存在卷冲突。</p>
</blockquote>
<blockquote>
<p>NoVolumeNodeConflict：对于某个指定节点，检查如果在此节点上部署Pod是否存在卷冲突。</p>
</blockquote>
<h4 id="基于约束关系的判断"><a href="#基于约束关系的判断" class="headerlink" title="基于约束关系的判断"></a>基于约束关系的判断</h4><blockquote>
<p>MatchNodeSelector：检查节点标签（label）是否匹配Pod指定的nodeSelector，是则通过预选。</p>
</blockquote>
<blockquote>
<p>MatchInterPodAffinity：根据Pod之间的亲和性做判断。</p>
</blockquote>
<blockquote>
<p>PodToleratesNodeTaints：排斥性关系，即判断Pod不允许被调度到哪些节点。这里涉及到两个概念Taints（污点）和Toleration（容忍）。Node可以定义一或多个Taint，Pod可以定义一或多个Toleration，对于具有某个Taint的节点，只有遇到能容忍它的（即带有对应Toleration的）Pod，才允许Pod被调度到此节点，从而避免Pod被分配到不合适的节点。</p>
</blockquote>
<h4 id="基于适合性的判断"><a href="#基于适合性的判断" class="headerlink" title="基于适合性的判断"></a>基于适合性的判断</h4><blockquote>
<p>PodFitsResources：检查节点是否有足够资源（如CPU、内存、GPU等）满足Pod的运行需求。</p>
</blockquote>
<blockquote>
<p>PodFitsHostPorts：检查Pod容器所需的HostPort是否已被节点上其它容器或服务占用。如果已被占用，则禁止Pod调度到该节点。</p>
</blockquote>
<blockquote>
<p>PodFitsHost：检查Pod指定的NodeName是否匹配当前节点。</p>
</blockquote>
<h3 id="优选策略（Priorities）"><a href="#优选策略（Priorities）" class="headerlink" title="优选策略（Priorities）"></a>优选策略（Priorities）</h3><p>优选过程会根据优选策略对每个候选节点进行打分，最终把Pod调度到分值最高的节点。kube-scheduler用一组优先级函数处理每个通过预选的节点，每个函数返回0-10的分数，各个函数有不同权重，最终得分是所有优先级函数的加权和，即节点得分的计算公式为</p>
<p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="47.585ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 21032.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(749, 0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1094, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1694, 0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(2223, 0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(2521, 0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(3409, 0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(3894, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(4414, 0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(4880, 0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g><g data-mml-node="mi" transform="translate(5525, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(5958, 0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(6443, 0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(6894, 0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mo" transform="translate(7637.8, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(8693.6, 0)"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="mi" transform="translate(9916.2, 0)"><path data-c="1D44A" d="M436 683Q450 683 486 682T553 680Q604 680 638 681T677 682Q695 682 695 674Q695 670 692 659Q687 641 683 639T661 637Q636 636 621 632T600 624T597 615Q597 603 613 377T629 138L631 141Q633 144 637 151T649 170T666 200T690 241T720 295T759 362Q863 546 877 572T892 604Q892 619 873 628T831 637Q817 637 817 647Q817 650 819 660Q823 676 825 679T839 682Q842 682 856 682T895 682T949 681Q1015 681 1034 683Q1048 683 1048 672Q1048 666 1045 655T1038 640T1028 637Q1006 637 988 631T958 617T939 600T927 584L923 578L754 282Q586 -14 585 -15Q579 -22 561 -22Q546 -22 542 -17Q539 -14 523 229T506 480L494 462Q472 425 366 239Q222 -13 220 -15T215 -19Q210 -22 197 -22Q178 -22 176 -15Q176 -12 154 304T131 622Q129 631 121 633T82 637H58Q51 644 51 648Q52 671 64 683H76Q118 680 176 680Q301 680 313 683H323Q329 677 329 674T327 656Q322 641 318 637H297Q236 634 232 620Q262 160 266 136L501 550L499 587Q496 629 489 632Q483 636 447 637Q428 637 422 639T416 648Q416 650 418 660Q419 664 420 669T421 676T424 680T428 682T436 683Z"></path></g><g data-mml-node="mi" transform="translate(10964.2, 0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(11430.2, 0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(11775.2, 0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(12252.2, 0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="msub" transform="translate(12828.2, 0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(361, -150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(13705.4, 0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(14705.6, 0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mi" transform="translate(15456.6, 0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(15907.6, 0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(16252.6, 0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(16737.6, 0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(17188.6, 0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(17533.6, 0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"></path></g><g data-mml-node="mi" transform="translate(17894.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(18384.6, 0)"><path data-c="1D439" d="M48 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H742Q749 676 749 669Q749 664 736 557T722 447Q720 440 702 440H690Q683 445 683 453Q683 454 686 477T689 530Q689 560 682 579T663 610T626 626T575 633T503 634H480Q398 633 393 631Q388 629 386 623Q385 622 352 492L320 363H375Q378 363 398 363T426 364T448 367T472 374T489 386Q502 398 511 419T524 457T529 475Q532 480 548 480H560Q567 475 567 470Q567 467 536 339T502 207Q500 200 482 200H470Q463 206 463 212Q463 215 468 234T473 274Q473 303 453 310T364 317H309L277 190Q245 66 245 60Q245 46 334 46H359Q365 40 365 39T363 19Q359 6 353 0H336Q295 2 185 2Q120 2 86 2T48 1Z"></path></g><g data-mml-node="mi" transform="translate(19133.6, 0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(19705.6, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="msub" transform="translate(20305.6, 0)"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mi" transform="translate(433, -150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></p>
<p>代码中大部分采用字典的形式进行传输，所以需要一个映射关系，<code>pkg/scheduler/framework/plugins/registry.go</code>文件中记录了默认算法的名称映射关系。</p>
<p>优选的优先级函数包括: </p>
<h4 id="Name-noderesources-BalancedAllocationName-Weight-1"><a href="#Name-noderesources-BalancedAllocationName-Weight-1" class="headerlink" title="{Name: noderesources.BalancedAllocationName, Weight: 1}"></a>{Name: noderesources.BalancedAllocationName, Weight: 1}</h4><p>CPU和内存使用率越接近的节点权重越高。该策略均衡了节点CPU和内存的配比，尽量选择在部署Pod后各项资源更均衡的机器。</p>
<h4 id="Name-imagelocality-Name-Weight-1"><a href="#Name-imagelocality-Name-Weight-1" class="headerlink" title="{Name: imagelocality.Name, Weight: 1}"></a>{Name: imagelocality.Name, Weight: 1}</h4><p>尽量调度到Pod所需镜像的节点。检查Node是否存在Pod所需镜像：如果不存在，返回0分；如果存在，则镜像越大得分越高</p>
<h4 id="Name-interpodaffinity-Name-Weight-1"><a href="#Name-interpodaffinity-Name-Weight-1" class="headerlink" title="{Name: interpodaffinity.Name, Weight: 1}"></a>{Name: interpodaffinity.Name, Weight: 1}</h4><p>叠加该节点已调度的每个Pod的权重，权重可配置文件里设定，通常亲和性越强的Pod权重越高，如果Pod满足要求则将加到权重和，具有最高权重和的节点是最优的。</p>
<h4 id="Name-noderesources-LeastAllocatedName-Weight-1"><a href="#Name-noderesources-LeastAllocatedName-Weight-1" class="headerlink" title="{Name: noderesources.LeastAllocatedName, Weight: 1}"></a>{Name: noderesources.LeastAllocatedName, Weight: 1}</h4><p>尽量将Pod调度到计算资源占用比较小的Node上，这里涉及两种计算资源：内存和CPU</p>
<h4 id="Name-nodeaffinity-Name-Weight-1"><a href="#Name-nodeaffinity-Name-Weight-1" class="headerlink" title="{Name: nodeaffinity.Name, Weight: 1}"></a>{Name: nodeaffinity.Name, Weight: 1}</h4><p>nodeselector 按照节点选择器选择</p>
<h4 id="Name-nodepreferavoidpods-Name-Weight-10000"><a href="#Name-nodepreferavoidpods-Name-Weight-10000" class="headerlink" title="{Name: nodepreferavoidpods.Name, Weight: 10000}"></a>{Name: nodepreferavoidpods.Name, Weight: 10000}</h4><p>避免将ReplicationController或ReplicaSet调度到节点。如果Pod由RC或者RS的Controller调度，则得分为0，不对最终加权得分产生影响；如果不是，则总分为100000，意味着覆盖其他策略，直接决定最优节点。</p>
<h4 id="Name-podtopologyspread-Name-Weight-2"><a href="#Name-podtopologyspread-Name-Weight-2" class="headerlink" title="{Name: podtopologyspread.Name, Weight: 2}"></a>{Name: podtopologyspread.Name, Weight: 2}</h4><p>拓扑约束</p>
<h4 id="Name-tainttoleration-Name-Weight-1"><a href="#Name-tainttoleration-Name-Weight-1" class="headerlink" title="{Name: tainttoleration.Name, Weight: 1}"></a>{Name: tainttoleration.Name, Weight: 1}</h4><p>污点容忍</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux资源管理之cgroups简介</title>
    <url>/2020/09/13/linux/cgroup/</url>
    <content><![CDATA[<h1 id="Linux资源管理之cgroups简介"><a href="#Linux资源管理之cgroups简介" class="headerlink" title="Linux资源管理之cgroups简介"></a>Linux资源管理之cgroups简介</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>cgroups 是Linux内核提供的一种可以限制单个进程或者多个进程所使用资源的机制，可以对 cpu，内存等资源实现精细化的控制，目前越来越火的轻量级容器 Docker 就使用了 cgroups 提供的资源限制能力来完成cpu，内存等部分的资源控制。</p>
<p>另外，开发者也可以使用 cgroups 提供的精细化控制能力，限制某一个或者某一组进程的资源使用。比如在一个既部署了前端 web 服务，也部署了后端计算模块的八核服务器上，可以使用 cgroups 限制 web server 仅可以使用其中的六个核，把剩下的两个核留给后端计算模块。</p>
<a id="more"></a>

<h2 id="概念及原理"><a href="#概念及原理" class="headerlink" title="概念及原理"></a>概念及原理</h2><h3 id="cgroups子系统"><a href="#cgroups子系统" class="headerlink" title="cgroups子系统"></a>cgroups子系统</h3><p>cgroups 的全称是control groups，cgroups为每种可以控制的资源定义了一个子系统。典型的子系统介绍如下：</p>
<ol>
<li>cpu 子系统，主要限制进程的 cpu 使用率。</li>
<li>cpuacct 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。</li>
<li>cpuset 子系统，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。</li>
<li>memory 子系统，可以限制进程的 memory 使用量。</li>
<li>blkio 子系统，可以限制进程的块设备 io。</li>
<li>devices 子系统，可以控制进程能够访问某些设备。</li>
<li>net_cls 子系统，可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块（traffic control）对数据包进行控制。</li>
<li>freezer 子系统，可以挂起或者恢复 cgroups 中的进程。</li>
<li>ns 子系统，可以使不同 cgroups 下面的进程使用不同的 namespace。</li>
</ol>
<p>这里面每一个子系统都需要与内核的其他模块配合来完成资源的控制，比如对 cpu 资源的限制是通过进程调度模块根据 cpu 子系统的配置来完成的；对内存资源的限制则是内存模块根据 memory 子系统的配置来完成的，而对网络数据包的控制则需要 Traffic Control 子系统来配合完成。本文不会讨论内核是如何使用每一个子系统来实现资源的限制，而是重点放在内核是如何把 cgroups 对资源进行限制的配置有效的组织起来的，和内核如何把cgroups 配置和进程进行关联的，以及内核是如何通过 cgroups 文件系统把cgroups的功能暴露给用户态的。</p>
<h3 id="cgroups-层级结构（Hierarchy）"><a href="#cgroups-层级结构（Hierarchy）" class="headerlink" title="cgroups 层级结构（Hierarchy）"></a>cgroups 层级结构（Hierarchy）</h3><p>内核使用 cgroup 结构体来表示一个 control group 对某一个或者某几个 cgroups 子系统的资源限制。cgroup 结构体可以组织成一颗树的形式，每一棵cgroup 结构体组成的树称之为一个 cgroups 层级结构。cgroups层级结构可以 attach 一个或者几个 cgroups 子系统，当前层级结构可以对其 attach 的 cgroups 子系统进行资源的限制。每一个 cgroups 子系统只能被 attach 到一个 cpu 层级结构中。</p>
<p><img src="/images/linux/cgroup/cgroup1.png" alt="cgroups"></p>
<p>比如上图表示两个cgroups层级结构，每一个层级结构中是一颗树形结构，树的每一个节点是一个 cgroup 结构体（比如cpu_cgrp, memory_cgrp)。第一个 cgroups 层级结构 attach 了 cpu 子系统和 cpuacct 子系统， 当前 cgroups 层级结构中的 cgroup 结构体就可以对 cpu 的资源进行限制，并且对进程的 cpu 使用情况进行统计。 第二个 cgroups 层级结构 attach 了 memory 子系统，当前 cgroups 层级结构中的 cgroup 结构体就可以对 memory 的资源进行限制。</p>
<p>在每一个 cgroups 层级结构中，每一个节点（cgroup 结构体）可以设置对资源不同的限制权重。比如上图中 cgrp1 组中的进程可以使用60%的 cpu 时间片，而 cgrp2 组中的进程可以使用20%的 cpu 时间片。</p>
<h3 id="cgroups与进程"><a href="#cgroups与进程" class="headerlink" title="cgroups与进程"></a>cgroups与进程</h3><p>上面的小节提到了内核使用 cgroups 子系统对系统的资源进行限制，也提到了 cgroups 子系统需要 attach 到 cgroups 层级结构中来对进程进行资源控制。本小节重点关注一下内核是如何把进程与 cgroups 层级结构联系起来的。</p>
<p>在创建了 cgroups 层级结构中的节点（cgroup 结构体）之后，可以把进程加入到某一个节点的控制任务列表中，一个节点的控制列表中的所有进程都会受到当前节点的资源限制。同时某一个进程也可以被加入到不同的 cgroups 层级结构的节点中，因为不同的 cgroups 层级结构可以负责不同的系统资源。所以说进程和 cgroup 结构体是一个多对多的关系。c</p>
<p><img src="/images/linux/cgroup/cgroup2.png" alt="cgroups"></p>
<p>上面这个图从整体结构上描述了进程与 cgroups 之间的关系。最下面的<code>P</code>代表一个进程。每一个进程的描述符中有一个指针指向了一个辅助数据结构<code>css_set</code>（cgroups subsystem set）。 指向某一个<code>css_set</code>的进程会被加入到当前<code>css_set</code>的进程链表中。一个进程只能隶属于一个<code>css_set</code>，一个<code>css_set</code>可以包含多个进程，隶属于同一<code>css_set</code>的进程受到同一个<code>css_set</code>所关联的资源限制。</p>
<p>上图中的”M×N Linkage”说明的是<code>css_set</code>通过辅助数据结构可以与 cgroups 节点进行多对多的关联。但是 cgroups 的实现不允许<code>css_set</code>同时关联同一个cgroups层级结构下多个节点。 这是因为 cgroups 对同一种资源不允许有多个限制配置。</p>
<p>一个<code>css_set</code>关联多个 cgroups 层级结构的节点时，表明需要对当前<code>css_set</code>下的进程进行多种资源的控制。而一个 cgroups 节点关联多个<code>css_set</code>时，表明多个<code>css_set</code>下的进程列表受到同一份资源的相同限制。</p>
<h3 id="cgroups文件系统"><a href="#cgroups文件系统" class="headerlink" title="cgroups文件系统"></a>cgroups文件系统</h3><p>Linux 使用了多种数据结构在内核中实现了 cgroups 的配置，关联了进程和 cgroups 节点，那么 Linux 又是如何让用户态的进程使用到 cgroups 的功能呢？ Linux内核有一个很强大的模块叫 VFS (Virtual File System)。 VFS 能够把具体文件系统的细节隐藏起来，给用户态进程提供一个统一的文件系统 API 接口。 cgroups 也是通过 VFS 把功能暴露给用户态的，cgroups 与 VFS 之间的衔接部分称之为 cgroups 文件系统。下面先介绍一下 VFS 的基础知识，然后再介绍下 cgroups 文件系统的实现。</p>
<h4 id="VFS"><a href="#VFS" class="headerlink" title="VFS"></a>VFS</h4><p>VFS 是一个内核抽象层，能够隐藏具体文件系统的实现细节，从而给用户态进程提供一套统一的 API 接口。VFS 使用了一种通用文件系统的设计，具体的文件系统只要实现了 VFS 的设计接口，就能够注册到 VFS 中，从而使内核可以读写这种文件系统。 这很像面向对象设计中的抽象类与子类之间的关系，抽象类负责对外接口的设计，子类负责具体的实现。其实，VFS本身就是用 c 语言实现的一套面向对象的接口。</p>
<p>VFS 通用文件模型中包含以下四种元数据结构：</p>
<ol>
<li>超级块对象(superblock object)，用于存放已经注册的文件系统的信息。比如ext2，ext3等这些基础的磁盘文件系统，还有用于读写socket的socket文件系统，以及当前的用于读写cgroups配置信息的 cgroups 文件系统等。</li>
<li>索引节点对象(inode object)，用于存放具体文件的信息。对于一般的磁盘文件系统而言，inode 节点中一般会存放文件在硬盘中的存储块等信息；对于socket文件系统，inode会存放socket的相关属性，而对于cgroups这样的特殊文件系统，inode会存放与 cgroup 节点相关的属性信息。这里面比较重要的一个部分是一个叫做 inode_operations 的结构体，这个结构体定义了在具体文件系统中创建文件，删除文件等的具体实现。</li>
<li>文件对象(file object)，一个文件对象表示进程内打开的一个文件，文件对象是存放在进程的文件描述符表里面的。同样这个文件中比较重要的部分是一个叫 file_operations 的结构体，这个结构体描述了具体的文件系统的读写实现。当进程在某一个文件描述符上调用读写操作时，实际调用的是 file_operations 中定义的方法。 对于普通的磁盘文件系统，file_operations 中定义的就是普通的块设备读写操作；对于socket文件系统，file_operations 中定义的就是 socket 对应的 send/recv 等操作；而对于cgroups这样的特殊文件系统，file_operations 中定义的就是操作 cgroup 结构体等具体的实现。</li>
<li>目录项对象(dentry object)，在每个文件系统中，内核在查找某一个路径中的文件时，会为内核路径上的每一个分量都生成一个目录项对象，通过目录项对象能够找到对应的 inode 对象，目录项对象一般会被缓存，从而提高内核查找速度。</li>
</ol>
<h4 id="cgroups文件系统的实现"><a href="#cgroups文件系统的实现" class="headerlink" title="cgroups文件系统的实现"></a>cgroups文件系统的实现</h4><p>基于 VFS 实现的文件系统,都必须实现 VFS 通用文件模型定义的这些对象，并实现这些对象中定义的部分函数。cgroup 文件系统也不例外,下面来看一下 cgroups 中这些对象的定义。</p>
<p>首先看一下 cgroups 文件系统类型的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">cgroup_fs_type</span> = &#123;</span></span><br><span class="line">        .name = <span class="string">&quot;cgroup&quot;</span>,</span><br><span class="line">        .mount = cgroup_mount,</span><br><span class="line">        .kill_sb = cgroup_kill_sb,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里面两个函数分别代表安装和卸载某一个 cgroup 文件系统所需要执行的函数。每次把某一个 cgroups 子系统安装到某一个装载点的时候，cgroup_mount 方法就会被调用，这个方法会生成一个 cgroups_root（cgroups层级结构的根）并封装成超级快对象。</p>
<p>然后看一下 cgroups 超级块对象定义的操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">cgroup_ops</span> = &#123;</span></span><br><span class="line">        .statfs = simple_statfs,</span><br><span class="line">        .drop_inode = generic_delete_inode,</span><br><span class="line">        .show_options = cgroup_show_options,</span><br><span class="line">        .remount_fs = cgroup_remount,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里只有部分函数的实现，这是因为对于特定的文件系统而言，所支持的操作可能仅是 super_operations 中所定义操作的一个子集，比如说对于块设备上的文件对象，肯定是支持类似 fseek 的查找某个位置的操作，但是对于 socket 或者 cgroups 这样特殊的文件系统，就不支持这样的操作。</p>
<p>同样简单看下 cgroups 文件系统对 inode 对象和 file 对象定义的特殊实现函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">cgroup_dir_inode_operations</span> = &#123;</span></span><br><span class="line">        .lookup = cgroup_lookup,</span><br><span class="line">        .mkdir = cgroup_mkdir,</span><br><span class="line">        .rmdir = cgroup_rmdir,</span><br><span class="line">        .rename = cgroup_rename,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">cgroup_file_operations</span> = &#123;</span></span><br><span class="line">        .read = cgroup_file_read,</span><br><span class="line">        .write = cgroup_file_write,</span><br><span class="line">        .llseek = generic_file_llseek,</span><br><span class="line">        .open = cgroup_file_open,</span><br><span class="line">        .release = cgroup_file_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本文并不去研究这些函数的代码实现是什么样的，但是从这些代码可以推断出，cgroups 通过实现 VFS 的通用文件系统模型，把维护 cgroups 层级结构的细节，隐藏在 cgroups 文件系统的这些实现函数中。</p>
<p>从另一个方面说，用户在用户态对 cgroups 文件系统的操作，通过 VFS 转化为对 cgroups 层级结构的维护。通过这样的方式，内核把 cgroups 的功能暴露给了用户态的进程。</p>
<h2 id="cgroups使用方法"><a href="#cgroups使用方法" class="headerlink" title="cgroups使用方法."></a>cgroups使用方法.</h2><h3 id="cgroups文件系统挂载"><a href="#cgroups文件系统挂载" class="headerlink" title="cgroups文件系统挂载"></a>cgroups文件系统挂载</h3><p>Linux中，用户可以使用mount命令挂载 cgroups 文件系统，格式为: <code>mount -t cgroup -o subsystems name /cgroup/name</code>，其中 subsystems 表示需要挂载的 cgroups 子系统， /cgroup/name 表示挂载点，如上文所提，这条命令同时在内核中创建了一个cgroups 层级结构。</p>
<p>比如挂载 cpuset, cpu, cpuacct, memory 4个subsystem到/cgroup/cpu_and_mem 目录下，就可以使用 <code>mount -t cgroup -o remount,cpu,cpuset,memory cpu_and_mem /cgroup/cpu_and_mem</code></p>
<p>在centos下面，在使用<code>yum install libcgroup</code>安装了cgroups模块之后，在 /etc/cgconfig.conf 文件中会自动生成 cgroups 子系统的挂载点:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mount &#123;</span><br><span class="line">    cpuset  = /cgroup/cpuset;</span><br><span class="line">    cpu = /cgroup/cpu;</span><br><span class="line">    cpuacct = /cgroup/cpuacct;</span><br><span class="line">    memory  = /cgroup/memory;</span><br><span class="line">    devices = /cgroup/devices;</span><br><span class="line">    freezer = /cgroup/freezer;</span><br><span class="line">    net_cls = /cgroup/net_cls;</span><br><span class="line">    blkio   = /cgroup/blkio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的每一条配置都等价于展开的 mount 命令，例如<code>mount -t cgroup -o cpuset cpuset /cgroup/cpuset</code>。这样系统启动之后会自动把这些子系统挂载到相应的挂载点上。</p>
<h3 id="子节点和进程"><a href="#子节点和进程" class="headerlink" title="子节点和进程"></a>子节点和进程</h3><p>挂载某一个 cgroups 子系统到挂载点之后，就可以通过在挂载点下面建立文件夹或者使用cgcreate命令的方法创建 cgroups 层级结构中的节点。比如通过命令<code>cgcreate -t sankuai:sankuai -g cpu:test</code>就可以在 cpu 子系统下建立一个名为 test 的节点。结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@idx cpu]# ls</span><br><span class="line">cgroup.event_control  cgroup.procs  cpu.cfs_period_us  cpu.cfs_quota_us  cpu.rt_period_us   cpu.rt_runtime_us  cpu.shares  cpu.stat  lxc  notify_on_release  release_agent  tasks  test</span><br></pre></td></tr></table></figure>

<p>然后可以通过写入需要的值到 test 下面的不同文件，来配置需要限制的资源。每个子系统下面都可以进行多种不同的配置，需要配置的参数各不相同，详细的参数设置需要参考 cgroups 手册。使用 cgset 命令也可以设置 cgroups 子系统的参数，格式为 <code>cgset -r parameter=value path_to_cgroup</code>。</p>
<p>当需要删除某一个 cgroups 节点的时候，可以使用 cgdelete 命令，比如要删除上述的 test 节点，可以使用 <code>cgdelete -r cpu:test</code>命令进行删除</p>
<p>把进程加入到 cgroups 子节点也有多种方法，可以直接把 pid 写入到子节点下面的 task 文件中。也可以通过 cgclassify 添加进程，格式为 <code>cgclassify -g subsystems:path_to_cgroup pidlist</code>，也可以直接使用 cgexec 在某一个 cgroups 下启动进程，格式为<code>gexec -g subsystems:path_to_cgroup command arguments</code>.</p>
<h2 id="实践中的例子"><a href="#实践中的例子" class="headerlink" title="实践中的例子"></a>实践中的例子</h2><p>相信大多数人都没有读过 Docker 的源代码，但是通过这篇文章，可以估计 Docker 在实现不同的 Container 之间资源隔离和控制的时候，是可以创建比较复杂的 cgroups 节点和配置文件来完成的。然后对于同一个 Container 中的进程，可以把这些进程 PID 添加到同一组 cgroups 子节点中已达到对这些进程进行同样的资源限制。</p>
<p>通过各大互联网公司在网上的技术文章，也可以看到很多公司的云平台都是基于 cgroups 技术搭建的，其实也都是把进程分组，然后把整个进程组添加到同一组 cgroups 节点中，受到同样的资源限制。</p>
<p>笔者所在的广告组，有一部分任务是给合作的广告投放网站生成“商品信息”，广告投放网站使用这些信息，把广告投放在他们各自的网站上。但是有时候会有恶意的爬虫过来爬取商品信息，所以我们生成了另外“一小份”数据供优先级较低的用户下载，这时候基本能够区分开大部分恶意爬虫。对于这样的“一小份”数据，对及时更新的要求不高，生成商品信息又是一个比较费资源的任务，所以我们把这个任务的cpu资源使用率限制在了50%。</p>
<p>首先在 cpu 子系统下面创建了一个 halfapi 的子节点：<code>cgcreate abc:abc -g cpu:halfapi</code>。</p>
<p>然后在配置文件中写入配置数据：<code>echo 50000 &gt; /cgroup/cpu/halfapi/cpu.cfs_quota_us</code>。<code>cpu.cfs_quota_us</code>中的默认值是100000，写入50000表示只能使用50%的 cpu 运行时间。</p>
<p>最后在这个cgroups中启动这个任务：<code>cgexec -g &quot;cpu:/halfapi&quot; php halfapi.php half &gt;/dev/null 2&gt;&amp;1</code></p>
<p>在 cgroups 引入内核之前，想要完成上述的对某一个进程的 cpu 使用率进行限制，只能通过 nice 命令调整进程的优先级，或者 cpulimit 命令限制进程使用进程的 cpu 使用率。但是这些命令的缺点是无法限制一个进程组的资源使用限制，也就无法完成 Docker 或者其他云平台所需要的这一类轻型容器的资源限制要求。</p>
<p>同样，在 cgroups 之前，想要完成对某一个或者某一组进程的物理内存使用率的限制，几乎是不可能完成的。使用 cgroups 提供的功能，可以轻易的限制系统内某一组服务的物理内存占用率。 对于网络包，设备访问或者io资源的控制，cgroups 同样提供了之前所无法完成的精细化控制。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>pod 的创建过程</title>
    <url>/2020/09/08/k8s/what_happen_apply_yaml/</url>
    <content><![CDATA[<h1 id="pod的创建过程"><a href="#pod的创建过程" class="headerlink" title="pod的创建过程"></a>pod的创建过程</h1><p>kubernetes 中各个组件都是以 <code>watch</code> 的方式从<code>kube-apiserver</code>中获取信息。当然，这其中也用到了<code>informer</code>的缓存机制</p>
<a id="more"></a>

<p><img src="/images/k8s/create_pod.png" alt="pod的创建"></p>
<ol>
<li>用户通过Kubectl提交Pod Spec给API Server；</li>
<li>API Server将Pod对象的信息存入Etcd中</li>
<li>Pod的创建会生成一个事件，返回给API Server</li>
<li>Controller监听到这个事件</li>
<li>Controller知道这个Pod要mount一个盘，于是查看是否有能够满足条件的PV</li>
<li>假设有满足条件的PV，就将Pod和PV绑定在一起，将绑定关系告知API Server</li>
<li>API Server将绑定信息写入Etcd中</li>
<li>生成一个Pod Update事件</li>
<li>Scheduler监听到了这个事件</li>
<li>Scheduler需要为Pod选择一个Node</li>
<li>假设有满足条件的Node，就讲Pod和Node绑定在一起，将绑定关系告知API Server</li>
<li>API Server将绑定信息写入Etcd中</li>
<li>生成一个Pod Update事件</li>
<li>Kubelet监听到了这个事件，开始创建Pod</li>
<li>Kubelet告知CRI去下载镜像</li>
<li>Kubelet告知CRI去运行容器</li>
<li>CRI调用Docker运行容器</li>
<li>Kubelet告知Volume Manager，将盘挂在到Node上，然后mount到Pod中</li>
<li>CRI调用CNI给容器配置网络</li>
</ol>
<p><img src="/images/k8s/kubelet_create_pod.png" alt="pod的创建"></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2020/07/29/interview/Python/</url>
    <content><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-Python-%E7%94%9F%E6%88%90%E5%99%A8">什么是 Python 生成器？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-Python-%E8%BF%AD%E4%BB%A3%E5%99%A8">什么是 Python 迭代器？</a></li>
<li><a href="#list-%E5%92%8C-tuple-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">list 和 tuple 有什么区别？</a></li>
<li><a href="#Python-%E4%B8%AD%E7%9A%84-list-%E5%92%8C-dict-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">Python 中的 list 和 dict 是怎么实现的？</a></li>
<li><a href="#Python-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%BE%BE%E5%88%B0%E5%A4%9A%E6%A0%B8CPU%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E5%90%97">Python 中使用多线程可以达到多核CPU一起使用吗？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A3%85%E9%A5%B0%E5%99%A8">什么是装饰器？</a></li>
<li><a href="#Python-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">Python 如何进行内存管理？</a></li>
<li><a href="#Python-%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">Python 中的垃圾回收机制？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">什么是 lambda 表达式？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D">什么是深拷贝和浅拷贝？</a></li>
<li><a href="#%E5%8F%8C%E7%AD%89%E4%BA%8E%E5%92%8C-is-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">双等于和 is 有什么区别？</a></li>
<li><a href="#%E5%85%B6%E5%AE%83-Python-%E7%9F%A5%E8%AF%86%E7%82%B9">其它 Python 知识点</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<a id="more"></a>

<hr>
<h2 id="什么是-Python-生成器？"><a href="#什么是-Python-生成器？" class="headerlink" title="什么是 Python 生成器？"></a>什么是 Python 生成器？</h2><p>generator，有两种产生生成器对象的方式：一种是列表生成式加括号：</p>
<p><code>g1 = (x for x in range(10))</code></p>
<p>一种是在函数定义中包含<code>yield</code>关键字：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">max</span>):</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line"></span><br><span class="line">g2 = fib(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>对于generator对象g1和g2，可以通过<code>next(g1)</code>不断获得下一个元素的值，如果没有更多的元素，就会报错<code>StopIteration</code></p>
<p>也可以通过for循环获得元素的值。</p>
<p>生成器的好处是不用占用很多内存，只需要在用的时候计算元素的值就行了。</p>
<h2 id="什么是-Python-迭代器？"><a href="#什么是-Python-迭代器？" class="headerlink" title="什么是 Python 迭代器？"></a>什么是 Python 迭代器？</h2><p>Python中可以用于for循环的，叫做可迭代<code>Iterable</code>，包括list/set/tuple/str/dict等数据结构以及生成器；可以用以下语句判断一个对象是否是可迭代的：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line">isinstance(x, Iterable)</span><br></pre></td></tr></table></figure>

<p>迭代器<code>Iterator</code>，是指可以被<code>next()</code>函数调用并不断返回下一个值，直到<code>StopIteration</code>；生成器都是Iterator，而列表等数据结构不是；可以通过以下语句将list变为Iterator：</p>
<p><code>iter([1,2,3,4,5])</code></p>
<p>生成器都是Iterator，但迭代器不一定是生成器。</p>
<h2 id="list-和-tuple-有什么区别？"><a href="#list-和-tuple-有什么区别？" class="headerlink" title="list 和 tuple 有什么区别？"></a>list 和 tuple 有什么区别？</h2><ul>
<li>list 长度可变，tuple不可变；</li>
<li>list 中元素的值可以改变，tuple 不能改变；</li>
<li>list 支持<code>append</code>; <code>insert</code>; <code>remove</code>; <code>pop</code>等方法，tuple 都不支持</li>
</ul>
<h2 id="Python-中的-list-和-dict-是怎么实现的？"><a href="#Python-中的-list-和-dict-是怎么实现的？" class="headerlink" title="Python 中的 list 和 dict 是怎么实现的？"></a>Python 中的 list 和 dict 是怎么实现的？</h2><h2 id="Python-中使用多线程可以达到多核CPU一起使用吗？"><a href="#Python-中使用多线程可以达到多核CPU一起使用吗？" class="headerlink" title="Python 中使用多线程可以达到多核CPU一起使用吗？"></a>Python 中使用多线程可以达到多核CPU一起使用吗？</h2><p>Python中有一个被称为Global Interpreter Lock（GIL）的东西，它会确保任何时候你的多个线程中，只有一个被执行。线程的执行速度非常之快，会让你误以为线程是并行执行的，但是实际上都是轮流执行。经过GIL这一道关卡处理，会增加执行的开销。</p>
<p>可以通过多进程实现多核任务。</p>
<h2 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h2><h2 id="Python-中的垃圾回收机制？"><a href="#Python-中的垃圾回收机制？" class="headerlink" title="Python 中的垃圾回收机制？"></a>Python 中的垃圾回收机制？</h2><p><a class="link"   href="https://www.jianshu.com/p/1e375fb40506" >Python垃圾回收机制–完美讲解!<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="什么是-lambda-表达式？"><a href="#什么是-lambda-表达式？" class="headerlink" title="什么是 lambda 表达式？"></a>什么是 lambda 表达式？</h2><p>简单来说，lambda表达式通常是当你需要使用一个函数，但是又不想费脑袋去命名一个函数的时候使用，也就是通常所说的匿名函数。</p>
<p>lambda表达式一般的形式是：关键词lambda后面紧接一个或多个参数，紧接一个冒号“：”，紧接一个表达式</p>
<h2 id="什么是深拷贝和浅拷贝？"><a href="#什么是深拷贝和浅拷贝？" class="headerlink" title="什么是深拷贝和浅拷贝？"></a>什么是深拷贝和浅拷贝？</h2><p>赋值（=），就是创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。</p>
<p>浅拷贝 copy.copy：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变）</p>
<p>深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的deep.deepcopy()函数}</p>
<h2 id="双等于和-is-有什么区别？"><a href="#双等于和-is-有什么区别？" class="headerlink" title="双等于和 is 有什么区别？"></a>双等于和 is 有什么区别？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;is&#96;&#96;&#96;比较的是两个变量的 id，即&#96;&#96;&#96;id(a) &#x3D;&#x3D; id(b)&#96;&#96;&#96;，只有两个变量指向同一个对象的时候，才会返回True</span><br><span class="line"></span><br><span class="line">但是需要注意的是，比如以下代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>a = 2<br>b = 2<br>print(a is b)</p>
<pre><code>
按照上面的解释，应该会输出False，但是事实上会输出True，这是因为Python中对小数据有缓存机制，-5~256之间的数据都会被缓存。

------

## 其它 Python 知识点

### 类型转换
- list(x)
- str(x)
- set(x)
- int(x)
- tuple(x)

### try...except

### list
- ```lst[a:b]```：左闭右开
- ```lst.append(value)```：在末尾添加元素，复杂度O(1)
- ```lst.pop()```：弹出列表末尾元素，复杂度O(1)
- ```lst.pop(index)```：弹出任意位置元素，将后面的元素前移，复杂度O(n)
- ```lst.insert(index, value)```：插入元素，后面的元素后移，复杂度O(n)
- ```lst.remove(value)```：移除等于value的第一个元素，后面的元素前移，复杂度O(n)
- ```lst.count(value)```：计数值为value的元素个数
- ```lst.sort(reverse = False)```：排序，默认升序

### 参考
- [生成器 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1016959663602400/1017318207388128)
- [Python中的is和==的区别](https://www.cnblogs.com/yjtxin/p/11793243.html)</code></pre>
]]></content>
      <categories>
        <category>技术文章</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生</title>
    <url>/2020/07/29/others/cncf/</url>
    <content><![CDATA[<h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><p>云原生，作为这个时期最热门的名词，在微服务的驱动下，更加加速了他的发展。</p>
<a id="more"></a>

<h1 id="云原生的设计理念"><a href="#云原生的设计理念" class="headerlink" title="云原生的设计理念"></a>云原生的设计理念</h1><p>云原生系统的设计理念如下:</p>
<ul>
<li>面向分布式设计（Distribution）：容器、微服务、API 驱动的开发；</li>
<li>面向配置设计（Configuration）：一个镜像，多个环境配置；</li>
<li>面向韧性设计（Resistancy）：故障容忍和自愈；</li>
<li>面向弹性设计（Elasticity）：弹性扩展和对环境变化（负载）做出响应；</li>
<li>面向交付设计（Delivery）：自动拉起，缩短交付时间；</li>
<li>面向性能设计（Performance）：响应式，并发和资源高效利用；</li>
<li>面向自动化设计（Automation）：自动化的 DevOps；</li>
<li>面向诊断性设计（Diagnosability）：集群级别的日志、metric 和追踪；</li>
<li>面向安全性设计（Security）：安全端点、API Gateway、端到端加密；</li>
</ul>
<h1 id="实现云原生应用程序所需特性的常用方法"><a href="#实现云原生应用程序所需特性的常用方法" class="headerlink" title="实现云原生应用程序所需特性的常用方法"></a>实现云原生应用程序所需特性的常用方法</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>拆就完事了</p>
<h2 id="健康报告"><a href="#健康报告" class="headerlink" title="健康报告"></a>健康报告</h2><p>程序自身的心跳接口，只要正常，说明程序正常。</p>
<p>应用程序不仅仅有健康或不健康的状态。它们将经历一个启动和关闭过程，在这个过程中它们应该通过健康检查，报告它们的状态。如果应用程序可以让平台准确了解它所处的状态，平台将更容易知道如何操作它。</p>
<p>一个很好的例子就是当平台需要知道应用程序何时可以接收流量。在应用程序启动时，如果它不能正确处理流量，它就应该表现为未准备好。此额外状态将防止应用程序过早终止，因为如果运行状况检查失败，平台可能会认为应用程序不健康，并且会反复停止或重新启动它。</p>
<p>应用程序健康只是能够自动化应用程序生命周期的一部分。除了知道应用程序是否健康之外，您还需要知道应用程序是否正在进行哪些工作。这些信息来自遥测数据。</p>
<h2 id="遥测数据"><a href="#遥测数据" class="headerlink" title="遥测数据"></a>遥测数据</h2><p>遥测数据是进行决策所需的信息。确实，遥测数据可能与健康报告重叠，但它们有不同的用途。健康报告通知我们应用程序生命周期状态，而遥测数据通知我们应用程序业务目标。</p>
<p>您测量的指标有时称为服务级指标（SLI）或关键性能指标（KPI）。这些是特定于应用程序的数据，可以确保应用程序的性能处于服务级别目标（SLO）内。</p>
<blockquote>
<p>请求数量<br>错误率<br>时长</p>
</blockquote>
<h2 id="弹性"><a href="#弹性" class="headerlink" title="弹性"></a>弹性</h2><h3 id="为失败设计"><a href="#为失败设计" class="headerlink" title="为失败设计"></a>为失败设计</h3><p>唯一永远不会失败的系统是那些让你活着的系统（例如心脏植入物和刹车系统）。如果您的服务永远不会停止运行，您需要花费太多时间设计它们来抵制故障，并且没有足够的时间增加业务价值。您的SLO确定服务需要多长时间。您花费在工程设计上超出SLO的正常运行时间的任何资源都将被浪费掉。</p>
<p>您应该为每项服务测量两个值，即平均无故障时间（MTBF）和平均恢复时间（MTTR）。监控和指标可以让您检测您是否符合您的SLO，但运行应用程序的平台是保持高MTBF和低MTTR的关键。</p>
<p>在任何复杂的系统中，都会有失败。您可以管理硬件中的某些故障（例如，RAID和冗余电源），以及某些基础设施中的故障（例如负载平衡器）。但是因为应用程序知道他们什么时候健康，所以他们也应该尽可能地管理自己的失败。</p>
<p>设计一个以失败期望为目标的应用程序将比假定可用性的应用程序更具防御性。当故障不可避免时，将会有额外的检查，故障模式和日志内置到应用程序中。</p>
<p>知道应用程序可能失败的每种方式是不可能的。假设任何事情都可能并且可能会失败，这是一种云原生应用程序的模式。</p>
<p>您的应用程序的最佳状态是健康状态。第二好的状态是失败状态。其他一切都是非二进制的，难以监控和排除故障。 Honeycomb首席执行官CharityMajors在她的文章“Ops：现在每个人都在工作”中指出：“分布式系统永远不会起作用；它们处于部分退化服务的持续状态。接受失败，设计弹性，保护和缩小关键路径。”</p>
<p>无论发生什么故障，云原生应用程序都应该是可适应的。他们期望失败，所以他们在检测到时进行调整。</p>
<p>有些故障不能也不应该被设计到应用程序中（例如，网络分区和可用区故障）。该平台应自主处理未集成到应用程序中的故障域。</p>
<h3 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h3><p>云原生应用程序需要有一种方法来处理过载，无论它是应用程序还是负载下的相关服务。处理负载的一种方式是优雅降级。 “站点可靠性工程”一书中描述了应用程序的优雅降级，因为它提供的响应在负载过重的情况下“不如正常响应准确或含有较少数据的响应，但计算更容易”。</p>
<p>减少应用程序负载的某些方面由基础设施处理。智能负载平衡和动态扩展可以提供帮助，但是在某些时候，您的应用程序可能承受的负载比它可以处理的负载更多。云原生应用程序需要知道这种必然性并作出相应的反应。</p>
<p>优雅降级的重点是允许应用程序始终返回请求的答案。如果应用程序没有足够的本地计算资源，并且依赖服务没有及时返回信息，则这是正确的。依赖于一个或多个其他服务的服务应该可用于应答请求，即使依赖于服务不是。当服务退化时，返回部分答案或使用本地缓存中的旧信息进行答案是可能的解决方案。</p>
<h2 id="声明式的，而不是命令式的"><a href="#声明式的，而不是命令式的" class="headerlink" title="声明式的，而不是命令式的"></a>声明式的，而不是命令式的</h2><p>声明式通信模型由于多种原因而变得更加健壮。最重要的是，它规范了通信模型，并且它将功能实现从应用程序转移到远程API或服务端点，从而实现某种状态到达期望状态。这有助于简化应用程序，并使它们彼此的行为更具可预测性。</p>
]]></content>
      <categories>
        <category>技术文章</category>
        <category>概念描述</category>
      </categories>
      <tags>
        <tag>CNCF</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/07/29/interview/network/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><!-- GFM-TOC -->
<ul>
<li>传输层：TCP和UDP<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-three-way-handshake">什么是三次握手？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">什么是四次挥手？</a></li>
<li><a href="#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP如何实现流量控制？</a></li>
<li><a href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">TCP的拥塞控制是怎么实现的？</a></li>
<li><a href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB">TCP与UDP的区别</a></li>
<li><a href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7">TCP如何保证传输的可靠性</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85"><del>什么是TCP粘包？</del></a></li>
</ul>
</li>
<li>应用层：HTTP和HTTPS<ul>
<li><a href="#HTTP%E5%92%8CHTTPS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">HTTP和HTTPS有什么区别？</a></li>
<li><a href="#GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB">GET与POST的区别？</a></li>
<li><a href="#Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB">Session与Cookie的区别？</a></li>
<li><a href="#%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B-%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD">从输入网址到获得页面的过程 (越详细越好)？</a></li>
<li><a href="#HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81">HTTP请求有哪些常见状态码？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFRIP-Routing-Information-Protocol-%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE-%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">什么是RIP (距离矢量路由协议)?</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络体系结构</a></li>
<li>网络层协议<ul>
<li><a href="#IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB">IP地址的分类？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">什么叫划分子网？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE-Address-Resolution-Protocol">什么是ARP协议？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFNAT-Network-Address-Translation-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">什么是NAT (网络地址转换)？</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a><!-- GFM-TOC -->

</li>
</ul>
<a id="more"></a>

<hr>
<h3 id="什么是三次握手-three-way-handshake-？"><a href="#什么是三次握手-three-way-handshake-？" class="headerlink" title="什么是三次握手 (three-way handshake)？"></a>什么是三次握手 (three-way handshake)？</h3><p><img src="/images/interview/20191129101827556_21212.png" alt="三次握手"></p>
<ul>
<li>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；</li>
<li>第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；</li>
<li>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</li>
</ul>
<h5 id="TCP建立连接可以两次握手吗？为什么"><a href="#TCP建立连接可以两次握手吗？为什么" class="headerlink" title="TCP建立连接可以两次握手吗？为什么?"></a>TCP建立连接可以两次握手吗？为什么?</h5><details>
<summary>展开</summary>

<p>不可以。有两个原因：</p>
<p>首先，可能会出现<strong>已失效的连接请求报文段又传到了服务器端</strong>。</p>
<blockquote>
<p>client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p>
</blockquote>
<p>其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。</p>
</details>

<h5 id="可以采用四次握手吗？为什么？"><a href="#可以采用四次握手吗？为什么？" class="headerlink" title="可以采用四次握手吗？为什么？"></a>可以采用四次握手吗？为什么？</h5><details>
<summary>展开</summary>

<p>可以。但是会降低传输的效率。</p>
<p>四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。</p>
</details>

<h5 id="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"><a href="#第三次握手中，如果客户端的ACK未送达服务器，会怎样？" class="headerlink" title="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"></a>第三次握手中，如果客户端的ACK未送达服务器，会怎样？</h5><details>
<summary>展开</summary>

<p>Server端：<br>由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。</p>
<p>Client端，两种情况：  </p>
<ol>
<li>在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态  </li>
<li>在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。</details>

</li>
</ol>
<h5 id="如果已经建立了连接，但客户端出现了故障怎么办？"><a href="#如果已经建立了连接，但客户端出现了故障怎么办？" class="headerlink" title="如果已经建立了连接，但客户端出现了故障怎么办？"></a>如果已经建立了连接，但客户端出现了故障怎么办？</h5><details>
<summary>展开</summary>

<p>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
</details>

<h5 id="初始序列号是什么？"><a href="#初始序列号是什么？" class="headerlink" title="初始序列号是什么？"></a>初始序列号是什么？</h5><details>
<summary>展开</summary>

<p>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</p>
</details>

<h3 id="什么是四次挥手？"><a href="#什么是四次挥手？" class="headerlink" title="什么是四次挥手？"></a>什么是四次挥手？</h3><p>![四次挥手]/images/(interview/20191129112652915_15481.png)</p>
<ul>
<li>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</li>
<li>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li>
<li>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</li>
<li>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</li>
</ul>
<h5 id="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？"><a href="#为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？" class="headerlink" title="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？"></a>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</h5><details>
<summary>展开</summary>

<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</p>
</details>

<h5 id="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的ACK没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</h5><details>
<summary>展开</summary>

<p>客户端没有收到ACK确认，会重新发送FIN请求。</p>
</details>

<h5 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a>客户端TIME_WAIT状态的意义是什么？</h5><details>
<summary>展开</summary>

<p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。</p>
<p>MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
</details>

<h3 id="TCP如何实现流量控制？"><a href="#TCP如何实现流量控制？" class="headerlink" title="TCP如何实现流量控制？"></a>TCP如何实现流量控制？</h3><p><img src="/images/interview/20191129145400104_2106.png" alt="滑动窗口"></p>
<p>使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。</p>
<p>发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。</p>
<h5 id="什么是零窗口（接收窗口为0时会怎样）？"><a href="#什么是零窗口（接收窗口为0时会怎样）？" class="headerlink" title="什么是零窗口（接收窗口为0时会怎样）？"></a>什么是零窗口（接收窗口为0时会怎样）？</h5><details>
<summary>展开</summary>

<p>如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。</p>
</details>

<h3 id="TCP的拥塞控制是怎么实现的？"><a href="#TCP的拥塞控制是怎么实现的？" class="headerlink" title="TCP的拥塞控制是怎么实现的？"></a>TCP的拥塞控制是怎么实现的？</h3><p><img src="/images/interview/20191129153624025_28293.png" alt="拥塞控制"></p>
<p>拥塞控制主要由四个算法组成：<strong>慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）</strong></p>
<ol>
<li>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍</li>
</ol>
<p><img src="/images/interview/20191129155345024_11142.png" alt="slow start"></p>
<ol start="2">
<li><p>拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.  </p>
<blockquote>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<strong>（这是不使用快重传的情况）</strong></p>
</blockquote>
</li>
<li><p>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
</li>
</ol>
<p><img src="/images/interview/20191129161026032_32431.png" alt="快重传"></p>
<ol start="4">
<li>快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。<br>也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。</li>
</ol>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ol>
<li>TCP是面向连接的，UDP是无连接的；<details>
<summary>什么叫无连接？</summary>

</li>
</ol>
<p>UDP发送数据之前不需要建立连接</p>
</details>

<ol start="2">
<li>TCP是可靠的，UDP不可靠；<details>
<summary>什么叫不可靠？</summary>

</li>
</ol>
<p>UDP接收方收到报文后，不需要给出任何确认</p>
</details>

<ol start="3">
<li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</li>
<li>TCP是面向字节流的，UDP是面向报文的；<details>
<summary>什么意思？</summary>

</li>
</ol>
<p>面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</p>
</details>

<ol start="5">
<li>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</li>
<li>TCP首部开销（20字节）比UDP首部开销（8字节）要大</li>
<li>UDP 的主机不需要维持复杂的连接状态表</li>
</ol>
<h5 id="什么时候选择TCP，什么时候选UDP？"><a href="#什么时候选择TCP，什么时候选UDP？" class="headerlink" title="什么时候选择TCP，什么时候选UDP？"></a>什么时候选择TCP，什么时候选UDP？</h5><details>
<summary>展开</summary>
对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失
</details>

<h5 id="HTTP可以使用UDP吗？"><a href="#HTTP可以使用UDP吗？" class="headerlink" title="HTTP可以使用UDP吗？"></a>HTTP可以使用UDP吗？</h5><details>
<summary>展开</summary>
HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠

</details>

<h5 id="面向连接和无连接的区别"><a href="#面向连接和无连接的区别" class="headerlink" title="面向连接和无连接的区别"></a>面向连接和无连接的区别</h5><details>
<summary>展开</summary>

<p>无连接的网络服务（数据报服务）– 面向连接的网络服务（虚电路服务）</p>
<p>虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；</p>
<p>数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；</p>
<p><img src="/images/interview/20191201081919108_30577.png" alt="virtual circuit"></p>
</details>

<h3 id="TCP如何保证传输的可靠性"><a href="#TCP如何保证传输的可靠性" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h3><ol>
<li>数据包校验</li>
<li>对失序数据包重新排序（TCP报文具有序列号）</li>
<li>丢弃重复数据</li>
<li>应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；</li>
<li>超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；</li>
<li>流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出</li>
</ol>
<h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol>
<li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li>
<li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li>
<li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li>
<li>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买</li>
</ol>
<h5 id="Https的连接过程？"><a href="#Https的连接过程？" class="headerlink" title="Https的连接过程？"></a>Https的连接过程？</h5><details>
<summary>展开</summary>

<ol>
<li>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</li>
<li>服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，<strong>加密公钥</strong>（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</li>
<li>客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</li>
<li>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个<strong>随机密钥</strong>（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行<strong>摘要</strong>计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</li>
<li>服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</li>
<li>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密</li>
</ol>
<p>总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。</p>
</details>

<h5 id="输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？"><a href="#输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？" class="headerlink" title="输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS？"></a>输入 <a class="link"   href="http://www.baidu.com,怎么变成/" >www.baidu.com，怎么变成<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://www.baidu.com/" >https://www.baidu.com<i class="fas fa-external-link-alt"></i></a> 的，怎么确定用HTTP还是HTTPS？</h5><details>
<summary>展开</summary>

<p><a class="link"   href="https://www.sohu.com/a/136637876_487516" >你访问的网站是如何自动切换到 HTTPS 的？<i class="fas fa-external-link-alt"></i></a></p>
<p>一种是原始的302跳转，服务器把所有的HTTp流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。<br>解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。</p>
</details>

<h5 id="HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？"><a href="#HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？" class="headerlink" title="HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？"></a>HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？</h5><details>
<summary>展开</summary>


</details>

<h5 id="什么是对称加密、非对称加密？区别是什么？"><a href="#什么是对称加密、非对称加密？区别是什么？" class="headerlink" title="什么是对称加密、非对称加密？区别是什么？"></a>什么是对称加密、非对称加密？区别是什么？</h5><details>
<summary>展开</summary>

<ul>
<li>对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4</li>
<li>非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA</li>
<li>区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）</details>

</li>
</ul>
<h5 id="数字签名、报文摘要的原理"><a href="#数字签名、报文摘要的原理" class="headerlink" title="数字签名、报文摘要的原理"></a>数字签名、报文摘要的原理</h5><details>
<summary>展开</summary>

<ul>
<li>发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。</li>
<li>摘要算法:MD5、SHA</details>

</li>
</ul>
<h3 id="GET与POST的区别？"><a href="#GET与POST的区别？" class="headerlink" title="GET与POST的区别？"></a>GET与POST的区别？</h3><ol>
<li>GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；</li>
<li>GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；</li>
<li>请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；</li>
<li>安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；</li>
<li>GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；</li>
<li>GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制</li>
</ol>
<h3 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h3><p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案</p>
<p>Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。</p>
<h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><ol>
<li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
<li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
<li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ol>
<h3 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h3><ol>
<li>2xx状态码：操作成功。200 OK</li>
<li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li>
<li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li>
<li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li>
</ol>
<h3 id="什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？"><a href="#什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？" class="headerlink" title="什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？"></a>什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？</h3><p>每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。</p>
<p>（PS：RIP是应用层协议：<a class="link"   href="https://www.zhihu.com/question/19645407" >https://www.zhihu.com/question/19645407<i class="fas fa-external-link-alt"></i></a>）</p>
<details>
<summary>优缺点</summary>

<ul>
<li>实现简单，开销小</li>
<li>随着网络规模扩大开销也会增大；</li>
<li>最大距离为15，限制了网络的规模；</li>
<li>当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器</details>

</li>
</ul>
<h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p><img src="/images/interview/20191129195451183_16713.png" alt="计算机网络体系结构"></p>
<ul>
<li>Physical, Data Link, Network, Transport, Application</li>
<li>应用层：常见协议：<ul>
<li>FTP(21端口)：文件传输协议</li>
<li>SSH(22端口)：远程登陆</li>
<li>TELNET(23端口)：远程登录</li>
<li>SMTP(25端口)：发送邮件</li>
<li>POP3(110端口)：接收邮件</li>
<li>HTTP(80端口)：超文本传输协议</li>
<li>DNS(53端口)：运行在UDP上，域名解析服务</li>
</ul>
</li>
<li>传输层：TCP/UDP</li>
<li>网络层：IP、ARP、NAT、RIP…</li>
</ul>
<details>
<summary>路由器、交换机位于哪一层？</summary>

<ul>
<li>路由器网络层，根据IP地址进行寻址；</li>
<li>交换机数据链路层，根据MAC地址进行寻址</details>

</li>
</ul>
<h3 id="IP地址的分类？"><a href="#IP地址的分类？" class="headerlink" title="IP地址的分类？"></a>IP地址的分类？</h3><p><img src="/images/interview/20191201085151639_2895.png" alt="IP address"></p>
<p>路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。</p>
<h3 id="什么叫划分子网？"><a href="#什么叫划分子网？" class="headerlink" title="什么叫划分子网？"></a>什么叫划分子网？</h3><p>从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。</p>
<h3 id="什么是ARP协议-Address-Resolution-Protocol-？"><a href="#什么是ARP协议-Address-Resolution-Protocol-？" class="headerlink" title="什么是ARP协议 (Address Resolution Protocol)？"></a>什么是ARP协议 (Address Resolution Protocol)？</h3><p><strong>ARP协议完成了IP地址与物理地址的映射</strong>。每一个主机都设有一个 ARP 高速缓存，里面有<strong>所在的局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向<strong>所在的局域网</strong>发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。</p>
<p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p>
<h3 id="什么是NAT-Network-Address-Translation-网络地址转换-？"><a href="#什么是NAT-Network-Address-Translation-网络地址转换-？" class="headerlink" title="什么是NAT (Network Address Translation, 网络地址转换)？"></a>什么是NAT (Network Address Translation, 网络地址转换)？</h3><p>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a class="link"   href="https://blog.csdn.net/justloveyou_/article/details/78303617" >面试/笔试第一弹 —— 计算机网络面试问题集锦<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/yjxsdzx/article/details/71937886" >什么时候选TCP、UDP？<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h3 id="待完成"><a href="#待完成" class="headerlink" title="待完成"></a>待完成</h3><ul>
<li><input disabled="" type="checkbox"> 发送窗口的大小，如何最大利用带宽，假设延迟100ms，发送端10Mb/s，接收端100Mb/s. <a class="link"   href="https://blog.csdn.net/bad_sheep/article/details/6158676" >reference<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2020/07/29/interview/Database/</url>
    <content><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul>
<li>数据库基础<ul>
<li><a href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E6%80%A7">事务的概念和特性？</a></li>
<li><a href="#%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">会出现哪些并发一致性问题？</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">数据库的四种隔离级别？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81">什么是乐观锁和悲观锁？</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B">常见的封锁类型？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E7%BA%A7%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE">什么是三级封锁协议？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%A4%E6%AE%B5%E9%94%81%E5%8D%8F%E8%AE%AE">什么是两段锁协议？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-mvcc">什么是 MVCC？</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%8C%83%E5%BC%8F">数据库的范式？</a></li>
<li><a href="#%E5%88%97%E4%B8%BE%E5%87%A0%E7%A7%8D%E8%A1%A8%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F">列举几种表连接方式？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9">什么是存储过程？有哪些优缺点？</a></li>
<li><a href="#DropDeleteTruncate%E7%9A%84%E5%8C%BA%E5%88%AB">Drop/Delete/Truncate的区别？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B8%E6%A0%87">什么是视图？什么是游标？</a></li>
</ul>
</li>
<li>MySQL<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86b%E6%A0%91">数据库索引的实现原理（B+树）</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9">使用索引的优点</a></li>
<li><a href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88">哪些情况下索引会失效？</a></li>
<li><a href="#%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">在哪些地方适合创建索引？</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB">索引的分类？</a></li>
<li><a href="#MySQL%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E5%92%8C-MyISAM-%E7%9A%84%E5%8C%BA%E5%88%AB">MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93">如何优化数据库？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">什么是主从复制？实现原理是什么？</a></li>
</ul>
</li>
<li>NoSQL/Redis<ul>
<li><a href="%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB">关系型数据库和非关系型数据库的区别？</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<a id="more"></a>

<hr>
<h3 id="事务的概念和特性？"><a href="#事务的概念和特性？" class="headerlink" title="事务的概念和特性？"></a>事务的概念和特性？</h3><p>概念：事务（Transaction）是一个操作序列，不可分割的工作单位，以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束</p>
<p>特性（ACID）：</p>
<ul>
<li><strong>原子性</strong>（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；</li>
<li><strong>一致性</strong>（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的；</li>
<li><strong>隔离性</strong>（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）；</li>
<li><strong>持久性</strong>（Durability）：一旦事务提交成功，对数据的修改是永久性的</li>
</ul>
<h3 id="会出现哪些并发一致性问题？"><a href="#会出现哪些并发一致性问题？" class="headerlink" title="会出现哪些并发一致性问题？"></a>会出现哪些并发一致性问题？</h3><ul>
<li><strong>丢失修改</strong>：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；</li>
<li><strong>脏读</strong>（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；</li>
<li><strong>不可重复读</strong>（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（可能被更新或删除了）；</li>
<li><strong>幻读</strong>（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了<strong>插入操作</strong>，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且需要是插入操作）</li>
</ul>
<h3 id="数据库的四种隔离级别？"><a href="#数据库的四种隔离级别？" class="headerlink" title="数据库的四种隔离级别？"></a>数据库的四种隔离级别？</h3><ul>
<li><strong>未提交读</strong>（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；</li>
<li><strong>提交读</strong>（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；</li>
<li><strong>可重复读</strong>（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读；</li>
<li><strong>可串行化</strong>（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。</li>
</ul>
<h3 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h3><ul>
<li>悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于<strong>数据更新比较频繁</strong>的场景；</li>
<li>乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于<strong>读多写少</strong>的场景。乐观锁的实现方式有：<ul>
<li>加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；</li>
<li>先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新</li>
</ul>
</li>
</ul>
<h3 id="常见的封锁类型？"><a href="#常见的封锁类型？" class="headerlink" title="常见的封锁类型？"></a>常见的封锁类型？</h3><p>意向锁是 InnoDB 自动加的， 不需用户干预。<br>对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB<br>会自动给涉及数据集加排他锁（X)；<br>对于普通 SELECT 语句，InnoDB 不会加任何锁；<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<br>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。<br>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</p>
<ul>
<li><strong>排它锁</strong>（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；</li>
<li><strong>共享锁</strong>（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁</li>
<li><strong>意向锁</strong>（Intention Locks）：<ul>
<li>一个事务在获得某个<strong>数据行</strong>对象的 S 锁之前，必须先获得<strong>整个表</strong>的 IS 锁或更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；</li>
<li>IS/IX 锁之间都是兼容的；</li>
<li>好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了</li>
</ul>
</li>
</ul>
<p>锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性</p>
<details>
<summary>封锁粒度的概念</summary>

<p>MySQL 中提供了两种封锁粒度：<strong>行级锁</strong>以及<strong>表级锁</strong>。</p>
<p>封锁粒度小：</p>
<ul>
<li>好处：锁定的数据量越少，发生锁争用的可能就越小，系统的<strong>并发程度</strong>就越高；</li>
<li>坏处：<strong>系统开销</strong>大（加锁、释放锁、检查锁的状态都需要消耗资源）</details>

</li>
</ul>
<details>
<summary>MySQL加锁</summary>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ... LOCK In SHARE MODE;</span><br><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>
</details>

<h3 id="什么是三级封锁协议？"><a href="#什么是三级封锁协议？" class="headerlink" title="什么是三级封锁协议？"></a>什么是三级封锁协议？</h3><ul>
<li>一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；</li>
<li>二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）；</li>
<li>三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）</li>
</ul>
<h3 id="什么是两段锁协议？"><a href="#什么是两段锁协议？" class="headerlink" title="什么是两段锁协议？"></a>什么是两段锁协议？</h3><p>事务必须严格分为两个阶段对数据进行<strong>加锁和解锁</strong>的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。</p>
<p><strong>可串行化调度</strong>是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。</p>
<h3 id="什么是-MVCC？"><a href="#什么是-MVCC？" class="headerlink" title="什么是 MVCC？"></a>什么是 MVCC？</h3><p>多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储<strong>创建版本号</strong>和<strong>删除版本号</strong>。</p>
<ul>
<li>创建版本号：创建一个数据行时的事务版本号（<strong>事务版本号</strong>：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）；</li>
<li>删除版本号：删除操作时的事务版本号；</li>
<li>各种操作：<ul>
<li>插入操作时，记录创建版本号；</li>
<li>删除操作时，记录删除版本号；</li>
<li>更新操作时，先记录删除版本号，再新增一行记录创建版本号；</li>
<li>查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成）</li>
</ul>
</li>
</ul>
<p>通过版本号减少了锁的争用，<strong>提高了系统性能</strong>；可以实现<strong>提交读</strong>和<strong>可重复读</strong>两种隔离级别，未提交读无需使用MVCC</p>
<details>
<summary>快照读与当前读</summary>

<p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table ...;</span><br></pre></td></tr></table></figure>

<p>当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br><span class="line">select * from table where ? for update;</span><br><span class="line">insert;</span><br><span class="line">update;</span><br><span class="line">delete;</span><br></pre></td></tr></table></figure>

</details>

<h3 id="数据库的范式？"><a href="#数据库的范式？" class="headerlink" title="数据库的范式？"></a>数据库的范式？</h3><ul>
<li><p><strong>第一范式</strong>（1NF，Normal Form）：<strong>属性不应该是可分的</strong>。举例：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话…如果将“移动电话”作为一个属性，就符合1NF；</p>
</li>
<li><p><strong>第二范式</strong> 2NF：每个非主属性<strong>完全依赖</strong>于主属性集（候选键集）；</p>
<ul>
<li>B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集；</li>
<li>主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性；</li>
<li>可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余；<br>满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>
</ul>
</li>
<li><p><strong>第三范式</strong> 3NF：在 2NF 的基础上，非主属性<strong>不传递依赖</strong>于主属性</p>
<ul>
<li>传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A；</li>
<li>3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。<br>必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；<details>
<summary>不符合范式会出现哪些异常？</summary>
</li>
</ul>
</li>
<li><p>冗余数据：某些同样的数据多次出现（如学生姓名）；</p>
</li>
<li><p>修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改；</p>
</li>
<li><p>删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）；</p>
</li>
<li><p>插入异常：无法插入（插入一个还没有课程信息的学生）</p>
</details>

</li>
</ul>
<h3 id="列举几种表连接方式？"><a href="#列举几种表连接方式？" class="headerlink" title="列举几种表连接方式？"></a>列举几种表连接方式？</h3><p><img src="/images/interview/20191207081711185_20242.png" alt="SQL连接"></p>
<ul>
<li>内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集<ul>
<li>自然连接：只考虑属性相同的元组对；</li>
<li>等值连接：给定条件进行查询</li>
</ul>
</li>
<li>外连接（Outer Join）<ul>
<li>左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL；</li>
<li>右连接：和左连接相反；</li>
<li>全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据</li>
</ul>
</li>
<li>交叉连接（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）</li>
</ul>
<h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h3><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。</p>
<p>优点：</p>
<ul>
<li>预先编译，而不需要每次运行时编译，提高了数据库执行<strong>效率</strong>；</li>
<li>封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以<strong>减少网络通信量</strong>；</li>
<li>具有<strong>可复用性</strong>，减少了数据库开发的工作量；</li>
<li><strong>安全性高</strong>，可以让没有权限的用户通过存储过程间接操作数据库；</li>
<li>更<strong>易于维护</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>可移植性差</strong>，存储过程将应用程序绑定到了数据库上；</li>
<li><strong>开发调试复杂</strong>：没有好的IDE；</li>
<li><strong>修改复杂</strong>，需要重新编译，有时还需要更新程序中的代码以更新调用</li>
</ul>
<h3 id="Drop-Delete-Truncate的区别？"><a href="#Drop-Delete-Truncate的区别？" class="headerlink" title="Drop/Delete/Truncate的区别？"></a>Drop/Delete/Truncate的区别？</h3><ul>
<li><strong>Delete</strong>用来删除表的全部或者<strong>部分数据</strong>，执行delete之后，用户<strong>需要提交</strong>之后才会执行，会触发表上的DELETE<strong>触发器</strong>（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据；</li>
<li><strong>Truncate</strong>删除表中的所有数据，这个操作<strong>不能回滚</strong>，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；</li>
<li><strong>Drop</strong>命令从数据库中<strong>删除表</strong>，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器；</li>
</ul>
<details>
<summary>什么是触发器？</summary>

<p>触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于<strong>保证数据完整性</strong>（比如可以检验或转换数据）。</p>
</details>

<details>
<summary>有哪些约束类型？</summary>

<p>约束（Constraint）类型：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束。</p>
</details>

<h3 id="什么是视图？什么是游标？"><a href="#什么是视图？什么是游标？" class="headerlink" title="什么是视图？什么是游标？"></a>什么是视图？什么是游标？</h3><ul>
<li>视图：从数据库的基本表中通过查询选取出来的数据组成的<strong>虚拟表</strong>（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处：<ul>
<li>通过只给用户访问视图的权限，保证数据的<strong>安全性</strong>；</li>
<li><strong>简化</strong>复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）；</li>
</ul>
</li>
<li>游标（Cursor）：用于定位在查询返回的<strong>结果集的特定行</strong>，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。</li>
</ul>
<hr>
<h3 id="数据库索引的实现原理（B-树）"><a href="#数据库索引的实现原理（B-树）" class="headerlink" title="数据库索引的实现原理（B+树）"></a>数据库索引的实现原理（B+树）</h3><p>见<a class="link"   href="https://github.com/wolverinn/Iridescent/blob/master/Data%20Structure.md#b%E6%A0%91" >数据结构部分：B树，B+树<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="使用B树和B-树的比较"><a href="#使用B树和B-树的比较" class="headerlink" title="使用B树和B+树的比较"></a>使用B树和B+树的比较</h5><p>InnoDB的索引使用的是B+树实现，B+树对比B树的好处：</p>
<ul>
<li>IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖；</li>
<li>范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表；</li>
<li>查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多</li>
</ul>
<h5 id="使用B树索引和哈希索引的比较"><a href="#使用B树索引和哈希索引的比较" class="headerlink" title="使用B树索引和哈希索引的比较"></a>使用B树索引和哈希索引的比较</h5><p>哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。</p>
<h3 id="使用索引的优点"><a href="#使用索引的优点" class="headerlink" title="使用索引的优点"></a>使用索引的优点</h3><ul>
<li>大大加快了数据的<strong>检索速度</strong>；</li>
<li>可以显著减少查询中<strong>分组和排序</strong>的时间；</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</li>
<li>将随机 I/O 变为<strong>顺序 I/O</strong>（B+Tree 索引是有序的，会将相邻的数据都存储在一起）</li>
</ul>
<p>缺点：建立和维护索引耗费时间空间，更新索引很慢。</p>
<h3 id="哪些情况下索引会失效？"><a href="#哪些情况下索引会失效？" class="headerlink" title="哪些情况下索引会失效？"></a>哪些情况下索引会失效？</h3><ul>
<li>以“%(表示任意0个或多个字符)”开头的LIKE语句；</li>
<li>OR语句前后没有同时使用索引；</li>
<li>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；</li>
<li>对于多列索引，必须满足 <strong>最左匹配原则</strong>/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；</li>
<li>如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）</li>
</ul>
<h3 id="在哪些地方适合创建索引？"><a href="#在哪些地方适合创建索引？" class="headerlink" title="在哪些地方适合创建索引？"></a>在哪些地方适合创建索引？</h3><ul>
<li>某列经常作为最大最小值；</li>
<li>经常被查询的字段；</li>
<li>经常用作表连接的字段；</li>
<li>经常出现在ORDER BY/GROUP BY/DISDINCT后面的字段</li>
</ul>
<h5 id="创建索引时需要注意什么？"><a href="#创建索引时需要注意什么？" class="headerlink" title="创建索引时需要注意什么？"></a>创建索引时需要注意什么？</h5><details>
<summary>展开</summary>

<ul>
<li>只应建立在<strong>小字段</strong>上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）；</li>
<li>建立索引的字段应该<strong>非空</strong>，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；</li>
<li>选择<strong>数据密度大</strong>（唯一值占总数的百分比很大）的字段作索引</details>

</li>
</ul>
<h3 id="索引的分类？"><a href="#索引的分类？" class="headerlink" title="索引的分类？"></a>索引的分类？</h3><ul>
<li>普通索引</li>
<li>唯一索引 UNIQUE：索引列的值必须唯一，但允许有空值；</li>
<li>主键索引 PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）；</li>
<li>单列索引和多列索引/复合索引（Composite）：索引的列数；</li>
<li>覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据；</li>
<li>聚集（Clustered）索引/非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序；</li>
<li>分区索引（？）</li>
<li>虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用</li>
</ul>
<h3 id="MySQL的两种存储引擎-InnoDB-和-MyISAM-的区别？"><a href="#MySQL的两种存储引擎-InnoDB-和-MyISAM-的区别？" class="headerlink" title="MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？"></a>MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？</h3><ul>
<li>InnoDB<strong>支持事务</strong>，可以进行Commit和Rollback；</li>
<li>MyISAM 只支持表级锁，而 InnoDB 还<strong>支持行级锁</strong>，提高了并发操作的性能；</li>
<li>InnoDB <strong>支持外键</strong>；</li>
<li>MyISAM <strong>崩溃</strong>后发生损坏的概率比 InnoDB 高很多，而且<strong>恢复的速度</strong>也更慢；</li>
<li>MyISAM 支持<strong>压缩</strong>表和空间数据索引，InnoDB需要更多的内存和存储；</li>
<li>InnoDB 支持在线<strong>热备份</strong></li>
</ul>
<details>
<summary>应用场景</summary>

<ul>
<li><strong>MyISAM</strong> 管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM；</li>
<li><strong>InnoDB</strong> 支持事务，并发情况下有很好的性能，基本可以替代MyISAM</details>

</li>
</ul>
<details>
<summary>热备份和冷备份</summary>

<ul>
<li>热备份：在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错</li>
<li>冷备份：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单</details>

</li>
</ul>
<h3 id="如何优化数据库？"><a href="#如何优化数据库？" class="headerlink" title="如何优化数据库？"></a>如何优化数据库？</h3><details>
<summary>SQL 语句的优化</summary>

<blockquote>
<p>分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句，通过日志去找出IO大的SQL以及发现未命中索引的SQL</p>
</blockquote>
<blockquote>
<p>使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、<strong>哪些索引被实际使用</strong>、表之间的引用以及<strong>被扫描的行数</strong>等问题；</p>
</blockquote>
<ul>
<li>应尽量避免在 where 子句中使用<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>操作符或对字段进行null值判断，否则将引擎放弃使用索引而进行全表扫描；</li>
<li>只返回必要的列：最好不要使用 SELECT * 语句；</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据；</li>
<li>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用；</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询；</li>
<li>减少锁竞争</details>

</li>
</ul>
</li>
</ul>
<details>
<summary>索引的优化</summary>

<p>注意会引起索引失效的情况，以及在适合的地方建立索引</p>
</details>

<details>
<summary>数据库表结构的优化</summary>

<ul>
<li>设计表时遵循<strong>三大范式</strong>；</li>
<li>选择合适的<strong>数据类型</strong>：尽可能不要存储NULL字段；使用简单的数据类型（int, varchar/ text）；</li>
<li>表的<strong>水平切分</strong>（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据ID范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力；</li>
<li>表的<strong>垂直切分</strong>：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单</details>

</li>
</ul>
<details>
<summary>系统配置的优化</summary>

<ul>
<li>操作系统：增加TCP支持的队列数；</li>
<li>MySQL配置文件优化：缓存池大小和个数设置</details>

</li>
</ul>
<details>
<summary>硬件的优化</summary>

<ul>
<li>磁盘性能：固态硬盘；</li>
<li>CPU：多核且高频；</li>
<li>内存：增大内存</details>

</li>
</ul>
<h3 id="什么是主从复制？实现原理是什么？"><a href="#什么是主从复制？实现原理是什么？" class="headerlink" title="什么是主从复制？实现原理是什么？"></a>什么是主从复制？实现原理是什么？</h3><p>主从复制（Replication）是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。</p>
<p>实现原理：</p>
<ul>
<li>主服务器 <strong>binary log dump 线程</strong>：将主服务器中的数据更改（增删改）日志写入 Binary log 中；</li>
<li>从服务器 <strong>I/O 线程</strong>：负责从主服务器读取binary log，并写入本地的 Relay log；</li>
<li>从服务器 <strong>SQL 线程</strong>：负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性</li>
</ul>
<h5 id="为什么要主从复制？"><a href="#为什么要主从复制？" class="headerlink" title="为什么要主从复制？"></a>为什么要主从复制？</h5><details>
<summary>展开</summary>

<ul>
<li>读写分离：主服务器负责写，从服务器负责读<ul>
<li>缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性</li>
</ul>
</li>
<li>数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换</li>
<li>降低单个服务器磁盘I/O访问的频率，提高单个机器的I/O性能</details>

</li>
</ul>
<h3 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a class="link"   href="https://blog.csdn.net/weixin_43433032/article/details/89293663" >数据库六大范式详解 – CSDN博客<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/alice-cj/p/10354737.html" >delete，truncate 和 delete之间的区别 – 博客园<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://baijiahao.baidu.com/s?id=1617888740370098866&wfr=spider&for=pc" >深度探索MySQL主从复制原理<i class="fas fa-external-link-alt"></i></a></li>
<li>数据库程序员面试笔试宝典-机械工业出版社</li>
<li><a class="link"   href="https://github.com/CyC2018/CS-Notes/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md" >CS-Notes/数据库系统原理 – GitHub<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/justloveyou_/article/details/78308460" >面试/笔试第三弹 —— 数据库面试问题集锦 – CSDN博客<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/wenxiaofei/p/9853682.html" >史上最全的数据库面试题，不看绝对后悔 – 博客园<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h3 id="待完成"><a href="#待完成" class="headerlink" title="待完成"></a>待完成</h3><ul>
<li><input disabled="" type="checkbox"> E-R 模型</li>
<li><input disabled="" type="checkbox"> 数据库的三级模式和二级映像</li>
<li><input disabled="" type="checkbox"> <a class="link"   href="https://github.com/CyC2018/CS-Notes/blob/master/notes/MySQL.md#%E5%9B%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" >数据类型<i class="fas fa-external-link-alt"></i></a>：VARCHAR和CHAR的区别，DATETIME和TIMESATMP的区别</li>
<li><input disabled="" type="checkbox"> Redis 面试<ul>
<li><a class="link"   href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md" >CyC2018<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/Butterfly_resting/article/details/89668661" >几率大的Redis面试题（含答案） - CSDN<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.jianshu.com/p/65765dd10671" >Redis面试题总结 - 简书<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/jasontec/p/9699242.html" >Redis常见面试题 - 博客园<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://github.com/0voice/interview_internal_reference#10" >0voice/interview_internal_reference<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
<li><input disabled="" type="checkbox"> <a class="link"   href="https://www.cnblogs.com/wenxiaofei/p/9853682.html" >史上最全的数据库面试题，不看绝对后悔 – 博客园<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/07/29/interview/Operating_Systems/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ul>
<li>进程和线程<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">进程和线程有什么区别？</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">进程间通信有哪些方式？</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98">进程同步问题</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81">进程有哪几种状态？</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B">进程调度策略有哪些？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B">什么是僵尸进程？</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F">线程同步有哪些方式？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B">什么是协程？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0">什么是IO多路复用？怎么实现？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81">什么是用户态和内核态？</a></li>
</ul>
</li>
<li>死锁<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81">什么是死锁？</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">死锁产生的必要条件？</a></li>
<li><a href="#%E6%AD%BB%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95">死锁有哪些处理方法？</a></li>
</ul>
</li>
<li>内存管理<ul>
<li><a href="#%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">分页和分段有什么区别？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">什么是虚拟内存？</a></li>
<li><a href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">有哪些页面置换算法？</a></li>
</ul>
</li>
<li><a href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6">磁盘调度</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
<a id="more"></a>

<hr>
<h3 id="进程和线程有什么区别？"><a href="#进程和线程有什么区别？" class="headerlink" title="进程和线程有什么区别？"></a>进程和线程有什么区别？</h3><ul>
<li>进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；</li>
<li>线程依赖于进程而存在，一个进程至少有一个线程；</li>
<li>进程有自己的独立地址空间，线程共享所属进程的地址空间；</li>
<li>进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；</li>
<li>在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；</li>
<li>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</li>
<li>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮</li>
</ul>
<p>进程操作代码实现，可以参考：<a class="link"   href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064" >多进程 - 廖雪峰的官方网站<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="同一进程中的线程可以共享哪些数据？"><a href="#同一进程中的线程可以共享哪些数据？" class="headerlink" title="同一进程中的线程可以共享哪些数据？"></a>同一进程中的线程可以共享哪些数据？</h5><details>
<summary>展开</summary>

<ul>
<li>进程代码段</li>
<li>进程的公有数据（全局变量、静态变量…）</li>
<li>进程打开的文件描述符</li>
<li>进程的当前目录</li>
<li>信号处理器/信号处理函数：对收到的信号的处理方式</li>
<li>进程ID与进程组ID</details>

</li>
</ul>
<h5 id="线程独占哪些资源？"><a href="#线程独占哪些资源？" class="headerlink" title="线程独占哪些资源？"></a>线程独占哪些资源？</h5><details>
<summary>展开</summary>

<ul>
<li>线程ID</li>
<li>一组寄存器的值</li>
<li>线程自身的栈（堆是共享的）</li>
<li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li>
<li>信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</details>

</li>
</ul>
<h3 id="进程间通信有哪些方式？"><a href="#进程间通信有哪些方式？" class="headerlink" title="进程间通信有哪些方式？"></a>进程间通信有哪些方式？</h3><ol>
<li>管道(Pipe)<details>
<summary>展开</summary>
</li>
</ol>
<ul>
<li>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；</li>
<li>一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；</li>
<li>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程)</details>
</li>
</ul>
<ol start="2">
<li>命名管道</li>
<li>消息队列</li>
<li>信号(Signal)</li>
<li>共享内存</li>
<li>信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态</li>
<li>套接字(Socket)</li>
</ol>
<p>更详细的可以参考（待整理）：</p>
<ul>
<li><a class="link"   href="https://imageslr.github.io/2020/02/26/ipc.html" >https://imageslr.github.io/2020/02/26/ipc.html<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.jianshu.com/p/c1015f5ffa74" >https://www.jianshu.com/p/c1015f5ffa74<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h3 id="进程同步问题"><a href="#进程同步问题" class="headerlink" title="进程同步问题"></a>进程同步问题</h3><blockquote>
<p>进程的同步是目的，而进程间通信是实现进程同步的手段</p>
</blockquote>
<details>
<summary>管程 Monitor</summary>

<p>管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。</p>
<p>当一个进程试图进入管程时，在<strong>入口等待队列</strong>等待。若P进程唤醒了Q进程，则Q进程先执行，P在<strong>紧急等待队列</strong>中等待。（<strong>HOARE管程</strong>）</p>
<p>wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（<strong>HOARE管程</strong>）</p>
<p><strong>MESA管程</strong>：将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。优点：没有额外的进程切换</p>
</details>

<details>
<summary>生产者-消费者问题</summary>

<blockquote>
<p>问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述 </span></span><br><span class="line"><span class="comment">// 定义信号量 full记录缓冲区物品数量 empty代表缓冲区空位数量 mutex为互斥量</span></span><br><span class="line">semaphore full = <span class="number">0</span>, empty = n, mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">   	  P(empty);</span><br><span class="line">	  P(mutex);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 生产者进行生产</span></span><br><span class="line">   	</span><br><span class="line">   	  V(mutex);</span><br><span class="line">   	  V(full);</span><br><span class="line"> 	&#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">	  P(full);</span><br><span class="line">	  P(mutex);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 消费者进行消费</span></span><br><span class="line"></span><br><span class="line">	  V(mutex);</span><br><span class="line">	  V(empty);</span><br><span class="line"> 	&#125; <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>哲学家就餐问题</summary>

<blockquote>
<p>问题描述：有五位哲学家围绕着餐桌坐，每一位哲学家要么思考，要么吃饭。为了吃饭，哲学家必须拿起两双筷子（分别放于左右两端）不幸的是，筷子的数量和哲学家相等，所以每只筷子必须由两位哲学家共享。</p>
</blockquote>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5  <span class="comment">// number of philosopher</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1)%N <span class="comment">// number of i&#x27;s left neighbors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + 1)%N <span class="comment">// number of i&#x27;s right neighbors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUNGRY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EATING 2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="keyword">int</span> state[N]; <span class="comment">// array to keep track of everyone&#x27;s state</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>; <span class="comment">// mutual exclusion of critical region</span></span><br><span class="line">semaphore s[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line">		think();</span><br><span class="line">		take_forks(i);</span><br><span class="line">		eat();</span><br><span class="line">		put_forks(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_forks</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	down(&amp;mutex); <span class="comment">// enter critical region</span></span><br><span class="line">	state[i] = HUNGRY; <span class="comment">// record that i is hungry</span></span><br><span class="line">	test_forks(i); <span class="comment">// try to acquire two forks</span></span><br><span class="line">	up(&amp;mutex); <span class="comment">// exit critical region</span></span><br><span class="line">	down(&amp;s[i]); <span class="comment">// block if forks are not acquired</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_forks</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	down(&amp;mutex); <span class="comment">// enter critical region</span></span><br><span class="line">	state[i] = THINKING; <span class="comment">// record that has finished eating</span></span><br><span class="line">	test_forks(LEFT); <span class="comment">// see if left neighbor can now eat</span></span><br><span class="line">	test_forks(RIGHT); <span class="comment">// see if right neighbor can now eat</span></span><br><span class="line">	up(&amp;mutex); <span class="comment">// exit critical region</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_forks</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) &#123;</span><br><span class="line">		state[i] = EATING;</span><br><span class="line">		up(&amp;s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>读者-写者问题</summary>


</details>

<h5 id="临界区的概念？"><a href="#临界区的概念？" class="headerlink" title="临界区的概念？"></a>临界区的概念？</h5><details>
<summary>展开</summary>

<p>各个进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段</p>
</details>

<h5 id="同步与互斥的概念？"><a href="#同步与互斥的概念？" class="headerlink" title="同步与互斥的概念？"></a>同步与互斥的概念？</h5><details>
<summary>展开</summary>

<ul>
<li>同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；</li>
<li>互斥：多个进程在同一时刻只有一个进程能进入临界区</details>

</li>
</ul>
<h5 id="并发、并行、异步的区别？"><a href="#并发、并行、异步的区别？" class="headerlink" title="并发、并行、异步的区别？"></a>并发、并行、异步的区别？</h5><details>
<summary>展开</summary>

<p>并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；</p>
<p>多线程：并发运行的一段代码。是实现异步的手段</p>
<p>并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的</p>
<p>异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事</p>
</details>

<h3 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h3><p><img src="/images/interview/20191202090217863_1873.png" alt="Process State"></p>
<ul>
<li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源</li>
<li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数</li>
<li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li>
</ul>
<h3 id="进程调度策略有哪些？"><a href="#进程调度策略有哪些？" class="headerlink" title="进程调度策略有哪些？"></a>进程调度策略有哪些？</h3><ol>
<li><strong>批处理系统</strong>：</li>
</ol>
<details>
<summary>先来先服务 first-come first-serverd（FCFS）</summary>

<p>按照请求的顺序进行调度。非抢占式，开销小，无饥饿问题，响应时间不确定（可能很慢）；</p>
<p>对短进程不利，对IO密集型进程不利。</p>
</details>

<details>
<summary>最短作业优先 shortest job first（SJF）</summary>

<p>按估计运行时间最短的顺序进行调度。非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题；</p>
<p>对短进程提供好的响应时间，对长进程不利。</p>
</details>

<details>
<summary>最短剩余时间优先 shortest remaining time next（SRTN）</summary>

<p>按剩余运行时间的顺序进行调度。(最短作业优先的抢占式版本)。吞吐量高，开销可能较大，提供好的响应时间；</p>
<p>可能导致饥饿问题，对长进程不利。</p>
</details>

<details>
<summary>最高响应比优先 Highest Response Ratio Next（HRRN）</summary>

<p>响应比 = 1+ 等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。</p>
</details>

<ol start="2">
<li><strong>交互式系统</strong><br>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</li>
</ol>
<details>
<summary>时间片轮转 Round Robin</summary>

<p>将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间；</p>
<p>若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证。</p>
</details>

<details>
<summary>优先级调度算法</summary>

<p>为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
</details>

<details>
<summary>多级反馈队列调度算法 Multilevel Feedback Queue</summary>

<p>设置多个就绪队列1、2、3…，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。</p>
<p>抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。</p>
</details>

<h5 id="什么叫优先级反转？如何解决？"><a href="#什么叫优先级反转？如何解决？" class="headerlink" title="什么叫优先级反转？如何解决？"></a>什么叫优先级反转？如何解决？</h5><details>
<summary>展开</summary>

<p>高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。</p>
<p>解决方法：</p>
<ul>
<li>优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。</li>
<li>优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。</details>

</li>
</ul>
<h3 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h3><p>一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。</p>
<p>危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。</p>
<p>以下情况不会产生僵尸进程：</p>
<ul>
<li>该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。</li>
<li>父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入<code>WNOHANG</code>(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程；</li>
<li>子进程结束时，系统会产生<code>SIGCHLD</code>(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）；</li>
<li>也可以用<code>signal(SIGCLD, SIG_IGN)</code>(signal-ignore)通知内核，表示忽略<code>SIGCHLD</code>信号，那么子进程结束后，内核会进行回收。</li>
</ul>
<h5 id="什么是孤儿进程？"><a href="#什么是孤儿进程？" class="headerlink" title="什么是孤儿进程？"></a>什么是孤儿进程？</h5><details>
<summary>展开</summary>

<p>一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。</p>
</details>

<h3 id="线程同步有哪些方式？"><a href="#线程同步有哪些方式？" class="headerlink" title="线程同步有哪些方式？"></a>线程同步有哪些方式？</h3><blockquote>
<p>为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。</p>
</blockquote>
<ul>
<li><strong>互斥量</strong> Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；</li>
<li><strong>信号量</strong> Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了<strong>最大资源计数</strong>和<strong>当前可用资源计数</strong>，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过<code>ReleaseSemaphore</code>函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；</li>
<li><strong>事件</strong> Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒<strong>一个</strong>等待中的线程，然后自动恢复为未激发状态。</li>
<li><strong>临界区</strong> Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。</li>
</ul>
<h5 id="互斥量和临界区有什么区别？"><a href="#互斥量和临界区有什么区别？" class="headerlink" title="互斥量和临界区有什么区别？"></a>互斥量和临界区有什么区别？</h5><details>
<summary>展开</summary>

<p>互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。</p>
</details>

<h3 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h3><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<h5 id="协程多与线程进行比较？"><a href="#协程多与线程进行比较？" class="headerlink" title="协程多与线程进行比较？"></a>协程多与线程进行比较？</h5><details>
<summary>展开</summary>

<ol>
<li><p>一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</p>
</li>
<li><p>线程进程都是同步机制，而协程则是异步</p>
</li>
<li><p>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p>
</details>

</li>
</ol>
<h3 id="什么是IO多路复用？怎么实现？"><a href="#什么是IO多路复用？怎么实现？" class="headerlink" title="什么是IO多路复用？怎么实现？"></a>什么是IO多路复用？怎么实现？</h3><p>IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。</p>
<p>实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。</p>
<details>
<summary>select/poll/epoll三者的区别？</summary>

<ul>
<li><code>select</code>：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，<strong>开销大</strong>），由内核根据就绪状态修改该集合的内容。（缺点2）<strong>集合大小有限制</strong>，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：<strong>轮询的方式效率较低</strong>），当文件描述符的数量增加时，效率会线性下降；</li>
<li><code>poll</code>：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；</li>
<li><code>epoll</code>：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。</li>
</ul>
<p>总结，区别主要在于：</p>
<ul>
<li>一个线程/进程所能打开的最大连接数</li>
<li>文件描述符传递方式（是否复制）</li>
<li>水平触发 or 边缘触发</li>
<li>查询就绪的描述符时的效率（是否轮询）</details>

</li>
</ul>
<details>
<summary>什么时候使用select/poll，什么时候使用epoll？</summary>

<p>当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。</p>
</details>

<details>
<summary>什么是文件描述符？</summary>

<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p>内核通过文件描述符来访问文件。文件描述符指向一个文件。</p>
</details>

<h5 id="什么是水平触发？什么是边缘触发？"><a href="#什么是水平触发？什么是边缘触发？" class="headerlink" title="什么是水平触发？什么是边缘触发？"></a>什么是水平触发？什么是边缘触发？</h5><details>
<summary>展开</summary>

<ul>
<li>水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知；</li>
<li>边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。</li>
<li>区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。</li>
<li>为什么边缘触发一定要用非阻塞（non-block）IO：避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。</details>

</li>
</ul>
<h5 id="有哪些常见的IO模型？"><a href="#有哪些常见的IO模型？" class="headerlink" title="有哪些常见的IO模型？"></a>有哪些常见的IO模型？</h5><details>
<summary>展开</summary>

<ul>
<li>同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够；</li>
<li>同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源；</li>
<li>IO多路复用</li>
<li>异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。</details>

</li>
</ul>
<h3 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h3><p>为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。</p>
<ul>
<li>用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取；</li>
<li>内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。</li>
</ul>
<p>所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用<strong>陷阱指令</strong>，CPU切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。</p>
<h5 id="为什么要分用户态和内核态？"><a href="#为什么要分用户态和内核态？" class="headerlink" title="为什么要分用户态和内核态？"></a>为什么要分用户态和内核态？</h5><details>
<summary>展开</summary>

<p>（我自己的见解：）</p>
<ul>
<li>安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源；</li>
<li>封装性：用户程序不需要实现更加底层的代码；</li>
<li>利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。</details>

</li>
</ul>
<h5 id="如何从用户态切换到内核态？"><a href="#如何从用户态切换到内核态？" class="headerlink" title="如何从用户态切换到内核态？"></a>如何从用户态切换到内核态？</h5><details>
<summary>展开</summary>

<ul>
<li>系统调用：比如读取命令行输入。本质上还是通过中断实现</li>
<li>用户程序发生异常时：比如缺页异常</li>
<li>外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序</details>

</li>
</ul>
<h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><p>在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。</p>
<h3 id="死锁产生的必要条件？"><a href="#死锁产生的必要条件？" class="headerlink" title="死锁产生的必要条件？"></a>死锁产生的必要条件？</h3><ul>
<li><strong>互斥</strong>：一个资源一次只能被一个进程使用；</li>
<li><strong>占有并等待</strong>：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；</li>
<li><strong>非抢占</strong>：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；</li>
<li><strong>循环等待</strong>：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ul>
<h3 id="死锁有哪些处理方法？"><a href="#死锁有哪些处理方法？" class="headerlink" title="死锁有哪些处理方法？"></a>死锁有哪些处理方法？</h3><details>
<summary>鸵鸟策略</summary>

<p>直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>
</details>

<details>
<summary>死锁预防</summary>

<p>基本思想是破坏形成死锁的四个必要条件：</p>
<ul>
<li>破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；</li>
<li>破坏占有并等待条件：<ul>
<li>实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；</li>
<li>或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；</li>
<li>缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性；</li>
</ul>
</li>
<li>破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；</li>
<li>破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。</details>

</li>
</ul>
<details>
<summary>死锁避免</summary>

<p>动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。</p>
<blockquote>
<p>银行家算法</p>
</blockquote>
</details>

<details>
<summary>死锁解除</summary>

<blockquote>
<p>如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。</p>
</blockquote>
<p>死锁解除的方法：</p>
<ul>
<li>利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；</li>
<li>利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；</li>
<li>利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。</details>

</li>
</ul>
<h3 id="分页和分段有什么区别？"><a href="#分页和分段有什么区别？" class="headerlink" title="分页和分段有什么区别？"></a>分页和分段有什么区别？</h3><ul>
<li>页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；</li>
<li>段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；</li>
<li>段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。</li>
</ul>
<p>区别：</p>
<ul>
<li>目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；</li>
<li>大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；</li>
<li>地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；</li>
<li>分段便于信息的保护和共享；分页的共享收到限制；</li>
<li>碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）</li>
</ul>
<h3 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h3><p>每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。</p>
<p>虚拟内存的优点是让程序可以获得更多的可用内存。</p>
<h5 id="如何进行地址空间到物理内存的映射？"><a href="#如何进行地址空间到物理内存的映射？" class="headerlink" title="如何进行地址空间到物理内存的映射？"></a>如何进行地址空间到物理内存的映射？</h5><details>
<summary>展开</summary>

<p><strong>内存管理单元</strong>（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。</p>
</details>

<h3 id="有哪些页面置换算法？"><a href="#有哪些页面置换算法？" class="headerlink" title="有哪些页面置换算法？"></a>有哪些页面置换算法？</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<ul>
<li><strong>最佳页面置换算法</strong>OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；</li>
<li><strong>先进先出</strong>FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；</li>
<li><strong>第二次机会算法</strong>SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；</li>
<li><strong>时钟算法</strong> Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；</li>
<li><strong>最近未使用算法</strong>NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；</li>
<li><strong>最近最少使用算法</strong>LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</li>
<li><strong>最不经常使用算法</strong>NFU：置换出访问次数最少的页面</li>
</ul>
<details>
<summary>局部性原理</summary>

<ul>
<li>时间上：最近被访问的页在不久的将来还会被访问；</li>
<li>空间上：内存中被访问的页周围的页也很可能被访问。</details>

</li>
</ul>
<details>
<summary>什么是颠簸现象</summary>

<p>颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括：</p>
<ul>
<li>修改页面置换算法；</li>
<li>降低同时运行的程序的数量；</li>
<li>终止该进程或增加物理内存容量。</details>

</li>
</ul>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法：</p>
<ul>
<li>先来先服务</li>
<li>最短寻道时间优先</li>
<li>电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a class="link"   href="https://www.jianshu.com/p/c1015f5ffa74" >进程间通信IPC – 简书<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/justloveyou_/article/details/78304294" >面试/笔试第二弹 —— 操作系统面试问题集锦 - CSDN博客<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://segmentfault.com/a/1190000018970361" >线程同步与并发 - - SegmentFault<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="http://baijiahao.baidu.com/s?id=1641172494287388070&wfr=spider&for=pc" >彻底搞懂epoll高效运行的原理<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/lirong21/p/4213028.html" >用户态与内核态的切换<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h3 id="待完成"><a href="#待完成" class="headerlink" title="待完成"></a>待完成</h3><ul>
<li><input disabled="" type="checkbox"> IPC</li>
<li><input disabled="" type="checkbox"> 进程同步问题：生产者-消费者问题…</li>
<li><input disabled="" type="checkbox"> 银行家算法</li>
<li><input disabled="" type="checkbox"> 文件与文件系统、文件管理？<div>
<img src="/images/interview/20191202162008435_14938.png" width=540px></img>
</div>
</li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown数学公式语法</title>
    <url>/2020/07/29/others/markdown_math/</url>
    <content><![CDATA[<p>#markdown 数学公式</p>
<h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol>
<li>行内公式：将公式插入到本行内，符号：<code>$公式内容$</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="3.455ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 1527 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1062, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>独行公式：将公式插入到新的一行内，并且居中，符号：<code>$$公式内容$$</code>，如：<mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="3.455ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 1527 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1062, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
</ol>
<h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol>
<li>上标符号，符号：<code>^</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="2.207ex" height="1.929ex" role="img" focusable="false" viewBox="0 -841.7 975.6 852.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(572, 363) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g></g></g></g></svg></mjx-container></li>
<li>下标符号，符号：<code>_</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex" xmlns="http://www.w3.org/2000/svg" width="2.207ex" height="1.339ex" role="img" focusable="false" viewBox="0 -442 975.6 592"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(572, -150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g></svg></mjx-container></li>
<li>组合符号，符号：<code>{}</code>，如：${16}<em>{8}O{2+}</em>{2}$</li>
</ol>
<h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol>
<li>汉字形式，符号：<code>\mbox{}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.349ex" xmlns="http://www.w3.org/2000/svg" width="5.505ex" height="2.895ex" role="img" focusable="false" viewBox="0 -683 2433 1279.4"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g><g data-mml-node="TeXAtom" transform="translate(583, -396.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mstyle" transform="scale(1.414)"><g data-mml-node="mtext"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">初</text><text data-variant="normal" transform="translate(900, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">始</text></g></g></g></g></g></g></svg></mjx-container></li>
<li>字体控制，符号：<code>\displaystyle</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -2.016ex" xmlns="http://www.w3.org/2000/svg" width="6.164ex" height="4.864ex" role="img" focusable="false" viewBox="0 -1259 2724.4 2150"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220, 676)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mrow" transform="translate(273.5, -686)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(712.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1712.4, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g><rect width="2484.4" height="60" x="120" y="220"></rect></g></g></g></g></svg></mjx-container></li>
<li>下划线符号，符号：<code>\underline</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.91ex" xmlns="http://www.w3.org/2000/svg" width="5.168ex" height="2.229ex" role="img" focusable="false" viewBox="0 -583 2284.4 985"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munder"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(0, -550)"><svg width="2284.4" height="237" x="0" y="148" viewBox="571.1 148 2284.4 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(6.853, 1)"></path></svg></g></g></g></g></svg></mjx-container></li>
<li>标签，符号<code>\tag{数字}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="0.002ex" height="0" role="img" focusable="false" viewBox="0 0 1 0" preserveAspectRatio="xMidYMid slice"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"></g></g></svg></mjx-container></li>
<li>上大括号，符号：<code>\overbrace{算式}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="12.621ex" height="5.038ex" role="img" focusable="false" viewBox="0 -2144.9 5578.3 2226.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="TeXAtom" data-mjx-texclass="OP"><g data-mml-node="mover"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(751.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1751.4, 0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(2402.7, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(3402.9, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(4058.1, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5058.3, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g><g data-mml-node="mo" transform="translate(0, 954)"><path data-c="E150" d="M-18 -213L-24 -207V-172L-16 -158Q75 2 260 84Q334 113 415 119Q418 119 427 119T440 120Q454 120 457 117T460 98V60V25Q460 7 457 4T441 0Q308 0 193 -55T25 -205Q21 -211 18 -212T-1 -213H-18Z"></path><path data-c="E151" d="M-10 60Q-10 104 -10 111T-5 118Q-1 120 10 120Q96 120 190 84Q375 2 466 -158L474 -172V-207L468 -213H451H447Q437 -213 434 -213T428 -209T423 -202T414 -187T396 -163Q331 -82 224 -41T9 0Q-4 0 -7 3T-10 25V60Z" transform="translate(5128.3, 0)"></path><g data-c="E155" transform="translate(2339.2, 0)"><path data-c="E153" d="M-10 60V95Q-10 113 -7 116T9 120Q151 120 250 171T396 284Q404 293 412 305T424 324T431 331Q433 333 451 333H468L474 327V292L466 278Q375 118 190 36Q95 0 8 0Q-5 0 -7 3T-10 24V60Z"></path><path data-c="E152" d="M-24 327L-18 333H-1Q11 333 15 333T22 329T27 322T35 308T54 284Q115 203 225 162T441 120Q454 120 457 117T460 95V60V28Q460 8 457 4T442 0Q355 0 260 36Q75 118 -16 278L-24 292V327Z" transform="translate(450, 0)"></path></g><svg width="2089.2" height="720" x="350" y="-300" viewBox="522.3 -300 2089.2 720"><path data-c="E154" d="M-10 0V120H410V0H-10Z" transform="scale(7.834, 1)"></path></svg><svg width="2089.2" height="720" x="3139.2" y="-300" viewBox="522.3 -300 2089.2 720"><path data-c="E154" d="M-10 0V120H410V0H-10Z" transform="scale(7.834, 1)"></path></svg></g></g></g><g data-mml-node="TeXAtom" transform="translate(2337.3, 1574) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500, 0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(778, 0)"></path></g></g></g></g></g></svg></mjx-container></li>
<li>下大括号，符号：<code>\underbrace{算式}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -3.429ex" xmlns="http://www.w3.org/2000/svg" width="12.621ex" height="4.999ex" role="img" focusable="false" viewBox="0 -694 5578.3 2209.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(751.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="munder" transform="translate(1751.4, 0)"><g data-mml-node="TeXAtom" data-mjx-texclass="OP"><g data-mml-node="munder"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(651.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1651.4, 0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g><g data-mml-node="mo" transform="translate(0, -462)"><path data-c="E152" d="M-24 327L-18 333H-1Q11 333 15 333T22 329T27 322T35 308T54 284Q115 203 225 162T441 120Q454 120 457 117T460 95V60V28Q460 8 457 4T442 0Q355 0 260 36Q75 118 -16 278L-24 292V327Z"></path><path data-c="E153" d="M-10 60V95Q-10 113 -7 116T9 120Q151 120 250 171T396 284Q404 293 412 305T424 324T431 331Q433 333 451 333H468L474 327V292L466 278Q375 118 190 36Q95 0 8 0Q-5 0 -7 3T-10 24V60Z" transform="translate(1634.4, 0)"></path><g data-c="E156" transform="translate(592.2, 0)"><path data-c="E151" d="M-10 60Q-10 104 -10 111T-5 118Q-1 120 10 120Q96 120 190 84Q375 2 466 -158L474 -172V-207L468 -213H451H447Q437 -213 434 -213T428 -209T423 -202T414 -187T396 -163Q331 -82 224 -41T9 0Q-4 0 -7 3T-10 25V60Z"></path><path data-c="E150" d="M-18 -213L-24 -207V-172L-16 -158Q75 2 260 84Q334 113 415 119Q418 119 427 119T440 120Q454 120 457 117T460 98V60V25Q460 7 457 4T441 0Q308 0 193 -55T25 -205Q21 -211 18 -212T-1 -213H-18Z" transform="translate(450, 0)"></path></g><svg width="342.2" height="720" x="350" y="-300" viewBox="85.6 -300 342.2 720"><path data-c="E154" d="M-10 0V120H410V0H-10Z" transform="scale(1.283, 1)"></path></svg><svg width="342.2" height="720" x="1392.2" y="-300" viewBox="85.6 -300 342.2 720"><path data-c="E154" d="M-10 0V120H410V0H-10Z" transform="scale(1.283, 1)"></path></svg></g></g></g><g data-mml-node="TeXAtom" transform="translate(590.4, -1399.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z" transform="translate(500, 0)"></path><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(778, 0)"></path></g></g></g><g data-mml-node="mo" transform="translate(4058.1, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(5058.3, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container></li>
<li>上位符号，符号：<code>\stacrel{上位符号}{基位符号}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="14.361ex" height="3.565ex" role="img" focusable="false" viewBox="0 -1381.5 6347.5 1575.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(63.8, -14)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="REL" transform="translate(849.8, 0)"><g data-mml-node="mover"><g data-mml-node="TeXAtom" data-mjx-texclass="OP" transform="translate(96.1, 0)"><g data-mml-node="mo"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(0, 783) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z"></path></g><g data-mml-node="mi" transform="translate(556, 0)"><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z"></path></g><g data-mml-node="mi" transform="translate(1000, 0)"><path data-c="66" d="M273 0Q255 3 146 3Q43 3 34 0H26V46H42Q70 46 91 49Q99 52 103 60Q104 62 104 224V385H33V431H104V497L105 564L107 574Q126 639 171 668T266 704Q267 704 275 704T289 705Q330 702 351 679T372 627Q372 604 358 590T321 576T284 590T270 627Q270 647 288 667H284Q280 668 273 668Q245 668 223 647T189 592Q183 572 182 497V431H293V385H185V225Q185 63 186 61T189 57T194 54T199 51T206 49T213 48T222 47T231 47T241 46T251 46H282V0H273Z"></path></g></g></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2097.7, 0)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(572, -150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(975.6, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(1420.2, 0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(2758.9, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(3203.6, 0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, -150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></g></svg></mjx-container></li>
</ol>
<h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol>
<li>两个quad空格，符号：<code>\qquad</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="6.928ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 3062 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mstyle" transform="translate(572, 0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mi" transform="translate(2572, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>quad空格，符号：<code>\quad</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="4.665ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 2062 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mstyle" transform="translate(572, 0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mi" transform="translate(1572, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>大空格，符号<code>\</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="2.968ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 1312 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mtext" transform="translate(572, 0)"><path data-c="A0" d=""></path></g><g data-mml-node="mi" transform="translate(822, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>中空格，符号<code>\:</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="4.289ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 1895.6 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mi" transform="translate(1405.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>小空格，符号<code>\,</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="3.409ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 1506.7 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1016.7, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>没有空格，符号``，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="2.403ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 1062 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>紧贴，符号<code>\!</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="3.032ex" height="2.084ex" role="img" focusable="false" viewBox="0 -716 1340 921"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572, 0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"></path></g><g data-mml-node="mi" transform="translate(850, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
</ol>
<h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol>
<li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -2.827ex" xmlns="http://www.w3.org/2000/svg" width="16.389ex" height="6.785ex" role="img" focusable="false" viewBox="0 -1749.5 7243.8 2999"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><text data-variant="normal" transform="matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">（</text><text data-variant="normal" transform="translate(900, 0) matrix(1 0 0 -1 0 0)" font-size="884px" font-family="serif">）</text></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2077.8, 0)"><g data-mml-node="mo"><path data-c="28" d="M152 251Q152 646 388 850H416Q422 844 422 841Q422 837 403 816T357 753T302 649T255 482T236 250Q236 124 255 19T301 -147T356 -251T403 -315T422 -340Q422 -343 416 -349H388Q359 -325 332 -296T271 -213T212 -97T170 56T152 251Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2535.8, 0)"><g data-mml-node="mo"><path data-c="29" d="M305 251Q305 -145 69 -349H56Q43 -349 39 -347T35 -338Q37 -333 60 -307T108 -239T160 -136T204 27T221 250T204 473T160 636T108 740T60 807T35 839Q35 850 50 850H56H69Q197 743 256 566Q305 425 305 251Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2993.8, 0)"><g data-mml-node="mo"><path data-c="28" d="M180 96T180 250T205 541T266 770T353 944T444 1069T527 1150H555Q561 1144 561 1141Q561 1137 545 1120T504 1072T447 995T386 878T330 721T288 513T272 251Q272 133 280 56Q293 -87 326 -209T399 -405T475 -531T536 -609T561 -640Q561 -643 555 -649H527Q483 -612 443 -568T353 -443T266 -270T205 -41Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3590.8, 0)"><g data-mml-node="mo"><path data-c="29" d="M35 1138Q35 1150 51 1150H56H69Q113 1113 153 1069T243 944T330 771T391 541T416 250T391 -40T330 -270T243 -443T152 -568T69 -649H56Q43 -649 39 -647T35 -637Q65 -607 110 -548Q283 -316 316 56Q324 133 324 251Q324 368 316 445Q278 877 48 1123Q36 1137 35 1138Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4187.8, 0)"><g data-mml-node="mo"><path data-c="28" d="M701 -940Q701 -943 695 -949H664Q662 -947 636 -922T591 -879T537 -818T475 -737T412 -636T350 -511T295 -362T250 -186T221 17T209 251Q209 962 573 1361Q596 1386 616 1405T649 1437T664 1450H695Q701 1444 701 1441Q701 1436 681 1415T629 1356T557 1261T476 1118T400 927T340 675T308 359Q306 321 306 250Q306 -139 400 -430T690 -924Q701 -936 701 -940Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4923.8, 0)"><g data-mml-node="mo"><path data-c="29" d="M34 1438Q34 1446 37 1448T50 1450H56H71Q73 1448 99 1423T144 1380T198 1319T260 1238T323 1137T385 1013T440 864T485 688T514 485T526 251Q526 134 519 53Q472 -519 162 -860Q139 -885 119 -904T86 -936T71 -949H56Q43 -949 39 -947T34 -937Q88 -883 140 -813Q428 -430 428 251Q428 453 402 628T338 922T245 1146T145 1309T46 1425Q44 1427 42 1429T39 1433T36 1436L34 1438Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(5659.8, 0)"><g data-mml-node="mo"><path data-c="28" d="M758 -1237T758 -1240T752 -1249H736Q718 -1249 717 -1248Q711 -1245 672 -1199Q237 -706 237 251T672 1700Q697 1730 716 1749Q718 1750 735 1750H752Q758 1744 758 1741Q758 1737 740 1713T689 1644T619 1537T540 1380T463 1176Q348 802 348 251Q348 -242 441 -599T744 -1218Q758 -1237 758 -1240Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(6451.8, 0)"><g data-mml-node="mo"><path data-c="29" d="M33 1741Q33 1750 51 1750H60H65Q73 1750 81 1743T119 1700Q554 1207 554 251Q554 -707 119 -1199Q76 -1250 66 -1250Q65 -1250 62 -1250T56 -1249Q55 -1249 53 -1249T49 -1250Q33 -1250 33 -1239Q33 -1236 50 -1214T98 -1150T163 -1052T238 -910T311 -727Q443 -335 443 251Q443 402 436 532T405 831T339 1142T224 1438T50 1716Q33 1737 33 1741Z"></path></g></g></g></g></svg></mjx-container></li>
<li>中括号，符号：<code>[]</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="6.426ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2840.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(278, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1072.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2072.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.4, 0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container></li>
<li>大括号，符号：<code>\{ \}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="5.168ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 2284.4 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></li>
<li>自适应括号，符号：<code>\left \right</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="3.054ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 1350 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(961, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.215ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2305 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(961, 0)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(490, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g><g data-mml-node="mo" transform="translate(1916, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></li>
<li>组合公式，符号：<code>{上位公式 \choose 下位公式}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.912ex" xmlns="http://www.w3.org/2000/svg" width="18.842ex" height="2.982ex" role="img" focusable="false" viewBox="0 -914.9 8328.3 1317.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mrow"><g data-mml-node="TeXAtom" data-mjx-texclass="OPEN"><g data-mml-node="mo"><path data-c="28" d="M152 251Q152 646 388 850H416Q422 844 422 841Q422 837 403 816T357 753T302 649T255 482T236 250Q236 124 255 19T301 -147T356 -251T403 -315T422 -340Q422 -343 416 -349H388Q359 -325 332 -296T271 -213T212 -97T170 56T152 251Z"></path></g></g><g data-mml-node="mfrac" transform="translate(458, 0)"><g data-mml-node="mrow" transform="translate(0, 444) scale(0.707)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1378, 0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mi" transform="translate(479.8, -345) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="CLOSE" transform="translate(1785.9, 0)"><g data-mml-node="mo"><path data-c="29" d="M305 251Q305 -145 69 -349H56Q43 -349 39 -347T35 -338Q37 -333 60 -307T108 -239T160 -136T204 27T221 250T204 473T160 636T108 740T60 807T35 839Q35 850 50 850H56H69Q197 743 256 566Q305 425 305 251Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(2521.7, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3577.5, 0)"><g data-mml-node="mrow"><g data-mml-node="TeXAtom" data-mjx-texclass="OPEN"><g data-mml-node="mo"><path data-c="28" d="M152 251Q152 646 388 850H416Q422 844 422 841Q422 837 403 816T357 753T302 649T255 482T236 250Q236 124 255 19T301 -147T356 -251T403 -315T422 -340Q422 -343 416 -349H388Q359 -325 332 -296T271 -213T212 -97T170 56T152 251Z"></path></g></g><g data-mml-node="mfrac" transform="translate(458, 0)"><g data-mml-node="mi" transform="translate(0, 444) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(27.9, -345) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="CLOSE" transform="translate(882.3, 0)"><g data-mml-node="mo"><path data-c="29" d="M305 251Q305 -145 69 -349H56Q43 -349 39 -347T35 -338Q37 -333 60 -307T108 -239T160 -136T204 27T221 250T204 473T160 636T108 740T60 807T35 839Q35 850 50 850H56H69Q197 743 256 566Q305 425 305 251Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(5140, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(6140.2, 0)"><g data-mml-node="mrow"><g data-mml-node="TeXAtom" data-mjx-texclass="OPEN"><g data-mml-node="mo"><path data-c="28" d="M152 251Q152 646 388 850H416Q422 844 422 841Q422 837 403 816T357 753T302 649T255 482T236 250Q236 124 255 19T301 -147T356 -251T403 -315T422 -340Q422 -343 416 -349H388Q359 -325 332 -296T271 -213T212 -97T170 56T152 251Z"></path></g></g><g data-mml-node="mfrac" transform="translate(458, 0)"><g data-mml-node="mi" transform="translate(423.9, 444) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mrow" transform="translate(0, -345) scale(0.707)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(521, 0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1299, 0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="CLOSE" transform="translate(1730.1, 0)"><g data-mml-node="mo"><path data-c="29" d="M305 251Q305 -145 69 -349H56Q43 -349 39 -347T35 -338Q37 -333 60 -307T108 -239T160 -136T204 27T221 250T204 473T160 636T108 740T60 807T35 839Q35 850 50 850H56H69Q197 743 256 566Q305 425 305 251Z"></path></g></g></g></g></g></g></svg></mjx-container></li>
<li>组合公式，符号：<code>{上位公式 \atop 下位公式}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.626ex" xmlns="http://www.w3.org/2000/svg" width="19.938ex" height="3.322ex" role="img" focusable="false" viewBox="0 -750 8812.6 1468.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munder"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="TeXAtom" transform="translate(1056, -307.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(508.9, 444) scale(0.707)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -312.4)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1071, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1349, 0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -312.4)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(2420, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(2698, 0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(3870, 0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="mn" transform="translate(4648, 0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mrow" transform="translate(120, -345) scale(0.707)"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -312.4)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(1071, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msub" transform="translate(1849, 0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -312.4)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(2920, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(3698, 0)"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path></g><g data-mml-node="mo" transform="translate(4870, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(5648, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></g><g data-mml-node="msub" transform="translate(4566.4, 0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="TeXAtom" transform="translate(750, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></g><g data-mml-node="msub" transform="translate(6020.1, 0)"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="TeXAtom" transform="translate(750, -150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(521, -150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(7640.6, 0)"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path></g></g></g></svg></mjx-container></li>
</ol>
<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol>
<li>加法运算，符号：<code>+</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>减法运算，符号：<code>-</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>加减运算，符号：<code>\pm</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.971ex" role="img" focusable="false" viewBox="0 -666 4083 871"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="B1" d="M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>减甲运算，符号：<code>\mp</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2213" d="M56 467T56 480T70 500H707Q722 492 722 480T707 460H409V187H707Q722 179 722 167Q722 154 707 147H409V0V-93Q409 -144 406 -155T389 -166Q376 -166 372 -155T368 -105Q368 -96 368 -62T369 -2V147H70Q56 154 56 167T70 187H369V460H70Q56 467 56 480Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>乘法运算，符号：<code>\times</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>点乘运算，符号：<code>\cdot</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="8.106ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 3583 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mi" transform="translate(1294.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2062.2, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3118, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>星乘运算，符号：<code>\ast</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="8.609ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 3805 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(1516.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2284.2, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3340, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>除法运算，符号：<code>\div</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="F7" d="M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>斜法运算，符号：<code>/</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.603ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3360.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(572, 0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mi" transform="translate(1072, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1839.8, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2895.6, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>分式表示，符号：<code>\frac{分子}{分母}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.108ex" xmlns="http://www.w3.org/2000/svg" width="3.939ex" height="3.138ex" role="img" focusable="false" viewBox="0 -897.2 1741.1 1387.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220, 485) scale(0.707)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1350, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mrow" transform="translate(257.8, -345) scale(0.707)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(490, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1268, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g><rect width="1501.1" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></li>
<li>分式表示，符号：<code>{分子} \voer {分母}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.108ex" xmlns="http://www.w3.org/2000/svg" width="3.939ex" height="3.138ex" role="img" focusable="false" viewBox="0 -897.2 1741.1 1387.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="TeXAtom" transform="translate(220, 485) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1350, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(257.8, -345) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(490, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1268, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g><rect width="1501.1" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></li>
<li>绝对值表示，符号：<code>||</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex" xmlns="http://www.w3.org/2000/svg" width="6.426ex" height="2.26ex" role="img" focusable="false" viewBox="0 -749.5 2840.4 999"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="mi" transform="translate(278, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1072.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2072.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.4, 0)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g></g></g></svg></mjx-container></li>
</ol>
<h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol>
<li>平均数运算，符号：<code>\overline{算式}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="3.455ex" height="2.216ex" role="img" focusable="false" viewBox="0 -774.5 1527 979.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mrow" transform="translate(0, 0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1062, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g><g data-mml-node="mo" transform="translate(0, 257.3) scale(0.707)"><svg width="2159.5" height="246" x="0" y="444" viewBox="539.9 444 2159.5 246"><path data-c="AF" d="M69 544V590H430V544H69Z" transform="scale(6.479, 1)"></path></svg></g></g></g></g></svg></mjx-container></li>
<li>开二次方运算，符号：<code>\sqrt</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.491ex" xmlns="http://www.w3.org/2000/svg" width="3.224ex" height="2.398ex" role="img" focusable="false" viewBox="0 -843 1425 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msqrt"><g transform="translate(853, 0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g><g data-mml-node="mo" transform="translate(0, -17)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="572" height="60" x="853" y="723"></rect></g></g></g></svg></mjx-container></li>
<li>开方运算，符号：<code>\sqrt[开方数]{被开方数}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.551ex" xmlns="http://www.w3.org/2000/svg" width="6.093ex" height="2.398ex" role="img" focusable="false" viewBox="0 -816.5 2693 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mroot"><g><g data-mml-node="mrow" transform="translate(853, 0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1350, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g><g data-mml-node="mn" transform="translate(261.8, 317.5) scale(0.5)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(0, -43.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="1840" height="60" x="853" y="696.5"></rect></g></g></g></svg></mjx-container></li>
<li>对数运算，符号：<code>\log</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.946ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2628 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278, 0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778, 0)"></path></g><g data-mml-node="mo" transform="translate(1278, 0)"><path data-c="2061" d=""></path></g><g data-mml-node="mo" transform="translate(1278, 0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1667, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(2239, 0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></li>
<li>极限运算，符号：<code>\lim</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.108ex" xmlns="http://www.w3.org/2000/svg" width="9.658ex" height="2.879ex" role="img" focusable="false" viewBox="0 -782.4 4268.8 1272.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(278, 0)"></path><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(556, 0)"></path></g><g data-mml-node="TeXAtom" transform="translate(1389, 421.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1572, 0)"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(1389, -247) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(490, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1490, 0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3424.3, 0)"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220, 394) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(249, -345) scale(0.707)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="604.5" height="60" x="120" y="220"></rect></g></g></g></g></svg></mjx-container></li>
<li>极限运算，符号：<code>\displaystyle \lim</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -2.016ex" xmlns="http://www.w3.org/2000/svg" width="6.781ex" height="5.082ex" role="img" focusable="false" viewBox="0 -1355.3 2997.3 2246.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="munderover"><g data-mml-node="mo" transform="translate(214.8, 0)"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(278, 0)"></path><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(556, 0)"></path></g><g data-mml-node="TeXAtom" transform="translate(205.8, -637.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(490, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1490, 0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(0, 894) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1572, 0)"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1985.3, 0)"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220, 676)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(261, -686)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="772" height="60" x="120" y="220"></rect></g></g></g></g></g></svg></mjx-container></li>
<li>求和运算，符号：<code>\sum</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.108ex" xmlns="http://www.w3.org/2000/svg" width="8.905ex" height="3.005ex" role="img" focusable="false" viewBox="0 -838.4 3935.8 1328.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="munderover"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"></path></g><g data-mml-node="TeXAtom" transform="translate(1056, 477.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1572, 0)"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(1056, -285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(490, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1490, 0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3091.3, 0)"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220, 394) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(249, -345) scale(0.707)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="604.5" height="60" x="120" y="220"></rect></g></g></g></g></svg></mjx-container></li>
<li>求和运算，符号：<code>\displaystyle \sum</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -3.016ex" xmlns="http://www.w3.org/2000/svg" width="6.781ex" height="6.661ex" role="img" focusable="false" viewBox="0 -1611.3 2997.3 2944.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="munderover"><g data-mml-node="mo" transform="translate(187.3, 0)"><path data-c="2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path></g><g data-mml-node="TeXAtom" transform="translate(205.8, -1087.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(490, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1490, 0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(0, 1150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(572, 0)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1572, 0)"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1985.3, 0)"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220, 676)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(261, -686)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><rect width="772" height="60" x="120" y="220"></rect></g></g></g></g></g></svg></mjx-container></li>
<li>积分运算，符号：<code>\int</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.806ex" xmlns="http://www.w3.org/2000/svg" width="7.364ex" height="2.718ex" role="img" focusable="false" viewBox="0 -845.1 3254.7 1201.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mo"><path data-c="222B" d="M113 -244Q113 -246 119 -251T139 -263T167 -269Q186 -269 199 -260Q220 -247 232 -218T251 -133T262 -15T276 155T297 367Q300 390 305 438T314 512T325 580T340 647T361 703T390 751T428 784T479 804Q481 804 488 804T501 805Q552 802 581 769T610 695Q610 669 594 657T561 645Q542 645 527 658T512 694Q512 705 516 714T526 729T538 737T548 742L552 743Q552 745 545 751T525 762T498 768Q475 768 460 756T434 716T418 652T407 559T398 444T387 300T369 133Q349 -38 337 -102T303 -207Q256 -306 169 -306Q119 -306 87 -272T55 -196Q55 -170 71 -158T104 -146Q123 -146 138 -159T153 -195Q153 -206 149 -215T139 -230T127 -238T117 -242L113 -244Z"></path></g><g data-mml-node="TeXAtom" transform="translate(666.9, 532.6) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(472, -340.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1590.7, 0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(1092, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></g></svg></mjx-container></li>
<li>积分运算，符号：<code>\displaystyle \int</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -2.063ex" xmlns="http://www.w3.org/2000/svg" width="8.147ex" height="5.232ex" role="img" focusable="false" viewBox="0 -1400.6 3601.2 2312.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mstyle"><g data-mml-node="msubsup"><g data-mml-node="mo"><path data-c="222B" d="M114 -798Q132 -824 165 -824H167Q195 -824 223 -764T275 -600T320 -391T362 -164Q365 -143 367 -133Q439 292 523 655T645 1127Q651 1145 655 1157T672 1201T699 1257T733 1306T777 1346T828 1360Q884 1360 912 1325T944 1245Q944 1220 932 1205T909 1186T887 1183Q866 1183 849 1198T832 1239Q832 1287 885 1296L882 1300Q879 1303 874 1307T866 1313Q851 1323 833 1323Q819 1323 807 1311T775 1255T736 1139T689 936T633 628Q574 293 510 -5T410 -437T355 -629Q278 -862 165 -862Q125 -862 92 -831T55 -746Q55 -711 74 -698T112 -685Q133 -685 150 -700T167 -741Q167 -789 114 -798Z"></path></g><g data-mml-node="TeXAtom" transform="translate(1013.4, 1088.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g><g data-mml-node="TeXAtom" transform="translate(556, -896.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1937.2, 0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mi" transform="translate(572, 0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(1092, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>微分运算，符号：<code>\partial</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.11ex" xmlns="http://www.w3.org/2000/svg" width="2.816ex" height="3.145ex" role="img" focusable="false" viewBox="0 -899.6 1244.7 1390.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mrow" transform="translate(220, 394) scale(0.707)"><g data-mml-node="mi"><path data-c="1D715" d="M202 508Q179 508 169 520T158 547Q158 557 164 577T185 624T230 675T301 710L333 715H345Q378 715 384 714Q447 703 489 661T549 568T566 457Q566 362 519 240T402 53Q321 -22 223 -22Q123 -22 73 56Q42 102 42 148V159Q42 276 129 370T322 465Q383 465 414 434T455 367L458 378Q478 461 478 515Q478 603 437 639T344 676Q266 676 223 612Q264 606 264 572Q264 547 246 528T202 508ZM430 306Q430 372 401 400T333 428Q270 428 222 382Q197 354 183 323T150 221Q132 149 132 116Q132 21 232 21Q244 21 250 22Q327 35 374 112Q389 137 409 196T430 306Z"></path></g><g data-mml-node="mi" transform="translate(566, 0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g><g data-mml-node="mrow" transform="translate(249, -345.6) scale(0.707)"><g data-mml-node="mi"><path data-c="1D715" d="M202 508Q179 508 169 520T158 547Q158 557 164 577T185 624T230 675T301 710L333 715H345Q378 715 384 714Q447 703 489 661T549 568T566 457Q566 362 519 240T402 53Q321 -22 223 -22Q123 -22 73 56Q42 102 42 148V159Q42 276 129 370T322 465Q383 465 414 434T455 367L458 378Q478 461 478 515Q478 603 437 639T344 676Q266 676 223 612Q264 606 264 572Q264 547 246 528T202 508ZM430 306Q430 372 401 400T333 428Q270 428 222 382Q197 354 183 323T150 221Q132 149 132 116Q132 21 232 21Q244 21 250 22Q327 35 374 112Q389 137 409 196T430 306Z"></path></g><g data-mml-node="mi" transform="translate(566, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><rect width="1004.7" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></li>
<li>矩阵表示，符号：<code>\begin{matrix} \end{matrix}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.469ex" xmlns="http://www.w3.org/2000/svg" width="57.864ex" height="4.07ex" role="img" focusable="false" viewBox="0 -1149.5 25576 1799"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="5B" d="M224 -649V1150H455V1099H275V-598H455V-649H224Z"></path></g><g data-mml-node="mtable" transform="translate(472, 0)"><g data-mml-node="mtr" transform="translate(0, -385)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mtd" transform="translate(1500, 0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mtd" transform="translate(3000, 0)"><g data-mml-node="mo"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path></g></g><g data-mml-node="mtd" transform="translate(5172, 0)"><g data-mml-node="mn"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mtext" fill="red" stroke="red" transform="translate(500, 0)"><path data-c="5C" d="M56 731Q56 740 62 745T75 750Q85 750 92 740Q96 733 270 255T444 -231Q444 -239 438 -244T424 -250Q414 -250 407 -240Q404 -236 230 242T56 731Z"></path><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500, 0)"></path></g></g><g data-mml-node="mtd" transform="translate(7672, 0)"><g data-mml-node="mn"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"></path></g></g><g data-mml-node="mtd" transform="translate(9172, 0)"><g data-mml-node="mo"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path></g></g><g data-mml-node="mtd" transform="translate(11344, 0)"><g data-mml-node="mn"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500, 0)"><g data-mml-node="mo"><path data-c="22EE" d="M78 30Q78 54 95 72T138 90Q162 90 180 74T199 31Q199 6 182 -12T139 -30T96 -13T78 30ZM78 440Q78 464 95 482T138 500Q162 500 180 484T199 441Q199 416 182 398T139 380T96 397T78 440ZM78 840Q78 864 95 882T138 900Q162 900 180 884T199 841Q199 816 182 798T139 780T96 797T78 840Z"></path></g></g></g><g data-mml-node="mtd" transform="translate(13122, 0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="22EE" d="M78 30Q78 54 95 72T138 90Q162 90 180 74T199 31Q199 6 182 -12T139 -30T96 -13T78 30ZM78 440Q78 464 95 482T138 500Q162 500 180 484T199 441Q199 416 182 398T139 380T96 397T78 440ZM78 840Q78 864 95 882T138 900Q162 900 180 884T199 841Q199 816 182 798T139 780T96 797T78 840Z"></path></g></g></g><g data-mml-node="mtd" transform="translate(14400, 0)"><g data-mml-node="mo"><path data-c="22F1" d="M133 760Q133 784 150 802T193 820Q217 820 235 804T254 761Q254 736 237 718T194 700T151 717T133 760ZM580 460Q580 484 597 502T640 520Q664 520 682 504T701 461Q701 436 684 418T641 400T598 417T580 460ZM1027 160Q1027 184 1044 202T1087 220Q1111 220 1129 204T1148 161Q1148 136 1131 118T1088 100T1045 117T1027 160Z"></path></g></g><g data-mml-node="mtd" transform="translate(16682, 0)"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="22EE" d="M78 30Q78 54 95 72T138 90Q162 90 180 74T199 31Q199 6 182 -12T139 -30T96 -13T78 30ZM78 440Q78 464 95 482T138 500Q162 500 180 484T199 441Q199 416 182 398T139 380T96 397T78 440ZM78 840Q78 864 95 882T138 900Q162 900 180 884T199 841Q199 816 182 798T139 780T96 797T78 840Z"></path></g></g><g data-mml-node="mtext" fill="red" stroke="red" transform="translate(278, 0)"><path data-c="5C" d="M56 731Q56 740 62 745T75 750Q85 750 92 740Q96 733 270 255T444 -231Q444 -239 438 -244T424 -250Q414 -250 407 -240Q404 -236 230 242T56 731Z"></path><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z" transform="translate(500, 0)"></path></g><g data-mml-node="mn" transform="translate(1278, 0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g><g data-mml-node="mtd" transform="translate(19460, 0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500, 0)"></path></g></g><g data-mml-node="mtd" transform="translate(21460, 0)"><g data-mml-node="mo"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path></g></g><g data-mml-node="mtd" transform="translate(23632, 0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500, 0)"></path></g></g></g></g><g data-mml-node="mo" transform="translate(25104, 0)"><path data-c="5D" d="M16 1099V1150H247V-649H16V-598H196V1099H16Z"></path></g></g></g></g></svg></mjx-container></li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol>
<li>等于运算，符号：<code>=</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>大于运算，符号：<code>&gt;</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>小于运算，符号：<code>&lt;</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>大于等于运算，符号：<code>\geq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.903ex" role="img" focusable="false" viewBox="0 -636 4083 841"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="2265" d="M83 616Q83 624 89 630T99 636Q107 636 253 568T543 431T687 361Q694 356 694 346T687 331Q685 329 395 192L107 56H101Q83 58 83 76Q83 77 83 79Q82 86 98 95Q117 105 248 167Q326 204 378 228L626 346L360 472Q291 505 200 548Q112 589 98 597T83 616ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>小于等于运算，符号：<code>\leq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.903ex" role="img" focusable="false" viewBox="0 -636 4083 841"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>不等于运算，符号：<code>\neq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.486ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="2.106ex" role="img" focusable="false" viewBox="0 -716 4083 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="2260" d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>不大于等于运算，符号：<code>\ngeq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.686ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="2.498ex" role="img" focusable="false" viewBox="0 -801 4083 1104"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="2271" d="M97 54Q82 54 82 72Q82 79 86 84Q95 91 222 153L351 215L398 324L442 433L258 519Q95 597 87 604Q82 608 82 615T88 628T102 635Q107 635 424 484L458 468L524 630Q593 789 597 795Q601 801 609 801Q616 801 622 795T629 781L562 615L493 450L589 406Q665 371 679 362T694 344Q694 339 693 337T677 326T631 302T538 257Q504 241 465 223T406 195T386 186Q384 185 322 39L262 -103H680Q682 -105 684 -108T688 -113T691 -118T693 -124Q693 -134 682 -141L464 -143H246L213 -219Q182 -292 178 -299Q172 -303 166 -303T153 -297T146 -283Q146 -282 174 -213T202 -143H146L93 -141Q82 -134 82 -124Q82 -120 83 -117T89 -110T95 -103H220L273 26Q326 156 326 157L218 106Q109 54 97 54ZM553 379Q480 412 480 415Q479 415 460 372T423 285T406 241Q408 240 516 291T624 344L553 379Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>不大于等于运算，符号：<code>\not\geq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.686ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="2.498ex" role="img" focusable="false" viewBox="0 -801 4083 1104"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="2271" d="M97 54Q82 54 82 72Q82 79 86 84Q95 91 222 153L351 215L398 324L442 433L258 519Q95 597 87 604Q82 608 82 615T88 628T102 635Q107 635 424 484L458 468L524 630Q593 789 597 795Q601 801 609 801Q616 801 622 795T629 781L562 615L493 450L589 406Q665 371 679 362T694 344Q694 339 693 337T677 326T631 302T538 257Q504 241 465 223T406 195T386 186Q384 185 322 39L262 -103H680Q682 -105 684 -108T688 -113T691 -118T693 -124Q693 -134 682 -141L464 -143H246L213 -219Q182 -292 178 -299Q172 -303 166 -303T153 -297T146 -283Q146 -282 174 -213T202 -143H146L93 -141Q82 -134 82 -124Q82 -120 83 -117T89 -110T95 -103H220L273 26Q326 156 326 157L218 106Q109 54 97 54ZM553 379Q480 412 480 415Q479 415 460 372T423 285T406 241Q408 240 516 291T624 344L553 379Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>不小于等于运算，符号：<code>\nleq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.686ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="2.498ex" role="img" focusable="false" viewBox="0 -801 4083 1104"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="2270" d="M82 -124Q82 -120 83 -117T89 -110T95 -103H220L284 50Q346 204 344 206L218 268Q153 297 123 313T87 333T82 344T86 355Q104 369 291 455Q491 552 491 553L542 673Q581 767 590 784T609 801Q616 801 622 795T629 781Q629 773 586 677Q546 581 546 577L609 606Q669 635 673 635Q680 635 686 629T693 615Q693 610 692 608T670 593T604 561L524 521L400 226L542 157Q617 123 649 107T687 85T694 72Q694 66 690 60T679 54Q664 54 526 121Q513 127 495 136T464 150T438 162T416 173T399 180T388 185L384 186Q383 186 322 41L262 -103H680Q682 -105 684 -108T688 -113T691 -118T693 -124Q693 -134 682 -141L464 -143H246L213 -219Q182 -292 178 -299Q172 -303 166 -303T153 -297T146 -283Q146 -282 174 -213T202 -143H146L93 -141Q82 -134 82 -124ZM418 370L466 495Q464 495 308 420T151 344T204 317T311 267T364 244Q364 247 418 370Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>不小于等于运算，符号：<code>\not\leq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.686ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="2.498ex" role="img" focusable="false" viewBox="0 -801 4083 1104"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="2270" d="M82 -124Q82 -120 83 -117T89 -110T95 -103H220L284 50Q346 204 344 206L218 268Q153 297 123 313T87 333T82 344T86 355Q104 369 291 455Q491 552 491 553L542 673Q581 767 590 784T609 801Q616 801 622 795T629 781Q629 773 586 677Q546 581 546 577L609 606Q669 635 673 635Q680 635 686 629T693 615Q693 610 692 608T670 593T604 561L524 521L400 226L542 157Q617 123 649 107T687 85T694 72Q694 66 690 60T679 54Q664 54 526 121Q513 127 495 136T464 150T438 162T416 173T399 180T388 185L384 186Q383 186 322 41L262 -103H680Q682 -105 684 -108T688 -113T691 -118T693 -124Q693 -134 682 -141L464 -143H246L213 -219Q182 -292 178 -299Q172 -303 166 -303T153 -297T146 -283Q146 -282 174 -213T202 -143H146L93 -141Q82 -134 82 -124ZM418 370L466 495Q464 495 308 420T151 344T204 317T311 267T364 244Q364 247 418 370Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>约等于运算，符号：<code>\approx</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="2248" d="M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
<li>恒定等于运算，符号：<code>\equiv</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="9.238ex" height="1.783ex" role="img" focusable="false" viewBox="0 -583 4083 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2562.2, 0)"><path data-c="2261" d="M56 444Q56 457 70 464H707Q722 456 722 444Q722 430 706 424H72Q56 429 56 444ZM56 237T56 250T70 270H707Q722 262 722 250T707 230H70Q56 237 56 250ZM56 56Q56 71 72 76H706Q722 70 722 56Q722 44 707 36H70Q56 43 56 56Z"></path></g><g data-mml-node="mi" transform="translate(3618, 0)"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"></path></g></g></g></svg></mjx-container></li>
</ol>
<h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol>
<li>属于运算，符号：<code>\in</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="5.169ex" height="1.686ex" role="img" focusable="false" viewBox="0 -540 2284.6 745"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1794.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>不属于运算，符号：<code>\notin</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.486ex" xmlns="http://www.w3.org/2000/svg" width="5.169ex" height="2.106ex" role="img" focusable="false" viewBox="0 -716 2284.6 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="2209" d="M196 25Q84 109 84 250Q84 372 166 450T360 539Q361 539 375 539T413 540T460 540L547 707Q550 716 563 716Q570 716 575 712T581 703T583 696T505 540H568Q583 532 583 520Q583 511 570 501L484 500L366 270H568Q583 262 583 250T568 230H346L247 38Q284 16 328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 447 -40T419 -41Q304 -41 228 3Q117 -211 115 -212Q111 -215 104 -215T92 -212T86 -204T84 -197Q84 -190 89 -183L196 25ZM214 61L301 230H124V228Q124 196 147 147T214 61ZM321 270L440 500Q353 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H321Z"></path></g><g data-mml-node="mi" transform="translate(1794.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>不属于运算，符号：<code>\not\in</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.486ex" xmlns="http://www.w3.org/2000/svg" width="5.169ex" height="2.106ex" role="img" focusable="false" viewBox="0 -716 2284.6 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="2209" d="M196 25Q84 109 84 250Q84 372 166 450T360 539Q361 539 375 539T413 540T460 540L547 707Q550 716 563 716Q570 716 575 712T581 703T583 696T505 540H568Q583 532 583 520Q583 511 570 501L484 500L366 270H568Q583 262 583 250T568 230H346L247 38Q284 16 328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 447 -40T419 -41Q304 -41 228 3Q117 -211 115 -212Q111 -215 104 -215T92 -212T86 -204T84 -197Q84 -190 89 -183L196 25ZM214 61L301 230H124V228Q124 196 147 147T214 61ZM321 270L440 500Q353 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H321Z"></path></g><g data-mml-node="mi" transform="translate(1794.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>子集运算，符号：<code>\subset</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="5.42ex" height="1.686ex" role="img" focusable="false" viewBox="0 -540 2395.6 745"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="2282" d="M84 250Q84 372 166 450T360 539Q361 539 370 539T395 539T430 540T475 540T524 540H679Q694 532 694 520Q694 511 681 501L522 500H470H441Q366 500 338 496T266 472Q244 461 224 446T179 404T139 337T124 250V245Q124 157 185 89Q244 25 328 7Q348 2 366 2T522 0H681Q694 -10 694 -20Q694 -32 679 -40H526Q510 -40 480 -40T434 -41Q350 -41 289 -25T172 45Q84 127 84 250Z"></path></g><g data-mml-node="mi" transform="translate(1905.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>子集运算，符号：<code>\supset</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="5.42ex" height="1.686ex" role="img" focusable="false" viewBox="0 -540 2395.6 745"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="2283" d="M83 520Q83 532 98 540H251Q267 540 297 540T343 541Q427 541 488 525T605 455Q693 374 693 250Q693 165 650 99T545 0T415 -39Q407 -40 251 -40H98Q83 -32 83 -20Q83 -10 96 0H255H308H337Q412 0 439 4T512 28Q533 39 553 54T599 96T639 163T654 250Q654 341 592 411Q557 449 512 472Q468 491 439 495T335 500H306H255L96 501Q83 511 83 520Z"></path></g><g data-mml-node="mi" transform="translate(1905.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>真子集运算，符号：<code>\subseteq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="5.42ex" height="1.903ex" role="img" focusable="false" viewBox="0 -636 2395.6 841"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="2286" d="M84 346Q84 468 166 546T360 635Q361 635 370 635T395 635T430 636T475 636T524 636H679Q694 628 694 616Q694 607 681 597L522 596H470H441Q366 596 338 592T266 568Q244 557 224 542T179 500T139 433T124 346V341Q124 253 185 185Q244 121 328 103Q348 98 366 98T522 96H681Q694 86 694 76Q694 64 679 56H526Q510 56 480 56T434 55Q350 55 289 71T172 141Q84 223 84 346ZM104 -131T104 -118T118 -98H679Q694 -106 694 -118T679 -138H118Q104 -131 104 -118Z"></path></g><g data-mml-node="mi" transform="translate(1905.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>非真子集运算，符号：<code>\subsetneq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.545ex" xmlns="http://www.w3.org/2000/svg" width="5.42ex" height="1.982ex" role="img" focusable="false" viewBox="0 -635 2395.6 876"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="228A" d="M693 72Q693 68 692 66T686 59T680 52H524Q398 52 367 53T309 63Q236 82 180 132T98 250Q84 288 84 343Q84 397 98 437Q126 515 193 568T346 632Q347 632 373 633T440 634T520 635H680Q693 620 693 615Q693 608 680 595H526Q364 595 353 592Q279 582 221 539T138 430Q124 392 124 343Q124 296 138 257Q163 192 221 149T353 95Q364 92 526 92H680Q693 79 693 72ZM102 -132T102 -125T115 -103H382L420 -68Q429 -60 438 -52T452 -39T463 -28T472 -20T478 -14T483 -10T487 -7T490 -6T493 -5T496 -5Q502 -5 508 -12T515 -28Q515 -34 513 -37Q512 -38 507 -42T492 -55T475 -70L440 -101L562 -103H682Q693 -114 693 -122T680 -143H395L355 -179Q289 -241 280 -241Q273 -241 267 -235T260 -221T265 -208T300 -174L335 -143H224L113 -141L106 -137Q102 -132 102 -125Z"></path></g><g data-mml-node="mi" transform="translate(1905.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>真子集运算，符号：<code>\supseteq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="5.42ex" height="1.903ex" role="img" focusable="false" viewBox="0 -636 2395.6 841"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="2287" d="M83 616Q83 628 98 636H251Q267 636 297 636T343 637Q427 637 488 621T605 551Q693 470 693 346Q693 261 650 195T545 96T415 57Q407 56 251 56H98Q83 64 83 76Q83 86 96 96H255H308H337Q412 96 439 100T512 124Q533 135 553 150T599 192T639 259T654 346Q654 437 592 507Q557 545 512 568Q468 587 439 591T335 596H306H255L96 597Q83 607 83 616ZM84 -131T84 -118T98 -98H659Q674 -106 674 -118T659 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1905.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>非真子集运算，符号：<code>\supsetneq</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.545ex" xmlns="http://www.w3.org/2000/svg" width="5.42ex" height="1.982ex" role="img" focusable="false" viewBox="0 -635 2395.6 876"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><path data-c="228B" d="M82 615Q82 620 95 635H251Q378 635 409 634T469 623Q540 605 596 555T678 437Q691 397 691 343T678 250Q649 172 581 119T426 55Q415 52 251 52H95Q93 55 89 59T84 65T82 72Q82 79 95 92H249Q411 92 422 95Q496 105 554 148T638 257Q651 296 651 343Q651 391 638 430Q613 495 555 538T422 592Q411 595 249 595H95Q82 608 82 615ZM82 -132T82 -125T95 -103H380L420 -57Q452 -21 460 -14T474 -6Q482 -6 488 -12T495 -25T451 -81L433 -101L549 -103H662Q673 -114 673 -122T660 -143H395L355 -190Q311 -239 309 -239Q305 -241 302 -241Q294 -241 287 -235T280 -221T324 -163L342 -143H218L93 -141L86 -137Q82 -132 82 -125Z"></path></g><g data-mml-node="mi" transform="translate(1905.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>非子集运算，符号：<code>\not\subset</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.486ex" xmlns="http://www.w3.org/2000/svg" width="5.42ex" height="2.106ex" role="img" focusable="false" viewBox="0 -716 2395.6 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><g data-c="2284"><path data-c="2282" d="M84 250Q84 372 166 450T360 539Q361 539 370 539T395 539T430 540T475 540T524 540H679Q694 532 694 520Q694 511 681 501L522 500H470H441Q366 500 338 496T266 472Q244 461 224 446T179 404T139 337T124 250V245Q124 157 185 89Q244 25 328 7Q348 2 366 2T522 0H681Q694 -10 694 -20Q694 -32 679 -40H526Q510 -40 480 -40T434 -41Q350 -41 289 -25T172 45Q84 127 84 250Z"></path><path data-c="338" d="M-612 -215T-619 -215T-631 -212T-637 -204T-639 -197Q-639 -190 -634 -183Q-621 -157 -400 274T-176 707Q-173 716 -160 716Q-153 716 -148 712T-142 703T-140 696Q-140 691 -372 241T-608 -212Q-612 -215 -619 -215Z" transform="translate(778, 0)"></path></g></g><g data-mml-node="mi" transform="translate(1905.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>非子集运算，符号：<code>\not\supset</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.486ex" xmlns="http://www.w3.org/2000/svg" width="5.42ex" height="2.106ex" role="img" focusable="false" viewBox="0 -716 2395.6 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(849.8, 0)"><g data-c="2285"><path data-c="2283" d="M83 520Q83 532 98 540H251Q267 540 297 540T343 541Q427 541 488 525T605 455Q693 374 693 250Q693 165 650 99T545 0T415 -39Q407 -40 251 -40H98Q83 -32 83 -20Q83 -10 96 0H255H308H337Q412 0 439 4T512 28Q533 39 553 54T599 96T639 163T654 250Q654 341 592 411Q557 449 512 472Q468 491 439 495T335 500H306H255L96 501Q83 511 83 520Z"></path><path data-c="338" d="M-612 -215T-619 -215T-631 -212T-637 -204T-639 -197Q-639 -190 -634 -183Q-621 -157 -400 274T-176 707Q-173 716 -160 716Q-153 716 -148 712T-142 703T-140 696Q-140 691 -372 241T-608 -212Q-612 -215 -619 -215Z" transform="translate(778, 0)"></path></g></g><g data-mml-node="mi" transform="translate(1905.6, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>并集运算，符号：<code>\cup</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="4.917ex" height="1.817ex" role="img" focusable="false" viewBox="0 -598 2173.4 803"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="222A" d="M591 598H592Q604 598 611 583V376Q611 345 611 296Q610 162 606 148Q605 146 605 145Q586 68 507 23T333 -22Q268 -22 209 -1T106 66T56 173Q55 180 55 384L56 585Q66 598 75 598Q85 598 95 585V378L96 172L98 162Q112 95 181 57T332 18Q415 18 487 58T570 175Q571 180 571 383V583Q579 598 591 598Z"></path></g><g data-mml-node="mi" transform="translate(1683.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>交集运算，符号：<code>\cap</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex" xmlns="http://www.w3.org/2000/svg" width="4.917ex" height="1.817ex" role="img" focusable="false" viewBox="0 -598 2173.4 803"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2229" d="M88 -21T75 -21T55 -7V200Q55 231 55 280Q56 414 60 428Q61 430 61 431Q77 500 152 549T332 598Q443 598 522 544T610 405Q611 399 611 194V-7Q604 -22 591 -22Q582 -22 572 -9L570 405Q563 433 556 449T529 485Q498 519 445 538T334 558Q251 558 179 518T96 401Q95 396 95 193V-7Q88 -21 75 -21Z"></path></g><g data-mml-node="mi" transform="translate(1683.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>差集运算，符号：<code>\setminus</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.539ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2006.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(794.2, 0)"><path data-c="2216" d="M56 731Q56 740 62 745T75 750Q85 750 92 740Q96 733 270 255T444 -231Q444 -239 438 -244T424 -250Q414 -250 407 -240Q404 -236 230 242T56 731Z"></path></g><g data-mml-node="mi" transform="translate(1516.4, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>同或运算，符号：<code>\bigodot</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.67ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2506.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(738.7, 0)"><path data-c="2A00" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM555 -165Q672 -165 767 -108T916 44T970 250Q970 418 861 532T600 664Q591 665 548 665Q446 665 353 614T200 466T140 250V243Q140 88 248 -30Q262 -46 280 -62T338 -105T434 -148T555 -165ZM478 250Q478 288 503 307T551 326Q586 326 609 305T632 250Q632 217 610 196T555 174T500 196T478 250Z"></path></g><g data-mml-node="mi" transform="translate(2016.3, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>同与运算，符号：<code>\bigotimes</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.67ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2506.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(738.7, 0)"><path data-c="2A02" d="M555 -250Q420 -250 306 -185T124 -4T56 250Q56 453 193 595T526 749Q528 750 539 750Q554 750 562 749Q688 749 800 687T983 508T1054 250Q1054 112 987 -3T806 -184T555 -250ZM600 664Q591 665 548 665Q414 665 306 583L292 573L423 441L555 310L687 441L818 573L804 583Q714 650 600 664ZM364 118L495 250L364 382L232 513L223 500Q140 391 140 250Q140 107 223 0L232 -13L364 118ZM970 250Q970 389 887 501L878 512Q878 513 861 496T812 447T746 381L615 250L746 118L878 -13L887 0Q970 109 970 250ZM687 59L555 190L423 59L292 -73L306 -83Q416 -166 555 -166T804 -83L818 -73L687 59Z"></path></g><g data-mml-node="mi" transform="translate(2016.3, 0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>实数集合，符号：<code>\mathbb{R}</code>，如：<code>\mathbb{R}</code></li>
<li>自然数集合，符号：<code>\mathbb{Z}</code>，如：<code>\mathbb{Z}</code></li>
<li>空集，符号：<code>\emptyset</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.176ex" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.923ex" role="img" focusable="false" viewBox="0 -772 500 850"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="2205" d="M331 696Q335 708 339 722T345 744T350 759T357 769T367 772Q374 772 381 767T388 754Q388 746 377 712L366 673L378 661Q460 575 460 344Q460 281 456 234T432 126T373 27Q319 -22 250 -22Q214 -22 180 -7Q168 -3 168 -4L159 -33Q148 -71 142 -75Q138 -78 132 -78Q124 -78 118 -72T111 -60Q111 -52 122 -18L133 21L125 29Q39 111 39 344Q39 596 137 675Q187 716 251 716Q265 716 278 714T296 710T315 703T331 696ZM276 676Q264 679 246 679Q196 679 159 631Q134 597 128 536T121 356Q121 234 127 174T151 80L234 366Q253 430 275 506T308 618L318 654Q318 656 294 669L276 676ZM181 42Q207 16 250 16Q291 16 324 47Q354 78 366 136T378 356Q378 470 372 528T349 616L348 613Q348 611 264 326L181 42Z"></path></g></g></g></svg></mjx-container></li>
</ol>
<h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol>
<li>无穷，符号：<code>\infty</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 1000 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="221E" d="M55 217Q55 305 111 373T254 442Q342 442 419 381Q457 350 493 303L507 284L514 294Q618 442 747 442Q833 442 888 374T944 214Q944 128 889 59T743 -11Q657 -11 580 50Q542 81 506 128L492 147L485 137Q381 -11 252 -11Q166 -11 111 57T55 217ZM907 217Q907 285 869 341T761 397Q740 397 720 392T682 378T648 359T619 335T594 310T574 285T559 263T548 246L543 238L574 198Q605 158 622 138T664 94T714 61T765 51Q827 51 867 100T907 217ZM92 214Q92 145 131 89T239 33Q357 33 456 193L425 233Q364 312 334 337Q285 380 233 380Q171 380 132 331T92 214Z"></path></g></g></g></svg></mjx-container></li>
<li>虚数，符号：<code>\imath</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="0.769ex" height="1.02ex" role="img" focusable="false" viewBox="0 -441 340 451"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="131" d="M75 287Q75 292 82 313T103 362T142 413T196 441H214Q248 441 270 419T293 357Q292 338 289 330T245 208Q193 72 193 46Q193 26 209 26Q228 26 247 43Q273 71 292 136Q295 148 297 150T311 153H317Q327 153 330 153T337 150T340 143Q340 133 330 105T292 41T228 -8Q220 -10 204 -10Q160 -10 141 15T122 71Q122 98 171 227T221 384Q221 396 218 400T203 405Q175 403 156 374T128 312T116 279Q115 278 97 278H81Q75 284 75 287Z"></path></g></g></g></svg></mjx-container></li>
<li>虚数，符号：<code>\jmath</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex" xmlns="http://www.w3.org/2000/svg" width="0.751ex" height="1.462ex" role="img" focusable="false" viewBox="0 -442 332 646"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="237" d="M75 284T75 287T81 305T101 343T133 389T180 426T240 442Q273 440 300 420T327 350V332L278 134Q267 92 253 37T233 -45T225 -73Q208 -123 162 -163T54 -204Q8 -204 -15 -181Q-32 -164 -32 -140Q-32 -112 -14 -96T27 -79Q48 -79 57 -91T67 -114Q67 -146 39 -166L44 -167H59H60Q112 -167 145 -74Q148 -65 198 134T251 347Q252 353 252 370Q252 382 251 388T245 399T230 405Q204 405 175 378Q157 360 145 337T126 298T117 280T98 278H81Q75 284 75 287Z"></path></g></g></g></svg></mjx-container></li>
<li>数学符号，符号<code>\hat{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.751ex" role="img" focusable="false" viewBox="0 -764 529 774"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -30)"><path data-c="5E" d="M112 560L249 694L257 686Q387 562 387 560L361 531Q359 532 303 581L250 627L195 580Q182 569 169 557T148 538L140 532Q138 530 125 546L112 560Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>数学符号，符号<code>\check{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.679ex" role="img" focusable="false" viewBox="0 -732 529 742"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -12)"><path data-c="2C7" d="M114 611L127 630L136 644Q138 644 193 612Q248 581 250 581L306 612Q361 644 363 644L385 611L318 562L249 513L114 611Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>数学符号，符号<code>\breve{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.787ex" role="img" focusable="false" viewBox="0 -780 529 790"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -14)"><path data-c="2D8" d="M250 515Q179 515 138 565T92 683V694H129V689Q129 688 129 683T130 675Q137 631 169 599T248 567Q304 567 337 608T370 689V694H407V683Q403 617 361 566T250 515Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>数学符号，符号<code>\tilde{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.615ex" role="img" focusable="false" viewBox="0 -704 529 714"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, 286)"><path data-c="7E" d="M179 251Q164 251 151 245T131 234T111 215L97 227L83 238Q83 239 95 253T121 283T142 304Q165 318 187 318T253 300T320 282Q335 282 348 288T368 299T388 318L402 306L416 295Q375 236 344 222Q330 215 313 215Q292 215 248 233T179 251Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>数学符号，符号<code>\bar{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.486ex" role="img" focusable="false" viewBox="0 -647 529 657"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -43)"><path data-c="AF" d="M69 544V590H430V544H69Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>矢量符号，符号<code>\vec{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.83ex" role="img" focusable="false" viewBox="0 -799 529 809"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -15)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>数学符号，符号<code>\acute{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.821ex" role="img" focusable="false" viewBox="0 -795 529 805"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -4)"><path data-c="B4" d="M349 699Q367 699 380 686T393 656Q393 651 392 647T387 637T380 627T367 616T351 602T330 585T303 563L232 505L217 519Q203 533 204 533Q204 534 229 567T282 636T313 678L316 681Q318 684 321 686T328 692T337 697T349 699Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>数学符号，符号<code>\grave{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.821ex" role="img" focusable="false" viewBox="0 -795 529 805"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -4)"><path data-c="60" d="M106 655Q106 671 119 685T150 699Q166 699 177 688Q190 671 222 629T275 561T295 533T282 519L267 505L196 563Q119 626 113 634Q106 643 106 655Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>数学符号，符号<code>\mathring{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.774ex" role="img" focusable="false" viewBox="0 -774 529 784"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -41)"><path data-c="2DA" d="M147 628Q147 669 179 692T244 715Q298 715 325 689T352 629Q352 592 323 567T249 542Q202 542 175 567T147 628ZM313 628Q313 660 300 669T259 678H253Q248 678 242 678T234 679Q217 679 207 674T192 659T188 644T187 629Q187 600 198 590Q210 579 250 579H265Q279 579 288 581T305 595T313 628Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>一阶导数符号，符号<code>\dot{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.654ex" role="img" focusable="false" viewBox="0 -721 529 731"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -48)"><path data-c="2D9" d="M190 609Q190 637 208 653T252 669Q275 667 292 652T309 609Q309 579 292 564T250 549Q225 549 208 564T190 609Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>二阶导数符号，符号<code>\ddot{a}</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.643ex" role="img" focusable="false" viewBox="0 -716 529 726"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(14.5, -53)"><path data-c="A8" d="M95 612Q95 633 112 651T153 669T193 652T210 612Q210 588 194 571T152 554L127 560Q95 577 95 612ZM289 611Q289 634 304 649T335 668Q336 668 340 668T346 669Q369 669 386 652T404 612T387 572T346 554Q323 554 306 570T289 611Z"></path></g></g></g></g></g></svg></mjx-container></li>
<li>上箭头，符号：<code>\uparrow</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.437ex" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="2.007ex" role="img" focusable="false" viewBox="0 -694 500 887"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2191" d="M27 414Q17 414 17 433Q17 437 17 439T17 444T19 447T20 450T22 452T26 453T30 454T36 456Q80 467 120 494T180 549Q227 607 238 678Q240 694 251 694Q259 694 261 684Q261 677 265 659T284 608T320 549Q340 525 363 507T405 479T440 463T467 455T479 451Q483 447 483 433Q483 413 472 413Q467 413 458 416Q342 448 277 545L270 555V-179Q262 -193 252 -193H250H248Q236 -193 230 -179V555L223 545Q192 499 146 467T70 424T27 414Z"></path></g></g></g></svg></mjx-container></li>
<li>上箭头，符号：<code>\Uparrow</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.382ex" height="2.009ex" role="img" focusable="false" viewBox="0 -694 611 888"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D1" d="M228 -179Q227 -180 226 -182T223 -186T221 -189T218 -192T214 -193T208 -194Q196 -194 189 -181L188 125V430L176 419Q122 369 59 338Q46 330 40 330Q38 330 31 337V350Q31 362 33 365T46 374Q60 381 77 390T128 426T190 484T247 567T292 677Q295 688 298 692Q302 694 305 694Q313 694 318 677Q334 619 363 568T420 485T481 427T532 391T564 374Q575 368 577 365T579 350V337Q572 330 570 330Q564 330 551 338Q487 370 435 419L423 430L422 125V-181Q409 -194 401 -194Q397 -194 394 -193T388 -189T385 -184T382 -180V-177V475L373 487Q331 541 305 602Q304 601 300 591T290 571T278 548T260 519T238 488L229 476L228 148V-179Z"></path></g></g></g></svg></mjx-container></li>
<li>下箭头，符号：<code>\downarrow</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="2.009ex" role="img" focusable="false" viewBox="0 -694 500 888"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2193" d="M473 86Q483 86 483 67Q483 63 483 61T483 56T481 53T480 50T478 48T474 47T470 46T464 44Q428 35 391 14T316 -55T264 -168Q264 -170 263 -173T262 -180T261 -184Q259 -194 251 -194Q242 -194 238 -176T221 -121T180 -49Q169 -34 155 -21T125 2T95 20T67 33T44 42T27 47L21 49Q17 53 17 67Q17 87 28 87Q33 87 42 84Q158 52 223 -45L230 -55V312Q230 391 230 482T229 591Q229 662 231 676T243 693Q244 694 251 694Q264 692 270 679V-55L277 -45Q307 1 353 33T430 76T473 86Z"></path></g></g></g></svg></mjx-container></li>
<li>下箭头，符号：<code>\Downarrow</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="1.382ex" height="2.009ex" role="img" focusable="false" viewBox="0 -694 611 888"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D3" d="M401 694Q412 694 422 681V375L423 70L435 81Q487 130 551 162Q564 170 570 170Q572 170 579 163V150Q579 138 577 135T564 126Q541 114 518 99T453 48T374 -46T318 -177Q313 -194 305 -194T293 -178T272 -119T225 -31Q158 70 46 126Q35 132 33 135T31 150V163Q38 170 40 170Q46 170 59 162Q122 131 176 81L188 70V375L189 681Q199 694 208 694Q219 694 228 680V352L229 25L238 12Q279 -42 305 -102Q344 -23 373 13L382 25V678Q387 692 401 694Z"></path></g></g></g></svg></mjx-container></li>
<li>左箭头，符号：<code>\leftarrow</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2190" d="M944 261T944 250T929 230H165Q167 228 182 216T211 189T244 152T277 96T303 25Q308 7 308 0Q308 -11 288 -11Q281 -11 278 -11T272 -7T267 2T263 21Q245 94 195 151T73 236Q58 242 55 247Q55 254 59 257T73 264Q121 283 158 314T215 375T247 434T264 480L267 497Q269 503 270 505T275 509T288 511Q308 511 308 500Q308 493 303 475Q293 438 278 406T246 352T215 315T185 287T165 270H929Q944 261 944 250Z"></path></g></g></g></svg></mjx-container></li>
<li>左箭头，符号：<code>\Leftarrow</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D0" d="M944 153Q944 140 929 133H318L328 123Q379 69 414 0Q419 -13 419 -17Q419 -24 399 -24Q388 -24 385 -23T377 -12Q332 77 253 144T72 237Q62 240 59 242T56 250T59 257T70 262T89 268T119 278T160 296Q303 366 377 512Q382 522 385 523T401 525Q419 524 419 515Q419 510 414 500Q379 431 328 377L318 367H929Q944 359 944 347Q944 336 930 328L602 327H274L264 319Q225 289 147 250Q148 249 165 241T210 217T264 181L274 173H930Q931 172 933 171T936 169T938 167T941 164T942 162T943 158T944 153Z"></path></g></g></g></svg></mjx-container></li>
<li>右箭头，符号：<code>\rightarrow</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.181ex" role="img" focusable="false" viewBox="0 -511 1000 522"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z"></path></g></g></g></svg></mjx-container></li>
<li>右箭头，符号：<code>\Rightarrow</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container></li>
<li>底端对齐的省略号，符号：<code>\ldots</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex" xmlns="http://www.w3.org/2000/svg" width="9.667ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 4272.7 860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(500, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(944.7, 0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(1444.7, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(1889.3, 0)"><path data-c="2026" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60ZM525 60Q525 84 542 102T585 120Q609 120 627 104T646 61Q646 36 629 18T586 0T543 17T525 60ZM972 60Q972 84 989 102T1032 120Q1056 120 1074 104T1093 61Q1093 36 1076 18T1033 0T990 17T972 60Z"></path></g><g data-mml-node="mo" transform="translate(3228, 0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3672.7, 0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></li>
<li>中线对齐的省略号，符号：<code>\cdots</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.651ex" xmlns="http://www.w3.org/2000/svg" width="17.73ex" height="2.538ex" role="img" focusable="false" viewBox="0 -833.9 7836.7 1121.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="msubsup"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(572, 363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(572, -287.9) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1197.8, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msubsup" transform="translate(2198, 0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(572, 363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mn" transform="translate(572, -287.9) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(3395.8, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(4396, 0)"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"></path></g><g data-mml-node="mo" transform="translate(5790.2, 0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="msubsup" transform="translate(6790.4, 0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(572, 363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(572, -247) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></g></svg></mjx-container></li>
<li>竖直对齐的省略号，符号：<code>\vdots</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.068ex" xmlns="http://www.w3.org/2000/svg" width="0.629ex" height="3.009ex" role="img" focusable="false" viewBox="0 -1300 278 1330"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="22EE" d="M78 30Q78 54 95 72T138 90Q162 90 180 74T199 31Q199 6 182 -12T139 -30T96 -13T78 30ZM78 440Q78 464 95 482T138 500Q162 500 180 484T199 441Q199 416 182 398T139 380T96 397T78 440ZM78 840Q78 864 95 882T138 900Q162 900 180 884T199 841Q199 816 182 798T139 780T96 797T78 840Z"></path></g></g></g></g></svg></mjx-container></li>
<li>斜对齐的省略号，符号：<code>\ddots</code>，如：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0.226ex" xmlns="http://www.w3.org/2000/svg" width="2.9ex" height="3.213ex" role="img" focusable="false" viewBox="0 -1520 1282 1420"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="22F1" d="M133 760Q133 784 150 802T193 820Q217 820 235 804T254 761Q254 736 237 718T194 700T151 717T133 760ZM580 460Q580 484 597 502T640 520Q664 520 682 504T701 461Q701 436 684 418T641 400T598 417T580 460ZM1027 160Q1027 184 1044 202T1087 220Q1111 220 1129 204T1148 161Q1148 136 1131 118T1088 100T1045 117T1027 160Z"></path></g></g></g></svg></mjx-container></li>
</ol>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th>字母</th>
<th>实现</th>
<th>字母</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td><code>A</code></td>
<td>α</td>
<td><code>\alhpa</code></td>
</tr>
<tr>
<td>B</td>
<td><code>B</code></td>
<td>β</td>
<td><code>\beta</code></td>
</tr>
<tr>
<td>Γ</td>
<td><code>\Gamma</code></td>
<td>γ</td>
<td><code>\gamma</code></td>
</tr>
<tr>
<td>Δ</td>
<td><code>\Delta</code></td>
<td>δ</td>
<td><code>\delta</code></td>
</tr>
<tr>
<td>E</td>
<td><code>E</code></td>
<td>ϵ</td>
<td><code>\epsilon</code></td>
</tr>
<tr>
<td>Z</td>
<td><code>Z</code></td>
<td>ζ</td>
<td><code>\zeta</code></td>
</tr>
<tr>
<td>H</td>
<td><code>H</code></td>
<td>η</td>
<td><code>\eta</code></td>
</tr>
<tr>
<td>Θ</td>
<td><code>\Theta</code></td>
<td>θ</td>
<td><code>\theta</code></td>
</tr>
<tr>
<td>I</td>
<td><code>I</code></td>
<td>ι</td>
<td><code>\iota</code></td>
</tr>
<tr>
<td>K</td>
<td><code>K</code></td>
<td>κ</td>
<td><code>\kappa</code></td>
</tr>
<tr>
<td>Λ</td>
<td><code>\Lambda</code></td>
<td>λ</td>
<td><code>\lambda</code></td>
</tr>
<tr>
<td>M</td>
<td><code>M</code></td>
<td>μ</td>
<td><code>\mu</code></td>
</tr>
<tr>
<td>N</td>
<td><code>N</code></td>
<td>ν</td>
<td><code>\nu</code></td>
</tr>
<tr>
<td>Ξ</td>
<td><code>\Xi</code></td>
<td>ξ</td>
<td><code>\xi</code></td>
</tr>
<tr>
<td>O</td>
<td><code>O</code></td>
<td>ο</td>
<td><code>\omicron</code></td>
</tr>
<tr>
<td>Π</td>
<td><code>\Pi</code></td>
<td>π</td>
<td><code>\pi</code></td>
</tr>
<tr>
<td>P</td>
<td><code>P</code></td>
<td>ρ</td>
<td><code>\rho</code></td>
</tr>
<tr>
<td>Σ</td>
<td><code>\Sigma</code></td>
<td>σ</td>
<td><code>\sigma</code></td>
</tr>
<tr>
<td>T</td>
<td><code>T</code></td>
<td>τ</td>
<td><code>\tau</code></td>
</tr>
<tr>
<td>Υ</td>
<td><code>\Upsilon</code></td>
<td>υ</td>
<td><code>\upsilon</code></td>
</tr>
<tr>
<td>Φ</td>
<td><code>\Phi</code></td>
<td>ϕ</td>
<td><code>\phi</code></td>
</tr>
<tr>
<td>X</td>
<td><code>X</code></td>
<td>χ</td>
<td><code>\chi</code></td>
</tr>
<tr>
<td>Ψ</td>
<td><code>\Psi</code></td>
<td>ψ</td>
<td><code>\psi</code></td>
</tr>
<tr>
<td>Ω</td>
<td><code>\v</code></td>
<td>ω</td>
<td><code>\omega</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术文章</category>
        <category>技术字典</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2020/07/29/interview/Design_Pattern/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="设计模式是什么"><a href="#设计模式是什么" class="headerlink" title="设计模式是什么"></a>设计模式是什么</h2><p>设计模式是一个通过定义、使用、测试去解决特定问题的方法，是针对软件设计中在给定条件下会重复性发生的问题而提出的一种通用性的可重用解决方案，设计模式不是可以直接转化为代码的完整设计，它是用于描述在不同情况下解决问题的通用方案。</p>
<h2 id="设计模式的作用"><a href="#设计模式的作用" class="headerlink" title="设计模式的作用"></a>设计模式的作用</h2><p>设计模式通过提供经过验证的行之有效的开发范式加快开发过程，预防重大的隐患问题，提高代码可读性。</p>
<a id="more"></a>


<h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p><strong>这里主要讨论GoF所提出的23种设计模式，可将其分为三种类型：</strong></p>
<ol>
<li><p>创造型设计模式</p>
</li>
<li><p>结构型设计模式</p>
</li>
<li><p>行为型设计模式</p>
<h3 id="创造型设计模式"><a href="#创造型设计模式" class="headerlink" title="创造型设计模式"></a>创造型设计模式</h3><p>注重完成对象的实例化，相比于直接实例化对象，根据实际情况选择合适的设计模式完成对象的实例化，可以为复杂的业务场景带来更高的灵活性。<br>创造型设计模式主要包括以下几种：</p>
</li>
<li><p>抽象工厂设计模式</p>
</li>
<li><p>生成器设计模式</p>
</li>
<li><p>工厂方法设计模式</p>
</li>
<li><p>原型设计模式</p>
</li>
<li><p>单例设计模式</p>
<h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><p>结构型设计模式用于指导我们完成对代码的结构划分，如此，代码结构会更加清晰，更易理解，也提高了软件的可维护性。<br>结构型设计模式主要包括以下几种：</p>
</li>
<li><p>适配器设计模式</p>
</li>
<li><p>桥接设计模式</p>
</li>
<li><p>组合设计模式</p>
</li>
<li><p>装饰设计模式</p>
</li>
<li><p>门面设计模式</p>
</li>
<li><p>享元设计模式</p>
</li>
<li><p>代理设计模式</p>
<h3 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h3><p>行为型设计模式主要用于定义对象之间的通信与流程控制，主要的设计模式都非常注重优化对象之间的数据交互方式。<br>行为型设计模式主要包括以下几种：</p>
</li>
<li><p>职责链设计模式</p>
</li>
<li><p>命令设计模式</p>
</li>
<li><p>解释器设计模式</p>
</li>
<li><p>迭代器设计模式</p>
</li>
<li><p>中介者设计模式</p>
</li>
<li><p>备忘录设计模式</p>
</li>
<li><p>观察者设计模式</p>
</li>
<li><p>策略设计模式</p>
</li>
<li><p>状态设计模式</p>
</li>
<li><p>模板方法设计模式</p>
</li>
<li><p>访问者设计模式</p>
<h2 id="如何学习设计模式"><a href="#如何学习设计模式" class="headerlink" title="如何学习设计模式"></a>如何学习设计模式</h2></li>
</ol>
<ul>
<li>模式名称是什么？</li>
<li>模式类型是什么？是创造型，结构型，还是行为型？</li>
<li>模式的目的是什么？（作用是什么？解决了什么问题？）</li>
<li>模式的别名是什么？</li>
<li>什么情况下使用该模式？</li>
<li>该模式的基本示例</li>
<li>该模式的UML图是什么样的？是类图还是交互图？</li>
<li>都有那些对象在模式中参与活动？列出设计模式中使用的类和对象，并说明他们各自的角色</li>
<li>模式中的类和对象是怎么进行交互的？</li>
<li>通过应用设计模式能获取什么好处，有哪些坏处？如何权衡？</li>
<li>如何实现该模式</li>
<li>与该模式相近的设计模式是什么？这几种相近的模式有哪些异同点？<h2 id="正确看待设计模式"><a href="#正确看待设计模式" class="headerlink" title="正确看待设计模式"></a>正确看待设计模式</h2>恰当使用设计模式能够提高代码的复用性，但是由于复用性往往会引入封装与间接调用，这些会降低系统性能，增加代码复杂程度。因此，除非设计模式能够帮助我们完成代码的实现或者后续的维护工作，否则没有必要去引入设计模式。<br>学习设计模式的关键并不在于学习设计模式本身，而是在于识别应用场景与潜在的风险，并将设计模式用之有道，这般，设计模式才能算作得心应手的工具。<br>在没有必要的情况大可不必去使用设计模式，因为设计模式有可能会牺牲代码的简洁性，而且滥用设计模式多会引入新的问题却没有解决原来的问题。</li>
</ul>
<p><strong>保持代码的整洁，模块化和可读性，同时不要让各类之间过度耦合。</strong></p>
<h2 id="创造型设计模式-1"><a href="#创造型设计模式-1" class="headerlink" title="创造型设计模式"></a>创造型设计模式</h2><p>创造型设计模式主要关注的是类的实例化，也就是说体现的是对象的创建方法，利用这些模式，我们可以在适当的情况下以适当的形式创建对象，创造型设计模式通过控制对象的创建来解决设计中的问题。<br>创造型设计模式主要包含以下子类别：</p>
<ol>
<li>对象创造型设计模式：</li>
</ol>
<p>主要完成对象创建，并将对象中部分内容放到其他对象中创建。</p>
<ol start="2">
<li>类创造型设计模式：</li>
</ol>
<p>主要完成类的实例化，并将类中的部分对象放到子类中创建，此类模式在实例化过程中高效地利用了继承机制<br>创造型设计模式主要包含以下5种具体的设计模式：</p>
<ol>
<li>抽象工厂设计模式</li>
</ol>
<p>提供一个用于创建相关对象或相互依赖对象的接口，无需指定对象的具体类</p>
<ol start="2">
<li>生成器设计模式</li>
</ol>
<p>将复杂对象的构建与其表示相互分离，使得同样的构建过程可以创建不同的表示</p>
<ol start="3">
<li>工厂方法设计模式</li>
</ol>
<p>允许在子类中实现本类的实例化类</p>
<ol start="4">
<li>原型设计模式</li>
</ol>
<p>使用一个原型实例来指定创建对象的种类，然后通过拷贝这些原型实现新对象的创建</p>
<ol start="5">
<li>单例模式</li>
</ol>
<p>确保某个类在系统中仅有一个实例，并提供一个访问它的全局访问点</p>
<table>
<thead>
<tr>
<th align="center">对象创造型设计模式</th>
<th align="center">类创造型设计模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">抽象工厂设计模式</td>
<td align="center">工厂方法设计模式</td>
</tr>
<tr>
<td align="center">生成器设计模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">原型设计模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">单例设计模式</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="工厂方法设计模式"><a href="#工厂方法设计模式" class="headerlink" title="工厂方法设计模式"></a>工厂方法设计模式</h3><p>工厂方法的作用是创建对象，用来从一组实现特定逻辑的类中实例化某个对象。</p>
<h4 id="模式中包括的类"><a href="#模式中包括的类" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li><p>产品类（Product）中定义了工厂方法创建的对象接口。</p>
</li>
<li><p>具体产品类（ Concrete Product）实现产品类接口。</p>
</li>
<li><p>工厂类（ Creator，因为由它来创建产品类，所以叫作工厂类）声明工厂方法，返回一个产品类对象。可用于调用创建产品类对象的生成方法。</p>
</li>
<li><p>具体工厂类（ Concrete Creator）重写用于创建具体产品类对象的方法。</p>
<h4 id="UML图"><a href="#UML图" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588679646408-22276075-76c2-42b2-8b20-84e3401fdbf7.png#align=left&display=inline&height=231&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=1228&size=220064&status=done&style=none&width=746" alt="image.png"></p>
<h4 id="功能及应用场景"><a href="#功能及应用场景" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li>
<li><p>当需要创建一个类，而在编程时不能确定这个类的类型时（需要运行时确定）。</p>
</li>
<li><p>当一个类希望由其子类来指定所创建对象的具体类型时。</p>
</li>
<li><p>当我们想要定位被创建类，并获取相关信息时。</p>
</li>
</ul>
<h3 id="抽象工厂设计模式"><a href="#抽象工厂设计模式" class="headerlink" title="抽象工厂设计模式"></a>抽象工厂设计模式</h3><p>抽象工厂模式相比于工厂方法模式的抽象层次更高。这意味着抽象工厂返回的是一组类的工厂。与工厂方法模式类似（返回多个子类中的一个），此方法会返回一个工厂，而这个工厂会返回多个子类中的一个。简单来说，抽象工厂是一个工厂对象，该对象又会返回若干工厂中的一个。<br>工厂模式是创造型模式的典型示例。抽象工厂设计模式是工厂方法模式的扩展，从而使我们无须担心所创建对象的实际类就能够创建对象。抽象工厂模式扩展了工厂方法模式，允许创建更多类型的对象。</p>
<h4 id="模式中包括的类-1"><a href="#模式中包括的类-1" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li>抽象工厂（AbstractFactory）声明一个用于完成抽象产品对象创建操作的接口。</li>
<li>具体工厂（ConcreteFactory）实现创建具体产品对象的操作。</li>
<li>抽象产品（AbstractProduct）声明一个用于一类产品对象的接口。</li>
<li>具体产品（ConcreteProduct）定义由相应的具体工厂来创建的产品对象。</li>
<li>客户端（Client）使用由抽象工厂和抽象产品类声明的唯一接口。</li>
</ul>
<h4 id="UML图-1"><a href="#UML图-1" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588681690229-615d93e2-9429-42cc-812e-fa8cb7eb49a4.png#align=left&display=inline&height=307&margin=%5Bobject%20Object%5D&name=image.png&originHeight=565&originWidth=1374&size=368470&status=done&style=none&width=746" alt="image.png"></p>
<h4 id="功能及应用场景-1"><a href="#功能及应用场景-1" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>抽象工厂模式的主要优点之一是它屏蔽了这些具体类的创建方法。实际应用的类名称不需要再让客户端（将客户端与具体类解耦）知道。由于具体类是屏蔽的，因此我们可以在不同的工厂（实现方法）之间进行切换。</p>
<h3 id="生成器设计模式"><a href="#生成器设计模式" class="headerlink" title="生成器设计模式"></a>生成器设计模式</h3><p>生成器模式，能够从简单的对象一步一步生成复杂的对象。生成器模式是一种用来逐步构建复杂对象并在最后一步返回对象的创造型模式。<br>构造一个对象的过程是通过泛型实现的，以便它能够用于对同一对象创建不同的表示形式。</p>
<h4 id="模式中包括的类-2"><a href="#模式中包括的类-2" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li><p>生成器类（ Builder）提供一个接口用于创建产品的各个组成部件。具体生成器（Concrete Builder）提供此接的实现。</p>
</li>
<li><p>具体生成器（ ConcreteBuilder）会跟踪其所创建对象的表现形式，并在创建对象的同时提供一个接口获取产品（Product）。</p>
</li>
<li><p>导演类（ Director）通过生成器提供的接口构造对象。产品类用于表示被构造的复杂对象。这包括对我们构建的所有类进行定义。</p>
<h4 id="UML图-2"><a href="#UML图-2" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588687137859-38493900-8c93-43ef-bbe7-c67c14e9ba75.png#align=left&display=inline&height=286&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=951&size=131071&status=done&style=none&width=746" alt="image.png"></p>
<h4 id="功能及应用场景-2"><a href="#功能及应用场景-2" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>生成器模式隐藏了产品构建过程中的内部细节。各个生成器之间都是相互独立的。这提高了代码的模块化，并使其他的生成器更方便地创建对象。因为每个生成器都能够逐步创建对象，这让我们能够很好地对最终产品进行掌控。</p>
<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>在应用程序的整个生命周期中，对象只有一个实例的时候，就会使用单例设计模式。单例类总是在第一次被访问时完成实例化，直至应用程序退出之前，都只会使用同一个实例。单一实例创建策略：我们通过限制构造函数（通过设置其为私有）从而限制单例类的实例化。之后在定义类时包含一个该类的静态私有对象，以便创建单例类的实例。<br>在单例模式中，最棘手的部分是对单一实例的实现和管理。<br>在单例模式的定义过程中，有两点需要注意的地方：</p>
</li>
<li><p>该类仅允许存在一个实例。</p>
</li>
<li><p>需要为该单一实例提供一个全局访问点。</p>
</li>
</ul>
<p>单例模式中的主动实例化和被动实例化（饿汉、懒汉）<br>线程安全的单例：双重同步锁、静态变量、枚举</p>
<h4 id="模式中包括的类-3"><a href="#模式中包括的类-3" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li>单例类<h4 id="UML图-3"><a href="#UML图-3" class="headerlink" title="UML图"></a>UML图</h4><img src="/images/interview/1588689300339-c33a3d0d-7544-4754-8695-b08fc843183d.png#align=left&display=inline&height=208&margin=%5Bobject%20Object%5D&name=image.png&originHeight=208&originWidth=334&size=51899&status=done&style=none&width=334" alt="image.png"><h4 id="功能及应用场景-3"><a href="#功能及应用场景-3" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4>在应用程序的整个生命周期中，对象只有一个实例的时候，就会使用单例设计模式。</li>
</ul>
<h3 id="原型设计模式"><a href="#原型设计模式" class="headerlink" title="原型设计模式"></a>原型设计模式</h3><p>相比于以往创建一个复杂对象总是费时费力，原型模式只需要复制现有的相似对象，并根据需要做适当修改。原型意味着使用克隆方法。克隆方法是一种复制对象的操作。克隆出的对象副本被初始化为调用克隆方法时原始对象的当前状态。这意味着对象的克隆避免了创建新对象。如果创建一个新对象的开销很大，而且有可能引起资源紧张时，我们就克隆对象。</p>
<ul>
<li>浅层复制：当原始对象变化时，新对象也跟着改变。这主要是因为浅层复制并没有实际复制新的对象，而只是对原有对象的一个引用。</li>
<li>深层复制：当原始对象变化时，新对象不受影响，因为原始对象所包含的所有参数、对象和引用在复制新对象的过程中都建立了新的拷贝。</li>
</ul>
<p>使用克隆方法来复制对象时，具体是使用浅层复制还是深层复制是由业务需求来决定的。在使用原型模式时，使用克隆方法来复制对象仅仅是一个设计上的决策。克隆方法对于原型模式来说并不是强制性的最佳选择。</p>
<h4 id="模式中包括的类-4"><a href="#模式中包括的类-4" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li>客户端（Client）：通过调用原型类的克隆操作创建一个新对象。</li>
<li>原型类（ Prototype）：声明一个接口用于克隆自己。</li>
<li>具体原型类（ Concrete Prototype）：实现克隆自己的操作。</li>
</ul>
<h4 id="UML图-4"><a href="#UML图-4" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588746617916-a21ed08c-42df-40c0-bc79-6701209c2f55.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=951&size=191697&status=done&style=none&width=951" alt="image.png"></p>
<h4 id="功能及应用场景-4"><a href="#功能及应用场景-4" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ol>
<li>当一个系统应该独立于其产品的创建、组合和表示。</li>
<li>当需要实例化的类是在运行时定义的，例如动态加载，或避免建立一个平行于产品类继承层次的工厂类继承层次时。</li>
<li>当一个类的实例仅可以拥有若干不同的状态组合中的一个时。使用原型模式建立相应数量的原型和克隆方法，会比每次都手动实例化类并配置相应状态更加方便。</li>
</ol>
<p><strong>主要难点：</strong></p>
<ul>
<li>每个原型类的子类都必须实现克隆操作。这实现起来可能有难度。例如，当类已经存在的时候添加克隆方法可能比较困难。</li>
<li>对象内部包含其他不支持克隆的对象或具有循环引用的对象时，实现克隆方法会比较困难。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>原型模式意味着使用克隆方法。克隆方法是一种复制对象的操作。相比于耗时的复制对象创建过程，原型模式仅复制类似的现有对象，再根据需要对复制出的副本进行修改。</li>
<li>客户端可以在运行时添加或移除原型对象。</li>
<li>通过各种参数来定义新对象：高度动态的系统允许我们通过使用对象组合来定义新的特征，例如为对象变量指定相应的参数值，而不是重新定义一个类。我们通过实例化现有类可以有效地定义新类型的对象，并为客户端对象注册原型实例。客户端可以通过向原型类委派某个责任而使其具有新的特征。这种设计允许用户无须大量编程就能轻松定义新的类。事实上，克隆一个原型本质上是类似于类的实例化的。但原型模式能够大大降低系统所需的类的数量。</li>
</ul>
<p><strong>副作用：</strong></p>
<ul>
<li>使用原型模式，我们可以根据需要通过对象克隆来实现运行时对象的添加和删除。我们可以根据程序运行情况在运行时修改类的内部数据表示形式。</li>
<li>在Java中实现原型模式的一大困难是如果这些类已经存在，我们未必能够通过添加所需要的克隆方法或深层克隆方法对类进行修改。此外，那些与其他类具有循环引用关系的类并不能真正实现克隆。</li>
<li>需要在这些类中具有足够的数据访问权限或方法，以便在克隆完成后对相应的数据进行修改。这可能需要在这些原型类中添加相应的数据访问方法，以便我们对类完成克隆之后可以修改数据。</li>
</ul>
<h2 id="结构型设计模式-1"><a href="#结构型设计模式-1" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p>结构型模式主要描述如何将对象和类组合在一起以组成更复杂的结构。在软件工程中结构型模式是用于帮助设计人员通过简单的方式来识别和实现对象之间关系的设计模式。结构型模式会以组的形式组织程序。这种划分形式使代码更加清晰，维护更加简便。结构型模式用于代码和对象的结构组织。<br>结构型模式会以组的形式组织程序。这种划分形式使代码更加清晰，维护更加简便。<br><strong>结构型模式又分为以下子类别：</strong></p>
<ol>
<li>对象结构型模式：用于对象之间相互关联与组织，以便形成更大、更复杂的结构。</li>
<li>类结构型模式：用于实现基于继承的代码抽象，并且会介绍如何通过该模式提供更有用的程序接口。</li>
</ol>
<p><strong>具体包括：</strong></p>
<table>
<thead>
<tr>
<th align="center">对象结构型模式</th>
<th align="center">类结构型模式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">桥接模式</td>
<td align="center">类适配器模式</td>
</tr>
<tr>
<td align="center">组合模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">装饰模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">门面模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">享元模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">对象适配器模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">代理模式</td>
<td align="center"></td>
</tr>
</tbody></table>
<ol>
<li>组合模式：它能够为客户端处理各种复杂和灵活的树状结构。这些树结构可以由各种不同类型的容器和叶节点组成，其深度或组合形式能够在运行时调整或确定。</li>
<li>装饰模式：允许我们通过附加新的功能或修改现有功能，在运行时动态地修改对象。</li>
<li>门面模式：允许我们为客户端创建一个统一的接口以访问不同子系统的不同接口，从而简化客户端。</li>
<li>享元模式：客户端调用类时会在运行时创建大量对象，该模式会重新设计类以优化内存开销。</li>
<li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。这种模式的目的是一个对象不适合或者不能直接引用另一个对象，简化客户端并实现对象访问，同时避免任何副作用。</li>
<li>适配器模式：允许我们为一个已有的类提供一个新的接口，并在客户端请求不同接口时实现类的重用。</li>
<li>桥接模式：允许我们将类与其接口相互解耦。允许类及其接口随着时间相互独立变化，增加类重用的次数，提高后续可扩展性。它也允许运行时对接口的不同实现方式动态切换，使代码更加灵活。<h3 id="适配器设计模式"><a href="#适配器设计模式" class="headerlink" title="适配器设计模式"></a>适配器设计模式</h3>软件适配器的工作原理也和插座适配器完全一样。我们也经常需要在程序中使用到不同的类或模块。假设有一段代码写得很烂，如果我们直接将这些代码集成到程序中，会将现有的代码搞乱。但是我们又不得不调用这段代码，因为我们需要实现相关的功能，而从头写起会耽误很多宝贵的时间。这时的最佳实践就是编写适配器，并将所需要的代码包装进去。这样我们就能够使用自定义的接口，从而降低对外部代码的依赖。<br>适配器模式会将现有接口转换为新的接口，已实现对应用程序中不相关的类的兼容性和可重用性的目标。适配器模式也被称为包装模式。适配器模式能够帮助那些因为接口不兼容而无法一起工作的类，以便它们能够一同工作。<br>适配器模式也负责将数据转换成适当的形式。当客户端在接口中指定了其对数据格式的要求时，我们通常可以创建新的类以实现现有类的接口和子类。这种实现方式也会通过创建类适配器，实现对客户端调用命和现有类中被调用方法之间接口的转换。<h4 id="模式中包括的类-5"><a href="#模式中包括的类-5" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
</ol>
<ul>
<li>客户端（Client）调用目标类的类或程序。</li>
<li>目标类（Target）客户端想要使用的接口。</li>
<li>适配对象类（Adapetee）需要进行适配的类或对象。</li>
<li>适配器类（ Adapter）按照目标类接口的要求对适配对象接口实现接口形式的适配转换。</li>
<li>request方法：客户端想要执行的操作。</li>
<li>specificRequest方法：适配对象中能够完成 request方法功能的实现。<h4 id="UML图-5"><a href="#UML图-5" class="headerlink" title="UML图"></a>UML图</h4></li>
</ul>
<p><strong><img src="/images/interview/1588761010089-ced9b3a9-3232-4729-943a-67c133909d7c.png#align=left&display=inline&height=395&margin=%5Bobject%20Object%5D&name=image.png&originHeight=395&originWidth=1149&size=182309&status=done&style=none&width=1149" alt="image.png"></strong></p>
<h4 id="功能及应用场景-5"><a href="#功能及应用场景-5" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>在具体实践上，有两种实际应用适配器模式的方法：</p>
<ol>
<li>使用继承［类适配器］</li>
<li>使用关联［对象适配器］</li>
</ol>
<p><strong>应用场景：</strong></p>
<ul>
<li>我们想要使用现有的类，但它的接口不符合我们的需要。</li>
<li>我们想要创建一个可重用的类，能够与一些无关的类或不可预见的类进行协作，同时这个类无须具有兼容的接口。</li>
<li>（仅适用于对象适配器）我们需要使用多个已经存在的子类，而我们为每一个子类都做接口适配显然是不切实际的。使用对象适配器可以直接适配其父类的接口。</li>
</ul>
<h3 id="桥接设计模式"><a href="#桥接设计模式" class="headerlink" title="桥接设计模式"></a>桥接设计模式</h3><p>桥接模式是结构型模式中的另一个典型模式。桥接模式用于将类的接口与接口的实现相互解耦。这样做提高了系统的灵活性使得接口和实现两者均可独立变化。<br>举一个例子，让我们想一下家用电器及其开关。例如，风扇的开关。开关是电器的控制接口，而一旦闭合开关，实际让风扇运转的是风扇电机。<br>所以，在这个示例中，开关和风扇之间是彼此独立的。如果我们将开关接到电灯泡的供电线路上，那么我们还可以选用其他开关来控制风扇。</p>
<h4 id="模式中包括的类-6"><a href="#模式中包括的类-6" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li>抽象化对象（Abstraction）桥接设计模式的核心，并定义了关键症结所在。包含对实现化对象的引用。</li>
<li>扩充抽象化对象（RefinedAbstraction）扩展抽象化对象，并将抽象化对象细化到新的层次。对实现化对象隐藏细节元素。</li>
<li>实现化对象（Implementor）该接口比抽象化对象的层次更高。只对基本操作进行定义。</li>
<li>具体实现化对象（Concretelmplementor）通过提供具体实现来执行实现化对象的具体功能。<h4 id="UML图-6"><a href="#UML图-6" class="headerlink" title="UML图"></a>UML图</h4><img src="/images/interview/1588760917772-e4e10a15-0c43-456e-88f2-279fdd3e2d12.png#align=left&display=inline&height=411&margin=%5Bobject%20Object%5D&name=image.png&originHeight=411&originWidth=1027&size=184618&status=done&style=none&width=1027" alt="image.png"><h4 id="功能及应用场景-6"><a href="#功能及应用场景-6" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4>桥接模式主要适用于系统的多个维度上都经常发生变化的情况。桥接模式能够将不同的抽象维度进行衔接。通过桥接模式，抽象化对象和实现化对象不会在编译时进行绑定，而能够在各自的类被调用时独立扩展。<br>当你经常需要在运行时在多个实现之间进行切换时，桥接模式也非常有用。</li>
</ul>
<h3 id="组合设计模式"><a href="#组合设计模式" class="headerlink" title="组合设计模式"></a>组合设计模式</h3><p>在大部分系统开发过程中，程序员都会遇到某个组件既可以是独立的个体对象，也能够作为对象集合的情况。组合模式就用于此类情况的设计。简单来说，组合模式是一组对象的集合，而这组对象中的每一个对象本身也是一个组合模式构成的对象，或者只是一个原始对象。<br>组合模式中存在着一个树形结构，并且在该结构中的分支节点和叶节点上都能够执行相同的操作。树形结构中每一个分支节点都包含子节点的类（能继承出叶节点和分支节点），这样的分支节点本身就是一个组合模式构成的节点。树形结构中的叶子节点仅是一个原始对象，其没有子节点（不能继承出叶节点和分支节点）。组合模式的子类（下一级节点）可以是叶子节点或其他组合模式。</p>
<h4 id="模式中包括的类-7"><a href="#模式中包括的类-7" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li><p>组件对象：（Component，结构）</p>
<ul>
<li>组件对象在整个继承结构的最顶端。它是对组合模式的抽象。</li>
<li>它声明了组合模式中的对象接口。</li>
<li>可以选择性地定义一个接口，以便对递归结构中组件的父类进行访问，并在需要的时候实现该接口。</li>
</ul>
</li>
<li><p>叶子节点：（Leaf，原始对象）</p>
<ul>
<li>树形结构的末端且不会再有子节点。</li>
<li>定义了组合结构中单个对象的行为。</li>
</ul>
</li>
<li><p>分支节点类：（Composite，组）</p>
<ul>
<li>包含了子组件并为它们定义行为。</li>
<li>实现子节点的相关操作。<h4 id="UML图-7"><a href="#UML图-7" class="headerlink" title="UML图"></a>UML图</h4><img src="/images/interview/1588762859910-c08b6230-8358-42e8-aa48-5835af2d2940.png#align=left&display=inline&height=395&margin=%5Bobject%20Object%5D&name=image.png&originHeight=395&originWidth=1149&size=182309&status=done&style=none&width=1149" alt="image.png"><h4 id="功能及应用场景-7"><a href="#功能及应用场景-7" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li>
</ul>
</li>
<li><p>当对象的集合需要采用与单个对象相同的处理方式时。</p>
</li>
<li><p>操纵单个对象的方式与操纵一组对象的方式类似时。</p>
</li>
<li><p>注意存在能够组合的递归结构或树形结构。</p>
</li>
<li><p>客户端能够通过组件对象访问整个继承结构，而它们却不会知道自己所处理的是叶子节点还是分支节点。</p>
</li>
</ul>
<p>组合模式的目的是能够使独立对象（单个分支节点或叶子节点）和对象集合（子树）都能够以同样的方式组织起来。组合模式中所有的对象都来自于其本身（成为一种嵌套结构）。组合模式允许我们使用递归的方式将类似的对象组合成一种树形结构，来实现复杂结构对象的构建。</p>
<h3 id="装饰者设计模式"><a href="#装饰者设计模式" class="headerlink" title="装饰者设计模式"></a>装饰者设计模式</h3><p>装饰设计模式用来在运行时扩展或修改一个实例的功能。一般来说，继承可以扩展类的功能（用于类的所有实例）。但与继承不同的是，通过装饰模式，我们可以选择一个类的某个对象，并对其进行修改，而不会影响这个类中其他的实例。继承会直接为类增加功能，而装饰模式则会通过将对象与其他对象进行包装的方式将功能添加到类。</p>
<h4 id="模式中包括的类-8"><a href="#模式中包括的类-8" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li>抽象组件（Component）给出一个抽象接口，用于能够动态添加功能的对象。</li>
<li>具体组件（Concrete Component）定义一个实现组件接口的对象。这是实际需要加以装饰的对象，但其对装饰的过程一无所知。<h4 id="UML图-8"><a href="#UML图-8" class="headerlink" title="UML图"></a>UML图</h4><img src="/images/interview/1588776261625-d6b2f2b2-85c7-4752-ba71-ac38f9ca639c.png#align=left&display=inline&height=529&margin=%5Bobject%20Object%5D&name=image.png&originHeight=628&originWidth=886&size=170487&status=done&style=none&width=746" alt="image.png"><h4 id="功能及应用场景-8"><a href="#功能及应用场景-8" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4>装饰设计模式用来在运行时扩展或修改一个实例的功能。一般来说，继承可以扩展类的功能（用于类的所有实例）。但与继承不同的是，通过装饰模式，我们可以选择一个类的某个对象，并对其进行修改，而不会影响这个类中其他的实例。继承会直接为类增加功能，而装饰模式则会通过将对象与其他对象进行包装的方式将功能添加到类。<h3 id="门面设计模式"><a href="#门面设计模式" class="headerlink" title="门面设计模式"></a>门面设计模式</h3>许多业务流程都会涉及复杂的业务类操作。由于流程很复杂，所以其涉及了多个业务对象，这往往会导致各个类之间的紧密耦合，从而降低系统的灵活性和设计的清晰度。底层业务组件间的复杂关系会使客户端的代码编写变得很困难。<br>门面模式简化了到复杂系统的外部接口。为此它会对所有的类进行整合，并构建一个复杂系统的子系统。<br>门面模式能够将用户与系统内部复杂的细节相互屏蔽，并只为用户提供简化后的更容易使用的外部接口。同时它也将系统内部代码与接口子系统的代码相互解耦，以便修改和升级系统代码。<br>相比于其他设计模式，门面模式更注重实现代码的解耦。它所强调的是代码设计中很重要的一点，即代码抽象。通过提供一个简单的接口并隐藏其后的复杂性，从而实现抽象。<br>在这种方式下，代码的实现完全交由门面层处理。客户端只会与一个接口交互，同时也只有和这个接口交互的权限。这样就能隐藏全部系统的复杂性。总而言之，门面模式通过提供一个简单的接口为客户端简化了与复杂系统的交互。<br>从另一方面看，门面模式也保证了能够在不修改客户端代码的情况下对具体实现方法进行修改。</li>
</ul>
<h4 id="模式中包括的类-9"><a href="#模式中包括的类-9" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li>门面层（ Facade）：它知道子系统内各个类的具体功能，并将客户端请求转换成对系统内部对象的调用。</li>
<li>系统内部类（ ComplicatedClass）：这些类会实现系统功能，处理门面层对象分配的各项工作任务。它们本身并不知道门面层的存在，也没有对其进行任何的引用。</li>
</ul>
<h4 id="UML图-9"><a href="#UML图-9" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588776769193-d3a6ae4a-83d5-4fbf-b187-339039a22f25.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=996&size=196580&status=done&style=none&width=996" alt="image.png"></p>
<h4 id="功能及应用场景-9"><a href="#功能及应用场景-9" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul>
<li>想要为一个复杂的子系统提供一个简单接口。子系统随着其自身的发展往往变得越来越复杂。它们应用的大多数的设计模式会导致类的数量更多、代码段更小。这使得该子系统可重用更好，也更容易进行自定义。而对于某些无法自定义的客户端来说，它也变得难以使用。门面层可以提供对大多数客户端来说足够好的简化的调用接口。只有极少数高度定制化的客户端需要直接调用门面层之后的底层代码。</li>
<li>在客户端和抽象层的实现类之间存在大量的依赖关系。引入一个门面层能够将客户端的子系统与其他子系统进行解耦，从而促进子系统的独立性和可移植性。</li>
<li>你想要为你的子系统增加层级。使用一个门面层对每个子系统级别分别定义一个入口点。如果子系统之间存在依赖关系，那么你可以通过令这些子系统之间的交互全部需要经由门面层来简化彼此的依赖关系。<h3 id="代理设计模式"><a href="#代理设计模式" class="headerlink" title="代理设计模式"></a>代理设计模式</h3>根据目的不同，有各种不同类型的代理。例如，有保护性代理，控制对某个对象的访问权限；有虚拟代理，处理开销过大而难以创建的对象，并通过远程访问控制来访问远程对象。<h4 id="模式中包括的类-10"><a href="#模式中包括的类-10" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
</ul>
<h4 id="UML图-10"><a href="#UML图-10" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588778531181-f78a0447-263d-40cf-bbfd-dfc565997dcd.png#align=left&display=inline&height=624&margin=%5Bobject%20Object%5D&name=image.png&originHeight=624&originWidth=934&size=174488&status=done&style=none&width=934" alt="image.png"></p>
<h4 id="功能及应用场景-10"><a href="#功能及应用场景-10" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>代理模式主要用于当我们需要用一个简单对象来表示一个复杂对象的情形。如果创建对象的开销很大，那么可以推迟其创建，并使用一个简单对象来代理其功能直到必须立即创建的时候。这个简单对象就可以称为复杂对象的代理。</p>
<h3 id="享元设计模式"><a href="#享元设计模式" class="headerlink" title="享元设计模式"></a>享元设计模式</h3><p>享元模式能够减少用于创建和操作大量相似的细碎对象所花费的成本。享元模式主要用在需要创建大量类似性质的对象时。大量的对象会消耗高内存，享元模式给出了一个解决方案，即通过共享对象来减少内存负载它的具体实现则是根据对象属性将对象分成两种类型：内蕴状态和外蕴状态。<br>共享是享元模式的关键。</p>
<h4 id="模式中包括的类-11"><a href="#模式中包括的类-11" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li><p>抽象享元角色（ Flyweight）声明一个为具体享元角色规定了必须实现的接口，而外蕴状态就是以参数的形式通过此方法传入。</p>
</li>
<li><p>具体享元角色（ Concrete Flyweight）实现享元模式接口，并存储内蕴状态。具体享元角色必须是共享的。具体享元角色必须保持其内蕴状态不变，并且能够操纵外蕴状态。</p>
</li>
<li><p>享元工厂角色（FlyweightFactory）负责创建和管理享元角色。此外，该工厂确保了享元角色的共享。工厂维护了不同的享元对象池，并负责在对象创建完成时从对象池返回对象，以及向对象池添加对象。</p>
</li>
<li><p>客户端（Client）维护对所有享元对象的引用，而且需要存储和计算对应的外蕴状态。</p>
<h4 id="UML图-11"><a href="#UML图-11" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588820461937-2a508c21-4203-4629-bcc1-ca0750f9fe84.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=515&originWidth=1032&size=209323&status=done&style=none&width=746" alt="image.png"></p>
<h4 id="功能及应用场景-11"><a href="#功能及应用场景-11" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>当我们选择享元模式的时候，需要考虑以下因素：</p>
</li>
<li><p>需要创建大量的对象时。</p>
</li>
<li><p>由于对象众多，内存的开销是一个制约因素。</p>
</li>
<li><p>大多数对象属性可以分为内蕴状态和外蕴状态。</p>
</li>
<li><p>应用程序需要使用多种对象，且创建对象后需要多次重复使用。</p>
</li>
<li><p>外蕴状态最好是通过计算得到的，而不需要进行存储。</p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式是一类主要关注对象间相互通信（交互）的设计模式。这些对象之间的相互作用既能保证对象间能够交换数据，同时对象间仍然能够保持松耦合。<br>紧耦合一般会发生在一组紧密关联（相互依赖）的类之间。在面向对象的设计过程中，耦合引用的数量和设计过程中类与类之间的相互依赖是成正比的。用通俗的话讲，就是当一个类变化的时候，有多少可能需要同时修改其他类呢？<br>松耦合是软件架构设计的关键。在行为型模式中，功能实现与调用该实现的客户端之间应该是松耦合的，以避免硬编码和依赖性。<br>行为型模式处理不同的对象之间的通信关系，为其提供基本的通信方式，并提供实现这种通信方式的最常用、最灵活的解决方案。<br>行为型模式描述的不仅是类或对象的模式，同时也包括了它们之间的通信模式。行为型模式能够用来避免硬编码和依赖性。</p>
</li>
</ul>
<p><strong>行为型模式又分为以下子类别：</strong></p>
<ol>
<li>对象行为型模式：对象行为型模式使用对象组合而非继承。描述一组对象如何合作执行部分任务，而单个对象无法执行这些任务。</li>
<li>类行为型模式：类行为型模式使用继承而不是对象组合来描述算法和流程控制。</li>
</ol>
<p><strong>具体包括：</strong></p>
<ul>
<li>职责链模式（COR）：在一系列对象链之间传递请求的方法。</li>
<li>命令模式：命令模式主要用于在需要向对象发出请求的情况，发出请求的对象无须了解请求的操作内容，也无须了解请求的实际接收对象。</li>
<li>解释器模式：解释器提供了在代码中使用特定语言的一种方法。解释器模式就是一种用于在程序中解析特定语言的设计模式。</li>
<li>迭代器模式：迭代器用于顺序访问集合（组合）对象中的元素，而无须了解其内部结构。</li>
<li>中介者模式：定义简单的类间通信。</li>
<li>备忘录模式：捕获和恢复对象的内部状态。</li>
<li>观察者模式：一种通知多个类进行改变的方式。</li>
<li>状态模式：当一个对象状态改变时改变其功能。</li>
<li>策略模式：在类中进行算法封装。</li>
<li>模板方法模式：将算法中的部分步骤延迟到子类中进行计算。</li>
<li>访问者模式：在不改变类的条件下为该类定义一个新的操作。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>对象行为型模式</strong></th>
<th align="center"><strong>类行为型模式</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">职责链模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">解释器模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">命令模式</td>
<td align="center">模板方法模式</td>
</tr>
<tr>
<td align="center">迭代器模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">中介者模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">备忘录模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">观察者模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">状态模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">策略模式</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">访问者模式</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="职责链设计模式"><a href="#职责链设计模式" class="headerlink" title="职责链设计模式"></a>职责链设计模式</h3><p>在职责链模式中，由发送端发送一个请求到一个对象链中，链中的对象自行处理请求。如果链中的对象决定不响应请求，它会将请求转发给链中的下一个对象。<br>职责链的目的是通过特定设计对请求的发送者和接收者之间进行解耦。解耦是软件设计中很重要的一个方面。通过该设计模式能够使我们彻底地将发送者和接收者之间完全解耦。发送者是用于调用操作的对象，接收者是接收请求并执行相关操作的对象。通过解耦，发送者不需要关心接收者的接口。<br>在职责链模式中，职责是前后传递的。对于链中的对象，决定谁来响应请求的责任由整个链中左侧的对象来承担。这就像问答测验的时候传递问题一样。当提问者向一个人提问，如果他不知道答案，他就把问题传给下一个人，以此类推。当一个人回答了问题，问题就会停止向下传递。有时，也可能到达最后一个人时，还是没有人能回答问题。<br>我们能举出若干个职责链模式的例子：硬币分拣机、ATM取款机、Servlet过滤器和Java的异常处理机制。<br>在Java中，我们可以在catch语句中列出的异常序列时就抛出一个异常，catch列表从上到下逐条扫描。如果赶上第一个进行异常处理就可以立刻完成任务，否则责任转移到下一行，直到最后一行。</p>
<h4 id="模式中包括的类-12"><a href="#模式中包括的类-12" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4><ul>
<li><p>抽象处理者（Handler）：定义用于处理请求的接口。</p>
</li>
<li><p>具体处理者（ Concrete Handler）：它负责处理请求。如果它能够处理这样的要求就会自行处理，否则会将请求发送到下一个处理者。</p>
</li>
<li><p>客户端（Client）：将命令发送到职责链中第一个能够处理该请求的对象。</p>
<h4 id="UML图-12"><a href="#UML图-12" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588839044031-1dcdb9c4-a7c0-43b0-af86-4fb919336801.png#align=left&display=inline&height=483&margin=%5Bobject%20Object%5D&name=image.png&originHeight=483&originWidth=942&size=137762&status=done&style=none&width=942" alt="image.png"></p>
<h4 id="功能及应用场景-12"><a href="#功能及应用场景-12" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li>
<li><p>发送者并不知道在链中的哪个对象会响应请求。</p>
</li>
<li><p>职责链中的每一个对象都有责任决定是否对请求进行响应，如果这些对象有能力响应请求就会响应请求。</p>
</li>
<li><p>如果对象（或节点）决定向后传递请求它需要具有选择下一个节点和继续传递的能力。</p>
</li>
<li><p>也有可能没有任何一个节点能够响应请求（有些请求可能无法得到处理）</p>
</li>
<li><p>会在运行时确定哪些对象能够响应请求。</p>
<h3 id="命令设计模式"><a href="#命令设计模式" class="headerlink" title="命令设计模式"></a>命令设计模式</h3><p>命令模式（也称为行动模式、业务模式）是一个对象行为型模式。<br>这使我们能够实现发送者和接收者之间完全解耦。发送者是调用操作的对象，接收者是接收请求并执行特定操作的对象。通过解耦，发送者无须了解接收者的接口。在这里，请求的含义是需要被执行的命令。</p>
<h4 id="模式中包括的类-13"><a href="#模式中包括的类-13" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
<li><p>抽象命令类（Command）：在类中对需要执行的命令接口进行声明。</p>
</li>
<li><p>具体命令类（ ConcreteCommand）：将接收者对象和行为之间进行绑定。它通过调用接收者中相应的操作实现 execute方法。</p>
</li>
<li><p>客户端（ Client）：客户端完成对命令对象的实例化并提供随后需要调用的方法的信息。</p>
</li>
<li><p>调用者（Invoker）：调用者决定合适的调用方法。</p>
</li>
<li><p>接收者（Receiver）：接收者是包含方法代码的类的一个实例。这意味着它知道如何处理一个请求并执行相应的操作。任何一个类都可以作为接收者。</p>
<h4 id="UML图-13"><a href="#UML图-13" class="headerlink" title="UML图"></a>UML图</h4></li>
</ul>
<p><strong><img src="/images/interview/1588841461626-35402966-4817-4f7c-bc64-7fa4dbfc6a84.png#align=left&display=inline&height=344&margin=%5Bobject%20Object%5D&name=image.png&originHeight=433&originWidth=938&size=126130&status=done&style=none&width=746" alt="image.png"></strong></p>
<h4 id="功能及应用场景-13"><a href="#功能及应用场景-13" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><ul>
<li>通过参数化对象实现功能执行。命令是面向对象式的，而不是回调函数式的。</li>
<li>指定消息队列并在不同的时间执行请求一个命令对象可以有独立于原始请求的生命周期。如果一个请求的接收者可以由一个独立地址空间的方式来表示，那么你可以将请求对应的命令对象转换到不同的进程并在其中完成请求。</li>
<li>支持撤销。命令的执行操作可以作为状态进行存储，并在需要时实现命令撤销。命令接口必须增加一个unexecute操作，支持撤销之前命令调用的执行效果。执行的命令存储在命令的历史列表中。无限次数的撤销和重做是通过遍历这个列表并分别调用 unexecute和 execute来实现的。</li>
<li>支持日志记录变化，在系统崩溃的情况下使命令可以重新应用。通过增加load和 store操作命令接口参数，你可以保存一个持续变化的日志。从系统崩溃中恢复需要从磁盘重新加载日志命令和使用 Execute作重新执行这些命令。</li>
<li>通过在原生操作基础上的高层操作构建系统。这样的结构在支持交易操作的信息系统中很常见。一个交易事务封装一组变化的数据。命令模式提供了一种交易模型。命令都有一个共同的接口，允许你使用相同的方式调用所有的交易。这种模式也使得它很容易与新的交易系统进行交互扩展。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li><p>目的：将请求封装为一个对象，从而使客户端可以将不同的请求、队列、日志请求及其他支持撤销的操作进行参数化。</p>
</li>
<li><p>发出请求的对象无须知道请求对应的操作或请求接收者的任何信息。</p>
</li>
<li><p>后果：</p>
<ul>
<li>将调用操作的对象和执行操作的对象之间对命令进行解耦。即调用者和接收者之间解耦。</li>
<li>命令转换为一类对象。使其可以像其他对象那样进行操作和扩展。</li>
<li>我们可以将命令组合成一个组合命令。一般来说，组合命令是一个组合模式的实例。</li>
<li>很容易添加新的命令，因为我们无须改变现有的类。<h3 id="解释器设计模式"><a href="#解释器设计模式" class="headerlink" title="解释器设计模式"></a>解释器设计模式</h3>解释器模式是一种用于在程序中解析特定语法的设计模式。解释器模式是组合模式的一种应用。<br>对于特定的某种语言，解释器模式能够定义针对其语法表示形式的解释器，并实现对该语言语句的翻译和解释。<h4 id="模式中包括的类-14"><a href="#模式中包括的类-14" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
</ul>
</li>
<li><p>内容类（Context）：包含解释器的全局信息</p>
</li>
<li><p>表达式（AbstractExpression）：带有名叫 interpret抽象方法的抽象类。它会声明执行操作的接口。</p>
</li>
<li><p>终结符表达式（TerminalExpression）：就是带有终结符的表达式。</p>
</li>
<li><p>非终结符表达式（ NonterminalExpression）：在两个终结符表达式或非终结符表达式之间实现逻辑运算（与或运算）的表达式。</p>
</li>
<li><p>客户端（Client）：建立抽象树，并调用抽象树中的 interpret方法。</p>
<h4 id="UML图-14"><a href="#UML图-14" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588846767979-ce72003e-375a-4eea-8d13-eed6b726aa3b.png#align=left&display=inline&height=649&margin=%5Bobject%20Object%5D&name=image.png&originHeight=649&originWidth=992&size=178099&status=done&style=none&width=992" alt="image.png"></p>
<h4 id="功能及应用场景-14"><a href="#功能及应用场景-14" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>解释器模式的适用范围非常有限。我们可以说解释器模式仅仅用于需要进行正式语法解释的地方，但这些领域往往已经有了更好的标准的解决方法，因此，在实际使用中，并不会经常使用该模式。该模式可以用于解释使用了特定语法的表达式或者建立某个简单的规则引擎的时候。</p>
<h3 id="迭代器设计模式"><a href="#迭代器设计模式" class="headerlink" title="迭代器设计模式"></a>迭代器设计模式</h3><p>迭代器模式也是一种行为型模式。迭代器模式允许对一组对象元素的遍历（也叫收集）以完成功能实现。</p>
<h4 id="模式中包括的类-15"><a href="#模式中包括的类-15" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
<li><p>迭代器（Iterator）：它会实现一个用于定义迭代器的抽象迭代器接口。</p>
</li>
<li><p>具体迭代器（Concretel）：这是迭代器的实现（实现迭代器接口）。</p>
</li>
<li><p>抽象容器（Container）：这是用于定义聚合关系的接口。</p>
</li>
<li><p>具体容器（ConcreteContainer）：一个聚合关系的实现。</p>
<h4 id="UML图-15"><a href="#UML图-15" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588848682603-c5da8658-bbda-4c63-9c3f-f9bc80a93299.png#align=left&display=inline&height=462&margin=%5Bobject%20Object%5D&name=image.png&originHeight=462&originWidth=816&size=135540&status=done&style=none&width=816" alt="image.png"></p>
<h4 id="功能及应用场景-15"><a href="#功能及应用场景-15" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li>
<li><p>需要访问一个聚合（也称为容器）对象的内容，而无须了解其内部表示。-</p>
</li>
<li><p>支持对聚合对象的多种遍历方式。</p>
</li>
<li><p>为遍历不同的聚合结构提供统一的接口（即支持多态迭代）。</p>
</li>
<li><p>迭代器模式允许我们访问集合对象中的内容，而无须暴露其内部数据结构。</p>
</li>
<li><p>支持多个迭代器同时遍历集合对象。这意味着我们可以对相同的集合创建多个独立的迭代器。</p>
</li>
<li><p>为遍历不同的集合提供统一的接口。</p>
<h3 id="中介者设计模式"><a href="#中介者设计模式" class="headerlink" title="中介者设计模式"></a>中介者设计模式</h3><p>中介者模式主要是关于数据交互的设计模式。中介者设计模式很容易理解，却难以实现。该模式的核心是一个中介者对象，负责协调一系列对象之间一系列不同的数据请求。这一系列对象称为同事类。<br>同事类会让中介者知道它们会发生变化这样中介者负责处理变化对不同对象之间交互的影响。</p>
<h4 id="模式中包括的类-16"><a href="#模式中包括的类-16" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
<li><p>中介者接口（Mediator）：它定义了一个接口来实现同事类对象之间的沟通。</p>
</li>
<li><p>具体中介者（ ConcreteMediator）：它知道各个同事类，并和这些同事类保持相互引用。它实现了与同事类之间的通信和消息传递。</p>
</li>
<li><p>同事类（ Colleague）：这些类保存了对中介者的引用。无论它们想和任何其他同事类进行交互，都必须通过与中介类通信来实现。</p>
<h4 id="UML图-16"><a href="#UML图-16" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588850989407-80696883-cc5d-472b-a4de-0d5f5edd4cc4.png#align=left&display=inline&height=437&margin=%5Bobject%20Object%5D&name=image.png&originHeight=437&originWidth=979&size=149617&status=done&style=none&width=979" alt="image.png"></p>
<h4 id="功能及应用场景-16"><a href="#功能及应用场景-16" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li>
<li><p>一组对象使用了标准的通信方式，但整体通信的连接都非常复杂。由此产生的相互依赖的结果导致系统难以结构化，也很难理解。</p>
</li>
<li><p>由于对象之间的通信和相互引用，导致对象难以重用。</p>
</li>
<li><p>分布在多个类中的行为能够被统一定制化，而无须创建过多的子类。</p>
</li>
</ul>
<p><strong>需要注意的问题：</strong><br>实际使用中介者模式的时候，反而会让问题变得越来越复杂。所以最佳的实践是仅让中介者类负责对象之间的通信部分。</p>
<ul>
<li>定义一个对象来负责一系列对象之间的交互。</li>
<li>同事类发送和接收请求都需要通过中介者。</li>
</ul>
<p><strong>功能：</strong></p>
<ul>
<li><p>它对同事类进行解耦。中介类实现了同事类之间的松耦合。你可以相互独立地对不同的同事类进行修改和重用。</p>
</li>
<li><p>它简化了对象协议。中介者取代了许多交互作用，而实现了与多个同事类之间一对多的通信方式。一对多关系更容易理解、维护和扩展。</p>
</li>
<li><p>它集中了控制。中介者模式在中介者中集成了系统交互的复杂性。因此通过中介封装协议之后，它会比任何单一的同事类都更为复杂。这会使中介者作为一个整体也很难维护。</p>
</li>
<li><p>门面模式不同于中介者模式的是，它抽象了对象的子系统以提供一个更方便的接口。该种抽象是单向的。也就是说，门面对象会向子系统中的各个类发出请求，反之则不会。相比之下，中介者模式更像是同事类对象之间通过中介者的合作行为，系统的交互都是多向的。</p>
</li>
<li><p>当各个同事类只和一个中介者对象交互时，没有必要再去定义一个抽象的中介者类。抽象中介者只用于多个同事类通过多个抽象中介者的子类进行交互的情况，反之则不同。</p>
<h3 id="备忘录设计模式"><a href="#备忘录设计模式" class="headerlink" title="备忘录设计模式"></a>备忘录设计模式</h3><p>我们每天至少会使用一次这种模式。备忘录模式提供了一种使对象恢复到其以前状态的能力（通过回滚撤销）。备忘录模式是通过两个对象实现的：发起者和管理者。发起者是具有内部状态的某个对象。管理者则会对发起者执行一些操作，并实现撤销更改。</p>
<h4 id="模式中包括的类-17"><a href="#模式中包括的类-17" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
<li><p>发起者（Originator）：发起者知道如何保存自己。这是我们想要保存状态的类。</p>
</li>
<li><p>管理者（ Caretaker）：管理者是用于管理发起者进行状态保存的对象，具体处理发起者何时、如何、为何对状态进行存储。管理员应能够对发起者进行修改，同时也能够撤销这些修改。</p>
</li>
<li><p>备忘录（Memento）：备忘录会保存发起人的状态信息，而这些状态不能由管理者修改。</p>
<h4 id="UML图-17"><a href="#UML图-17" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588858153516-9c6b4ce0-aa41-42c4-b4c5-ae14e7faae51.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=360&originWidth=994&size=145133&status=done&style=none&width=994" alt="image.png"></p>
<h4 id="功能及应用场景-17"><a href="#功能及应用场景-17" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>当我们在实际应用中需要提供撤销机制，当一个对象有可能需要在后续操作中恢复其内部状态时，就需要使用备忘录模式。结合本设计模式实现对象状态序列化，能够使其易于保存对象的状态并进行状态回滚。<br>当一个对象状态的快照必须被存储，且在后续操作过程中需要被恢复时，就可以使用备忘录模式。</p>
<h3 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a>观察者设计模式</h3><p>在观察者模式中，一种叫作被观察者的对象维护了观察者对象的集合。当被观察者对象变化时，它会通知观察者。<br>在被观察者对象所维护的观察者集合中能够添加或删除观察者。被观察者的状态变化能够传递给观察者。这样观察者能够根据被观察者的状态变化做出相应的改变。</p>
<h4 id="模式中包括的类-18"><a href="#模式中包括的类-18" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
<li><p>被观察者（Listener）：定义了向客户端添加和移除观察者操作的接口或抽象类。</p>
</li>
<li><p>具体被观察者（ ConcreteListener）：具体被观察者类。它维护了对象的状态，并在当其状态改变时通知各个观察者。</p>
</li>
<li><p>观察者（Observer）：定义了用于通知对象的接口或抽象类。</p>
</li>
<li><p>具体观察者（ ConcreteObserver）：具体实现了观察者。</p>
<h4 id="UML图-18"><a href="#UML图-18" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588859146567-662ae183-11ae-475d-8d8d-a8549f3d4026.png#align=left&display=inline&height=431&margin=%5Bobject%20Object%5D&name=image.png&originHeight=431&originWidth=978&size=180698&status=done&style=none&width=978" alt="image.png"></p>
<h4 id="功能及应用场景-18"><a href="#功能及应用场景-18" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li>
<li><p>当一个对象的改变需要其他对象同时改变，而我们并不知道需要有多少个对象一起改变时。</p>
</li>
<li><p>当一个对象必须通知其他对象，而无须了解这些对象是谁时。</p>
</li>
<li><p>当一个抽象包含有两个方面，其中一个依赖于另一个。将这些方面封装成独立的对象，以便我们独立改变和重复使用它们时。</p>
<h3 id="状态设计模式"><a href="#状态设计模式" class="headerlink" title="状态设计模式"></a>状态设计模式</h3><p>状态模式是一种行为型模式。状态模式背后的理念是根据其状态变化来改变对象的行为。状态模式允许对象根据内部状态（内容类）实现不同的行为。内容类可以具有大量的内部状态，每当对内容类调用 request方法时，消息就被委托给状态类进行处理。<br>状态类接口定义了一个对所有具体状态类都有效的通用接口，并在其中封装了与特定状态相关的所有操作。具体状态类对请求提供各自具体的实现。当内容类的状态变化时，那么与之关联的具体状态类也会发生一定相应的改变。</p>
<h4 id="模式中包括的类-19"><a href="#模式中包括的类-19" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
<li><p>内容类（ Context）：内容类主要用于状态模式的客户端。客户端并不直接访问对象的状态。内容类拥有一个具体的状态对象并根据其当前状态提供所需实现的行为。</p>
</li>
<li><p>抽象状态类（ State）：这个抽象类是所有具体状态类的基类。状态类定义了一个通用接口。内容类对象能够通过使用该接口实现对不同功能的改变。在状态类及其子类的各个条目或属性中，本身并没有任何的状态。</p>
</li>
<li><p>具体状态类（ ConcreteState）：具体状态类根据内容类所提供的状态实现真正的功能改变。每个状态类所提供的行为都适用于内容类对象的某一个状态。它们也包含着由内容类状态变化所下发的指令。</p>
<h4 id="UML图-19"><a href="#UML图-19" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588860191434-2b5ff1d1-06e8-4036-8f95-0adfe7e383c1.png#align=left&display=inline&height=397&margin=%5Bobject%20Object%5D&name=image.png&originHeight=397&originWidth=1013&size=178430&status=done&style=none&width=1013" alt="image.png"></p>
<h4 id="功能及应用场景-19"><a href="#功能及应用场景-19" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li>
<li><p>状态模式为对象提供了一个清晰的状态表示。</p>
</li>
<li><p>它允许一个对象在运行时部分清晰明了地改变其类型。</p>
<h3 id="策略设计模式"><a href="#策略设计模式" class="headerlink" title="策略设计模式"></a>策略设计模式</h3><p>策略模式主要用于需要使用不同的算法来处理不同的数据（对象）时。这意味着策略模式定义了一系列算法，并且使其可以替换使用。策略模式是一种可以在运行时选择算法的设计模式。<br>本模式可以使算法独立于调用算法的客户端。策略模式也称为政策模式。在使用多种不同的算法（每种算法都可以对应一个单独的类，而每个类的功能又各不相同）时可以运用策略模式。</p>
<h4 id="模式中包括的类-20"><a href="#模式中包括的类-20" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
<li><p>抽象策略类（Strategy）：定义一个所有算法都支持的通用接口。内容类会使用这个接口来调用由具体策略类定义的各个算法。</p>
</li>
<li><p>具体策略类（ ContreteStrategy）：每个具体策略类都会实现一个相应的算法。</p>
</li>
<li><p>内容类（ Context）：包含一个对策略对象的引用。它可以定义一个用于策略类访问内容类数据的接口。内容类对象包含了对将要使用的具体策略对象的引用。当需要进行特定操作时，会从对应的策略类对象中运行相应的算法。内容类本身觉察不到策略类的执行。如果有必要的话，还可以定义专用的对象来传递从内容类对象到策略类的数据。内容类对象接收来自客户端的请求，并将其委托给策略类对象。通常具体策略类是由客户端创建，并传递给内容类。从这一点来讲，客户端仅与内容类进行交互。</p>
<h4 id="UML图-20"><a href="#UML图-20" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588861529453-aa147daa-653f-4559-b2ee-fdb0a370bf11.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&name=image.png&originHeight=426&originWidth=1095&size=182081&status=done&style=none&width=1095" alt="image.png"></p>
<h4 id="功能及应用场景-20"><a href="#功能及应用场景-20" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>当我们有多种不同的算法可供选择（每种算法都可以对应一个单独的类，而每个类的功能又各不相同）时，可以应用策略模式。策略模式会定义一组算法并能够使其相互替代使用。</p>
<h3 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h3><p>模板方法会定义算法的各个执行步骤。算法的一个或多个步骤可以由子类通过重写来实现，同时保证算法的完整性并能够实现多种不同的功能。<br>类行为型模式使用继承来实现模式的功能。在模板方法模式中，会有一个方法（ Template method方法）来定义算法的各个步骤。这些步骤（即方法）的具体实现会放到子类中。也就是说，在模板方法中定义了特定算法，但该算法的具体步骤仍然需要通过子类来定义。模板方法会由一个抽象类来实现在这个抽象类中还会声明该算法的各个步骤（方法），最后将其具体实现的方法声明实现为抽象类的子类。</p>
<h4 id="模式中包括的类-21"><a href="#模式中包括的类-21" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
<li><p>抽象类（ AbstractClass）：定义了算法的抽象操作，并交由具体的子类完成这些操作的具体实现。它实现了一个模板方法，它该方法包含了算法的各个步骤。该模板方法还会在抽象类中定义各个相应步骤的基本操作。</p>
</li>
<li><p>具体类（ ConcreteClass）：他们通过执行基本操作来实现算法类的具体步骤。当调用一个具体类时，模板方法代码会从基类执行，而模板方法所使用的各个方法由派生类实现和调用。</p>
<h4 id="UML图-21"><a href="#UML图-21" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588862264475-f62b4542-a18a-410e-b841-96049a3f2b44.png#align=left&display=inline&height=427&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=980&size=162268&status=done&style=none&width=746" alt="image.png"></p>
<h4 id="功能及应用场景-21"><a href="#功能及应用场景-21" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4></li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li><p>当一个算法的功能需要能够改变，并通过在子类中对功能重写来实现这种改变。</p>
</li>
<li><p>当我们要避免代码重复时，能够在子类中实现算法不同的变化。</p>
</li>
<li><p>在一开始，模板方法可能不是一个显而易见的选择。最明显的现象会是当我们发现几乎完全一样的类在执行某些类似的逻辑。这时，我们就应该考虑使用模板方法模式来清理现有代码。</p>
<h3 id="访问者设计模式"><a href="#访问者设计模式" class="headerlink" title="访问者设计模式"></a>访问者设计模式</h3><p>访问者模式用来简化对象相关操作的分组。这些操作是由访问者来执行的，而不是把这些代码放在被访问的类中。由于访问的操作是由访问者执行的，而不是由被访问的类，这样执行操作的代码会集中在访问者中，而不是分散在对象分组中。这为代码提供了更好的可维护性。访问者模式也避免了使用 instanceof运算符对相似的类执行计算。</p>
<h4 id="模式中包括的类-22"><a href="#模式中包括的类-22" class="headerlink" title="模式中包括的类"></a>模式中包括的类</h4></li>
<li><p>访问者（ Visitor）：包括一个接口或抽象类，用于声明在所有类型的可访问对象中访问哪些操作。通常操作的名称是相同的，而是由该方法的参数来区分不同的操作。由输入对象类型来决定访问该方法中的哪一个。</p>
</li>
<li><p>具体访问者（ Concrete Visitor）：用于实现各个类型的访问者和各个类型的访问方法。它在抽象访问者中进行声明，并各自独立实现。每一个具体访问者会负责实现不同的功能。当定义一个新的访问者时，只需要将其传递给对象结构即可。</p>
</li>
<li><p>元素类（Element）：一个抽象对象用于声明所接受的操作。它是一个入口点，能够允许哪一类访问者对象访问。在集合中的每个对象都需要实现该抽象对象，以便相应访问者能够实现对其进行访问。</p>
</li>
<li><p>具体元素类（ Concrete Element）：这些类实现了抽象元素类的接口或类，并定义了所接受的操作。通过其可接受的操作，能够将访问者对象传递给该对象。</p>
</li>
<li><p>结构对象（ ObjectStruture）：这是一个包含了所有可访问对象的类。它提供了一种机制来遍历所有元素。这种结构不一定是一个集合，也可以是一个极其复杂的结构，如组合对象。</p>
<h4 id="UML图-22"><a href="#UML图-22" class="headerlink" title="UML图"></a>UML图</h4><p><img src="/images/interview/1588863690354-5649da92-3741-4812-9f63-b5b7d0960238.png#align=left&display=inline&height=835&margin=%5Bobject%20Object%5D&name=image.png&originHeight=835&originWidth=1141&size=373163&status=done&style=none&width=1141" alt="image.png"></p>
<h4 id="功能及应用场景-22"><a href="#功能及应用场景-22" class="headerlink" title="功能及应用场景"></a>功能及应用场景</h4><p>在 visitCollection()方法中，我们调用 Visitable.accept(this)来实现对正确的访问者方法进行调用。这叫作双重分派。访问者调用元素类中的方法，又会回到对访问者类中进行调用。</p>
</li>
</ul>
<p><strong>模式问题：</strong><br>在使用访问者模式的情况下，要想添加新的具体元素（数据结构）会更加困难。添加一个 ConcreteElement会涉及向访问者接口添加新的操作和在每一个具体访问者实现中添加对应的实现。<strong>访问者模式更适用于对象结构非常稳定，而对象的操作却需要经常变化的情况下。</strong><br>访问者模式只提供处理每种数据类型的方法，并且让数据对象确定调用哪个方法。由于数据对象本质上都知道其自身的类型，所以在访问者模式中算法决定所调用的方法所起到的作用是微不足道的。<br>因此，数据的整体处理包括对数据对象的分发以及通过对适当的访问者处理方法的二次分发。这就叫作双重分派。<br>使用访问者模式的一个主要优点是，对于在我们的数据结构中添加需要执行的新的操作来说，是非常容易的。我们所要做的就是创建一个新的访问者，并定义相应的操作。<br>访问者模式的主要问题是，因为每个访问者需要有相应的方法来处理每一种可能的具体数据，那么一旦实现了访问者模式，其具体类的数量和类型就不能被轻易改变。</p>
]]></content>
      <categories>
        <category>技术文章</category>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>事务</title>
    <url>/2020/07/20/mysql/affair/</url>
    <content><![CDATA[<p>事务是指对系统进行的一组操作，为了保证系统的完整性，事务需要具有ACID特性</p>
<a id="more"></a>
<p>具体如下：</p>
<ol>
<li>原子性（Atomic）<br>     一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。实现事务的原子性，要支持回滚操作，在某个操作失败后，回滚到事务执行之前的状态。<br>     回滚实际上是一个比较高层抽象的概念，大多数DB在实现事务时，是在事务操作的数据快照上进行的（比如，MVCC），并不修改实际的数据，如果有错并不会提交，所以很自然的支持回滚。<br>     而在其他支持简单事务的系统中，不会在快照上更新，而直接操作实际数据。可以先预演一边所有要执行的操作，如果失败则这些操作不会被执行，通过这种方式很简单的实现了原子性。</li>
<li>一致性（Consistency）<br>     一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性：<br>     强一致性：读操作可以立即读到提交的更新操作。<br>     弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。<br>     最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。<br>     其他一致性变体还有：<br>     单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。<br>     会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。</li>
<li>隔离性（Isolation）<br>     并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据。在事务并发操作时，可能出现的问题有：<br>     脏读：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。<br>     不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过MVCC可以在无锁的情况下，避免不可重复读。<br>     幻读：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。<br>     事务的隔离级别从低到高有：<br>     Read Uncommitted：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。<br>     Read Committed：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。<br>     Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。<br>     Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。<br>     通常，在工程实践中，为了性能的考虑会对隔离性进行折中。</li>
<li>持久性（Durability）<br>     事务提交后，对系统的影响是永久的</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡的实现应用</title>
    <url>/2020/04/09/network/Load_balancing/</url>
    <content><![CDATA[<p>负载均衡是高可用架构的一个关键组件，主要用来提高性能和可用性，通过负载均衡将流量分发到多个服务器，同时多服务器能够消除这部分的单点故障。</p>
<a id="more"></a>

<h1 id="lvs"><a href="#lvs" class="headerlink" title="lvs"></a>lvs</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><blockquote>
<p>DS：Director Server。指的是前端负载均衡器节点<br>RS：Real Server。后端真实的工作服务器<br>VIP：向外部直接面向用户请求，作为用户请求的目标的IP地址<br>DIP：Director Server IP，主要用于和内部主机通讯的IP地址<br>RIP：Real Server IP，后端服务器的IP地址<br>CIP：Client IP，访问客户端的IP地址</p>
</blockquote>
<h2 id="四种模式"><a href="#四种模式" class="headerlink" title="四种模式"></a>四种模式</h2><h3 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a>DR模式</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>用户请求LVS到达director，director将请求的报文的目的MAC地址改为后端的realserver的MAC地址，目的IP为VIP(不变)，源IP为client IP地址(不变)，然后director将报文发送到realserver，realserver检测到目的地址为自己本地的VIP，如果在同一网段，将请求直接返回给用户，如果用户跟realserver不在同一个网段，则需要通过网关返回给用户。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>前端路由将目标地址为VIP报文统统发给Director Server<br>RS跟Director Server必须有一个网卡在同一个物理网络中<br>所有的请求报文经由Director Server，但响应报文必须不能进过Director Server<br>所有的real server机器上都有VIP地址</p>
</blockquote>
<h3 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a>NAT模式</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>用户请求LVS到达director，director将请求的报文的目的IP改为RIP，同时将报文的目标端口也改为realserver的相应端口，最后将报文发送到realserver上，realserver将数据返回给director，director再把数据发送给用户</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>NAT模式修改的是目的ip，直接走的是switch不需要修改mac地址，所以VIP和RIP不需要在同一个网段内<br>NAT的包的进出都需要经过LVS，所以LVS可能会成为一个系统的瓶颈问题</p>
</blockquote>
<h3 id="FULLNAT模式"><a href="#FULLNAT模式" class="headerlink" title="FULLNAT模式"></a>FULLNAT模式</h3><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>FULLNAT模式也不需要DIP和RIP在同一网段<br>FULLNAT和NAT相比的话：会保证RS的回包一定可到达LVS<br>FULLNAT需要更新源IP，所以性能正常比NAT模式下降10%</p>
</blockquote>
<h3 id="TUN"><a href="#TUN" class="headerlink" title="TUN"></a>TUN</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>用户请求LVS到达director，director通过IP-TUN加密技术将请求报文的包封装到一个新的IP包里面，目的IP为VIP(不变)，然后director将报文发送到realserver，realserver基于IP-TUN解密，然后解析出来包的目的为VIP，检测网卡是否绑定了VIP，绑定了就处理这个包，如果在同一个网段，将请求直接返回给用户，否则通过网关返回给用户；如果没有绑定VIP就直接丢掉这个包</p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><blockquote>
<p>TUNNEL必须在所有的realserver上绑定VIP<br>realserver直接把包发给client<br>隧道模式运维起来会比较难，所以一般不用</p>
</blockquote>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><h3 id="性能方面"><a href="#性能方面" class="headerlink" title="性能方面"></a>性能方面</h3><p>DR模式、IP TUN模式都是在包进入的时候经过LVS，在包返回的时候直接返回给client；所以二者的性能比NAT高<br>但TUN模式更加复杂，所以性能不如DR<br>FULLNAT模式不仅更换目的IP还更换了源IP，所以性能比NAT下降10%<br><strong>性能比较：DR&gt;TUN&gt;NAT&gt;FULLNAT</strong></p>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><h3 id="轮叫调度-rr"><a href="#轮叫调度-rr" class="headerlink" title="轮叫调度 rr"></a>轮叫调度 rr</h3><p>均等地对待每一台服务器，不管服务器上的实际连接数和系统负载</p>
<h3 id="加权轮叫-wrr"><a href="#加权轮叫-wrr" class="headerlink" title="加权轮叫 wrr"></a>加权轮叫 wrr</h3><p>调度器可以自动问询真实服务器的负载情况，并动态调整权值</p>
<h3 id="最少链接-lc"><a href="#最少链接-lc" class="headerlink" title="最少链接 lc"></a>最少链接 lc</h3><p>动态地将网络请求调度到已建立的连接数最少的服务器上<br>如果集群真实的服务器具有相近的系统性能，采用该算法可以较好的实现负载均衡</p>
<h3 id="加权最少链接-wlc"><a href="#加权最少链接-wlc" class="headerlink" title="加权最少链接 wlc"></a>加权最少链接 wlc</h3><p>调度器可以自动问询真实服务器的负载情况，并动态调整权值<br>带权重的谁不干活就给谁分配，机器配置好的权重高</p>
<h3 id="基于局部性的最少连接调度算法-lblc"><a href="#基于局部性的最少连接调度算法-lblc" class="headerlink" title="基于局部性的最少连接调度算法 lblc"></a>基于局部性的最少连接调度算法 lblc</h3><p>这个算法是请求数据包的目标 IP 地址的一种调度算法，该算法先根据请求的目标 IP 地址寻找最近的该目标 IP 地址所有使用的服务器，如果这台服务器依然可用，并且有能力处理该请求，调度器会尽量选择相同的服务器，否则会继续选择其它可行的服务器</p>
<h3 id="复杂的基于局部性最少的连接算法-lblcr"><a href="#复杂的基于局部性最少的连接算法-lblcr" class="headerlink" title="复杂的基于局部性最少的连接算法 lblcr"></a>复杂的基于局部性最少的连接算法 lblcr</h3><p>记录的不是要给目标 IP 与一台服务器之间的连接记录，它会维护一个目标 IP 到一组服务器之间的映射关系，防止单点服务器负载过高。</p>
<h3 id="目标地址散列调度算法-dh"><a href="#目标地址散列调度算法-dh" class="headerlink" title="目标地址散列调度算法 dh"></a>目标地址散列调度算法 dh</h3><p>该算法是根据目标 IP 地址通过散列函数将目标 IP 与服务器建立映射关系，出现服务器不可用或负载过高的情况下，发往该目标 IP 的请求会固定发给该服务器。</p>
<h3 id="源地址散列调度算法-sh"><a href="#源地址散列调度算法-sh" class="headerlink" title="源地址散列调度算法 sh"></a>源地址散列调度算法 sh</h3><p>与目标地址散列调度算法类似，但它是根据源地址散列算法进行静态分配固定的服务器资源。</p>
<h3 id="最少期望延迟-sed"><a href="#最少期望延迟-sed" class="headerlink" title="最少期望延迟 sed"></a>最少期望延迟 sed</h3><p>不考虑非活动链接，谁的权重大，优先选择权重大的服务器来接收请求，但权重大的机器会比较忙</p>
<h3 id="永不排队-nq"><a href="#永不排队-nq" class="headerlink" title="永不排队 nq"></a>永不排队 nq</h3><p>无需队列，如果有realserver的连接数为0就直接分配过去</p>
<h1 id="lacp"><a href="#lacp" class="headerlink" title="lacp"></a>lacp</h1><h1 id="等价路由"><a href="#等价路由" class="headerlink" title="等价路由"></a>等价路由</h1><h1 id="F5"><a href="#F5" class="headerlink" title="F5"></a>F5</h1><h1 id="haproxy"><a href="#haproxy" class="headerlink" title="haproxy"></a>haproxy</h1><h1 id="oos"><a href="#oos" class="headerlink" title="oos"></a>oos</h1><h1 id="iptable"><a href="#iptable" class="headerlink" title="iptable"></a>iptable</h1>]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>overlay文件系统</title>
    <url>/2020/04/02/linux/overlay/</url>
    <content><![CDATA[<p>Overlayfs是一种类似aufs的一种堆叠文件系统，于2014年正式合入Linux-3.18主线内核，是一种覆盖式的文件系统。它依赖并建立在其它的文件系统之上（例如ext4fs和xfs等等），并不直接参与磁盘空间结构的划分，仅仅将原来底层文件系统中不同的目录进行“合并”，然后向用户呈现。因此对于用户来说，它所见到的overlay文件系统根目录下的内容就来自挂载时所指定的不同目录的“合集”。</p>
<a id="more"></a>

<p>常见用法是，底层文件系统只读，上层文件系统可读写；著名的docker就是使用的overlayfs。</p>
<p>在嵌入式应用中，底层只读系统一般使用squashfs，上层使用jffs2.</p>
<p><img src="/images/linux/filesystem/overlayFS1.jpg" alt="overlay"></p>
<p>如图所示，底层目录为只读目录，当用户需要修改时，会把底层目录中的文件<code>cp</code>一份至上层目录，并进行修改、增加</p>
<h2 id="docker中的对应关系"><a href="#docker中的对应关系" class="headerlink" title="docker中的对应关系"></a>docker中的对应关系</h2><blockquote>
<p>image layer  –&gt; 底层目录<br>container layer –&gt; 上层目录<br>container mount –&gt; 合并目录</p>
</blockquote>
<h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ul>
<li>如果文件在容器层（upperdir），直接读取文件；</li>
<li>如果文件不在容器层（upperdir），则从镜像层（lowerdir）读取；</li>
</ul>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul>
<li>首次写入： 如果在upperdir中不存在，overlay和overlay2执行copy_up操作，把文件从lowdir拷贝到upperdir，由于overlayfs是文件级别的（即使文件只有很少的一点修改，也会产生的copy_up的行为），后续对同一文件的在此写入操作将对已经复制到容器的文件的副本进行操作。这也就是常常说的写时复制（copy-on-write）</li>
<li>删除文件和目录： 当文件在容器被删除时，在容器层（upperdir）创建whiteout文件，镜像层(lowerdir)的文件是不会被删除的，因为他们是只读的，但without文件会阻止他们显示，当目录在容器内被删除时，在容器层（upperdir）一个不透明的目录，这个和上面whiteout原理一样，阻止用户继续访问，即便镜像层仍然存在。 </li>
</ul>
<h3 id="docker中的使用"><a href="#docker中的使用" class="headerlink" title="docker中的使用"></a>docker中的使用</h3><ol>
<li>容器层的文件删除只是一个“障眼法”，是靠whiteout文件将其遮挡,image层并没有删除，这也就是为什么使用docker commit 提交保存的镜像会越来越大，无论在容器层怎么删除数据，image层都不会改变。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>在进行<code>copy-up</code> 操作时，相对于磁盘类的文件系统，速度会大幅降低，为了保证底层目录用户间不互相影响，且保证一致性，<code>copy-up</code>时会进行很多操作，导致在复制大文件和多个小文件时慢</li>
<li>不可rename 文件夹，可以通过mv 进行文件夹的修改，但是修改时，会创建完整副本，并不会仅仅修改inode 索引</li>
<li>在硬链接中，当合并目录对底层目录的某个硬链接文件进行修改时，会在上层目录<code>copy-up</code>一份并进行修改，此时此文件和原始文件的硬链接就断开了，变成了一个单独的文件。</li>
</ol>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Channel的使用场景</title>
    <url>/2019/12/04/golang/channel_usage/</url>
    <content><![CDATA[<h2 id="channel的使用场景"><a href="#channel的使用场景" class="headerlink" title="channel的使用场景"></a>channel的使用场景</h2><p>把channel用在数据流动的地方：</p>
<ol>
<li>消息传递、消息过滤</li>
<li>信号广播</li>
<li>事件订阅与广播</li>
<li>请求、响应转发</li>
<li>任务分发</li>
<li>结果汇总</li>
<li>并发控制</li>
<li>同步与异步</li>
<li>…<a id="more"></a>

</li>
</ol>
<h2 id="channel的基本操作和注意事项"><a href="#channel的基本操作和注意事项" class="headerlink" title="channel的基本操作和注意事项"></a>channel的基本操作和注意事项</h2><h5 id="channel存在3种状态："><a href="#channel存在3种状态：" class="headerlink" title="channel存在3种状态："></a>channel存在3种状态：</h5><ol>
<li>nil，未初始化的状态，只进行了声明，或者手动赋值为nil</li>
<li>active，正常的channel，可读或者可写</li>
<li>closed，已关闭，千万不要误认为关闭channel后，channel的值是nil</li>
</ol>
<h5 id="channel可进行3种操作："><a href="#channel可进行3种操作：" class="headerlink" title="channel可进行3种操作："></a>channel可进行3种操作：</h5><ol>
<li>读</li>
<li>写</li>
<li>关闭</li>
</ol>
<h4 id="把这3种操作和3种channel状态可以组合出9种情况："><a href="#把这3种操作和3种channel状态可以组合出9种情况：" class="headerlink" title="把这3种操作和3种channel状态可以组合出9种情况："></a>把这3种操作和3种channel状态可以组合出9种情况：</h4><p><img src="/images/golang/channel_usage.jpg" alt="状态组合"></p>
<p>对于nil通道的情况，也并非完全遵循上表，有1个特殊场景：当nil的通道在select的某个case中时，这个case会阻塞，但不会造成死锁。</p>
<h2 id="使用channel的10种常用操作"><a href="#使用channel的10种常用操作" class="headerlink" title="使用channel的10种常用操作"></a>使用channel的10种常用操作</h2><h4 id="使用for-range读channel"><a href="#使用for-range读channel" class="headerlink" title="使用for range读channel"></a>使用for range读channel</h4><ul>
<li>场景：当需要不断从channel读取数据时</li>
<li>原理：使用<code>for ... range</code>读取channel，这样既安全又便利，当channel关闭时，for循环会自动退出，无需主动监测channel是否关闭，可以防止读取已经关闭的channel，造成读到数据为通道所存储的数据类型的零值。</li>
<li>用法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x := <span class="keyword">range</span> ch&#123;</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-ok判断channel是否关闭"><a href="#使用-ok判断channel是否关闭" class="headerlink" title="使用_,ok判断channel是否关闭"></a>使用_,ok判断channel是否关闭</h4><ul>
<li>场景：读channel，但不确定channel是否关闭时</li>
<li>原理：读已关闭的channel会造成panic，如果不确定channel，需要使用ok进行检测。ok的结果和含义：</li>
<li><ul>
<li><code>true</code>：读到数据，并且通道没有关闭。</li>
</ul>
</li>
<li><ul>
<li><code>false</code>：通道关闭，无数据读到。</li>
</ul>
</li>
<li>用法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> v, ok := &lt;- ch; ok &#123;</span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用select处理多个channel"><a href="#使用select处理多个channel" class="headerlink" title="使用select处理多个channel"></a>使用select处理多个channel</h4><ul>
<li>场景：需要对多个通道进行同时处理，但只处理最先发生的channel时</li>
<li>原理：select可以同时监控多个通道的情况，只处理未阻塞的case。当通道为nil时，对应的case永远为阻塞，无论读写。特殊关注：普通情况下，对nil的通道写操作是要panic的。</li>
<li>用法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配job时，如果收到关闭的通知则退出，不分配job</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">handle</span><span class="params">(job *Job)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> h.jobCh&lt;-job:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">case</span> &lt;-h.stopCh:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用channel的声明控制读写权限"><a href="#使用channel的声明控制读写权限" class="headerlink" title="使用channel的声明控制读写权限"></a>使用channel的声明控制读写权限</h5><ul>
<li>场景：协程对某个通道只读或只写时</li>
<li>目的：A. 使代码更易读、更易维护，B. 防止只读协程对通道进行写数据，但通道已关闭，造成panic。</li>
<li>用法：</li>
<li><ul>
<li>如果协程对某个channel只有写操作，则这个channel声明为只写。</li>
</ul>
</li>
<li><ul>
<li>如果协程对某个channel只有读操作，则这个channe声明为只读。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有generator进行对outCh进行写操作，返回声明</span></span><br><span class="line"><span class="comment">// &lt;-chan int，可以防止其他协程乱用此通道，造成隐藏bug</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generator</span><span class="params">(<span class="keyword">int</span> n)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;n;i++&#123;</span><br><span class="line">            outCh&lt;-i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> outCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consumer只读inCh的数据，声明为&lt;-chan int</span></span><br><span class="line"><span class="comment">// 可以防止它向inCh写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(inCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> inCh &#123;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用缓冲channel增强并发和异步"><a href="#使用缓冲channel增强并发和异步" class="headerlink" title="使用缓冲channel增强并发和异步"></a>使用缓冲channel增强并发和异步</h4><ul>
<li>场景：异步和并发</li>
<li>原理：A. 有缓冲通道是异步的，无缓冲通道是同步的，B. 有缓冲通道可供多个协程同时处理，在一定程度可提高并发性。</li>
<li>用法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无缓冲，同步</span></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 有缓冲，异步</span></span><br><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 使用5个`do`协程同时处理输入数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    inCh := generator(<span class="number">100</span>)</span><br><span class="line">    outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> do(inCh, outCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> r := <span class="keyword">range</span> outCh &#123;</span><br><span class="line">        fmt.Println(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(inCh &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>, outCh <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> inCh &#123;</span><br><span class="line">        outCh &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="为操作加上超时"><a href="#为操作加上超时" class="headerlink" title="为操作加上超时"></a>为操作加上超时</h4><ul>
<li>场景：需要超时控制的操作</li>
<li>原理：使用<code>select</code>和<code>time.After</code>，看操作和定时器哪个先返回，处理先完成的，就达到了超时控制的效果</li>
<li>用法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWithTimeOut</span><span class="params">(timeout time.Duration)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ret := &lt;-do():</span><br><span class="line">        <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(timeout):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    outCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// do work</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> outCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用time实现channel无阻塞读写"><a href="#使用time实现channel无阻塞读写" class="headerlink" title="使用time实现channel无阻塞读写"></a>使用time实现channel无阻塞读写</h4><ul>
<li>场景：并不希望在channel的读写上浪费时间</li>
<li>原理：是为操作加上超时的扩展，这里的操作是channel的读或写</li>
<li>用法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unBlockRead</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="params">(x <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> x = &lt;-ch:</span><br><span class="line">        <span class="keyword">return</span> x, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Microsecond):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;read time out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unBlockWrite</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>, x <span class="keyword">int</span>)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- x:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Microsecond):</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;read time out&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>注：time.After等待可以替换为default，则是channel阻塞时，立即返回的效果</em></p>
<h4 id="使用close-ch-关闭所有下游协程"><a href="#使用close-ch-关闭所有下游协程" class="headerlink" title="使用close(ch)关闭所有下游协程"></a>使用close(ch)关闭所有下游协程</h4><ul>
<li>场景：退出时，显示通知所有协程退出</li>
<li>原理：所有读ch的协程都会收到close(ch)的信号</li>
<li>用法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">close</span>(h.stopCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以使用WaitGroup等待所有协程退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到停止后，不再处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Handler)</span> <span class="title">loop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> req := &lt;-h.reqCh:</span><br><span class="line">            <span class="keyword">go</span> handle(req)</span><br><span class="line">        <span class="keyword">case</span> &lt;-h.stopCh:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用chan-struct-作为信号channel"><a href="#使用chan-struct-作为信号channel" class="headerlink" title="使用chan struct{}作为信号channel"></a>使用chan struct{}作为信号channel</h4><ul>
<li>场景：使用channel传递信号，而不是传递数据时</li>
<li>原理：没数据需要传递时，传递空struct</li>
<li>用法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上例中的Handler.stopCh就是一个例子，stopCh并不需要传递任何数据</span></span><br><span class="line"><span class="comment">// 只是要给所有协程发送退出的信号</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">struct</span> &#123;</span><br><span class="line">    stopCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    reqCh <span class="keyword">chan</span> *Request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用channel传递结构体的指针而非结构体"><a href="#使用channel传递结构体的指针而非结构体" class="headerlink" title="使用channel传递结构体的指针而非结构体"></a>使用channel传递结构体的指针而非结构体</h4><ul>
<li>场景：使用channel传递结构体数据时</li>
<li>原理：channel本质上传递的是数据的拷贝，拷贝的数据越小传输效率越高，传递结构体指针，比传递结构体更高效</li>
<li>用法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reqCh <span class="keyword">chan</span> *Request</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好过</span></span><br><span class="line">reqCh <span class="keyword">chan</span> Request</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Composite_Pattern/</url>
    <content><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>您想表示对象的部分-整体层次结构（树形结构）</li>
<li>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作数、操作符和另一个操作数</li>
<li>如描述一家公司的层次结构，那么我们用办公室来表示节点，则总经理办公司是根节点，下面分别由人事办公室、业务办公室、生产办公室、财务办公室，每个办公室下面可以还有跟小的办公室，每个办公室都有职责、人员数、人员薪资等属性；</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="组合模式-1"><a href="#组合模式-1" class="headerlink" title="组合模式"></a>组合模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentBases</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;部门抽象出来的基类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        slef.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params">ComponentBases</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, duty</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.duty = duty</span><br><span class="line">        self.children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        self.children.append(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        self.children.remove(obj)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self, number=<span class="number">1</span></span>):</span></span><br><span class="line">        print(<span class="string">&quot;部门：&#123;&#125; 级别：&#123;&#125; 职责：&#123;&#125;&quot;</span>.format(self.name, number, self.duty))</span><br><span class="line">        n = number+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> obj <span class="keyword">in</span> self.children:</span><br><span class="line">            obj.display(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    root = Node(<span class="string">&quot;总经理办公室&quot;</span>, <span class="string">&quot;总负责人&quot;</span>)</span><br><span class="line">    node1 = Node(<span class="string">&quot;财务部门&quot;</span>, <span class="string">&quot;公司财务管理&quot;</span>)</span><br><span class="line">    root.add(node1)</span><br><span class="line">    node2 = Node(<span class="string">&quot;业务部门&quot;</span>, <span class="string">&quot;销售产品&quot;</span>)</span><br><span class="line">    root.add(node2)</span><br><span class="line">    node3 = Node(<span class="string">&quot;生产部门&quot;</span>, <span class="string">&quot;生产产品&quot;</span>)</span><br><span class="line">    root.add(node3)</span><br><span class="line">    node4 = Node(<span class="string">&quot;销售事业一部门&quot;</span>, <span class="string">&quot;A产品销售&quot;</span>)</span><br><span class="line">    node2.add(node4)</span><br><span class="line">    node5 = Node(<span class="string">&quot;销售事业二部门&quot;</span>, <span class="string">&quot;B产品销售&quot;</span>)</span><br><span class="line">    node2.add(node5)</span><br><span class="line">    root.display()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">----------输出-----------</span></span><br><span class="line"><span class="string">部门：总经理办公室 级别：1 职责：总负责人</span></span><br><span class="line"><span class="string">部门：财务部门 级别：2 职责：公司财务管理</span></span><br><span class="line"><span class="string">部门：业务部门 级别：2 职责：销售产品</span></span><br><span class="line"><span class="string">部门：销售事业一部门 级别：3 职责：A产品销售</span></span><br><span class="line"><span class="string">部门：销售事业二部门 级别：3 职责：B产品销售</span></span><br><span class="line"><span class="string">部门：生产部门 级别：2 职责：生产产品</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Command_Pattern/</url>
    <content><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<p>“行为请求者”与“行为实现者”通常呈现一种“紧耦合”。但在某些场合，比如要对行为进行“记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将“行为请求者”与“行为实现者”解耦？将一组行为抽象为对象，实现二者之间的松耦合。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>模拟 CMD。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="命令模式-1"><a href="#命令模式-1" class="headerlink" title="命令模式"></a>命令模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;声明命令模式接口&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        self.obj = obj</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span>(<span class="params">Command</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;实现命令模式接口&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.obj.run()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;接受命令并执行命令的接口&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._commands = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_command</span>(<span class="params">self, cmd</span>):</span></span><br><span class="line">        self._commands.append(cmd)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_command</span>(<span class="params">self, cmd</span>):</span></span><br><span class="line">        self._commands.remove(cmd)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_command</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> cmd <span class="keyword">in</span> self._commands:</span><br><span class="line">            cmd.execute()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;具体动作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        self.word = word</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.word)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;装配者&quot;&quot;&quot;</span></span><br><span class="line">    test = Invoker()</span><br><span class="line">    cmd1 = ConcreteCommand(Receiver(<span class="string">&#x27;命令一&#x27;</span>))</span><br><span class="line">    test.add_command(cmd1)</span><br><span class="line">    cmd2 = ConcreteCommand(Receiver(<span class="string">&#x27;命令二&#x27;</span>))</span><br><span class="line">    test.add_command(cmd2)</span><br><span class="line">    cmd3 = ConcreteCommand(Receiver(<span class="string">&#x27;命令三&#x27;</span>))</span><br><span class="line">    test.add_command(cmd3)</span><br><span class="line">    test.run_command()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    client()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">--------------------------</span></span><br><span class="line"><span class="string">命令一</span></span><br><span class="line"><span class="string">命令二</span></span><br><span class="line"><span class="string">命令三</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Chain_of_Responsibility_Pattern/</url>
    <content><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>将多个处理方法连接成一条链条，请求将在这条链条上流动直到该链条中有一个节点可以处理该请求；通常这条链条是一个对象包含对另一个对象的引用而形成链条，每个节点有对请求的条件，当不满足条件将传递给下一个节点处理。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="责任链模式-1"><a href="#责任链模式-1" class="headerlink" title="责任链模式"></a>责任链模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bases</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, obj=None</span>):</span></span><br><span class="line">        self.obj = obj</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">screen</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">Bases</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">screen</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">200</span> &gt; number &gt; <span class="number">100</span>:</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125; 划入A集合&quot;</span>.format(number))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.obj.screen(number)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Bases</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">screen</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> number &gt;= <span class="number">200</span>:</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125; 划入B集合&quot;</span>.format(number))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.obj.screen(number)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">Bases</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">screen</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">100</span> &gt;= number:</span><br><span class="line">            print(<span class="string">&quot;&#123;&#125; 划入C集合&quot;</span>.format(number))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = [<span class="number">10</span>, <span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line">    c = C()</span><br><span class="line">    b = B(c)</span><br><span class="line">    a = A(b)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> test:</span><br><span class="line">        a.screen(i)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">-------------------</span></span><br><span class="line"><span class="string">10 划入C集合</span></span><br><span class="line"><span class="string">100 划入C集合</span></span><br><span class="line"><span class="string">150 划入A集合</span></span><br><span class="line"><span class="string">200 划入B集合</span></span><br><span class="line"><span class="string">300 划入B集合</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>一个对象中含有另一个对象的引用以此类推形成链条</li>
<li>每个对象中应该有明确的责任划分即处理请求的条件</li>
<li>链条的最后一节应该设计成通用请求处理，以免出现漏洞</li>
<li>请求应该传入链条的头部</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Builder_Pattern/</url>
    <content><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>建造者模式（生成器模式、Buidler Pattern）和抽象工厂模式的目的都是用来创建复杂的对象，但是创建的过程是截然不同的。</p>
<ul>
<li>在抽象工厂模式中，抽象出了创建方法，使用者只能按照预定好的步骤新创建一个对象。</li>
<li>在建造者模式中，使用者可以按照自己的想法，在合理的范围内定制自己所需要的对象。<a id="more"></a>

</li>
</ul>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>对象的创建步骤可以独立于创建过程的时候</li>
<li>被创建的对象拥有不同的表现形式</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="建造者模式-1"><a href="#建造者模式-1" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>举一个栗子，我现在要买一台新版 15 寸的 Macbook Pro，打开官网发现有标准版和定制版两种可以选择。<br>所以现在有两种选择，购买标准版和购买定制版，定制版可以 SSD 升级到 1TB，可以把 CPU 升级到 2.7GHz，但是不允许升级内存到 32G，因为苹果说 32G 内存效果提升不大，还更加耗电。<br>这么一来我们就可在合理的范围内定制一台适合自己的笔记本。和购买标准版的结果一样，最后的结果都是可以获得一台新的 Macbook Pro。<br>类比到建造者模式和抽象工厂模式就是定制版和标准版。<br>总结一句话：建造者模式注重一步一步创建对象，抽象工厂模式注重一步到位创建对象。<br>建造者由 Director 和 Builder 构成，Builder 用于抽象各个对象部件的接口，Director 用于构造一个 Builder 的接口，由 Director 去指导 Builder 如何生成一个复杂对象。</p>
<p>以购买一台 2016 款 15 寸 Macbook Pro 为背景描述一个建造者模式。</p>
<p>我们在线购买时候 online shop 就是一个 Director，它一步一步指导我们去购买一个 Macbook Pro。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlineShop</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, buidler</span>):</span></span><br><span class="line">        Macbook = namedtuple(<span class="string">&#x27;Macbook&#x27;</span>, <span class="string">&#x27;cpu memory ssd graphics&#x27;</span>)</span><br><span class="line">        self.macbook = Macbook(buidler.cpu, buidler.memory,</span><br><span class="line">                               buidler.ssd, buidler.graphics)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> str(self.macbook)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MacbookBuilder</span>(<span class="params">object</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            self.cpu = <span class="string">&#x27;2.7GHz&#x27;</span></span><br><span class="line">            self.memory = <span class="string">&#x27;16G&#x27;</span></span><br><span class="line">            self.ssd = <span class="string">&#x27;512GB&#x27;</span></span><br><span class="line">            self.graphics = <span class="string">&#x27;Radeon Pro 455&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">upgrade_cpu</span>(<span class="params">self, cpu</span>):</span></span><br><span class="line">            self.cpu = cpu</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">upgrade_memory</span>(<span class="params">self, memory</span>):</span></span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;&#123;0&#125; is max&#x27;</span>.format(self.memory))</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">upgrade_ssd</span>(<span class="params">self, ssd</span>):</span></span><br><span class="line">            self.ssd = ssd</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">upgrade_graphics</span>(<span class="params">self, graphics</span>):</span></span><br><span class="line">            self.graphics = graphics</span><br><span class="line">            <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>
<p>OnlineShop 作为一个 Director 被客户端调用，MacbookBuilder 作为一个 Builder 是不能被客户端调用，只能被 Director 所调用，直接在类中定义另一个类，是防止被调用的简洁实现方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">macbook &#x3D; OnlineShop.MacbookBuilder().upgrade_cpu(&#39;2.9GHz&#39;).upgrade_ssd(&#39;2TB&#39;).upgrade_graphics(&#39;Radeon Pro 460&#39;).build_up()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Bridge/</url>
    <content><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 </li>
<li>2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li>
<li>3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="桥接模式-1"><a href="#桥接模式-1" class="headerlink" title="桥接模式"></a>桥接模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        print(<span class="string">&quot;my name is :&#123;&#125;&quot;</span>.format(name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我的名字是：&#123;&#125;&quot;</span>.format(name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bridge</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ager, classname</span>):</span></span><br><span class="line">        self.ager = ager</span><br><span class="line">        self.classname = classname</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bridge_run</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.classname.run(self.ager)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = Bridge(<span class="string">&#x27;李华&#x27;</span>, A())</span><br><span class="line">    test.bridge_run()</span><br><span class="line">    test.ager = <span class="string">&#x27;Tome&#x27;</span></span><br><span class="line">    test.bridge_run()</span><br><span class="line">    test.classname = B()</span><br><span class="line">    test.bridge_run()</span><br><span class="line">    test.ager = <span class="string">&#x27;李华&#x27;</span></span><br><span class="line">    test.bridge_run()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Adapter_Pattern/</url>
    <content><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>面对一个有全新接口的类库而又不能改变现有代码时，最先想到的做法是，在这两个系统之间添加一个适配器。</li>
<li>grpc 也可以认为是一种适配器，提供了跨语言调用能力</li>
<li>sqlalchemy 可以在不改变代码的情况下对接多种数据库</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="适配器模式-1"><a href="#适配器模式-1" class="headerlink" title="适配器模式"></a>适配器模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 鸭子的简单描述</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 会呱呱叫</span></span><br><span class="line">        print(<span class="string">&quot;Quack&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 飞的能力</span></span><br><span class="line">        print(<span class="string">&quot;I&#x27;m flying&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 火鸡的简单描述</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turkey</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gobble</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 不会呱呱叫，只会咯咯叫</span></span><br><span class="line">        print(<span class="string">&quot;Gobble gobble&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 飞的能力 但是飞不远</span></span><br><span class="line">        print(<span class="string">&quot;I&#x27;m flying a short distance&quot;</span>)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>因为现在没有鸭子对象，只能那火鸡对象冒充。由于鸭子对象和火鸡对象功能不同，不能直接拿来用，现在就需要使用适配器来完成这个功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span>(<span class="params">Duck</span>):</span></span><br><span class="line">    turkey = Turkey()  <span class="comment"># 这里实际使用的是火鸡对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 实现鸭子对象拥有的quack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.turkey.gobble()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 假设火鸡比鸭子飞的短，为了模拟鸭子的动作，多飞几次</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            turkey.fly()</span><br><span class="line"></span><br><span class="line"><span class="comment"># test</span></span><br><span class="line"></span><br><span class="line">duck = Duck()</span><br><span class="line">duck.quack()</span><br><span class="line">duck.fly()</span><br><span class="line"></span><br><span class="line">turkey_adapter = Duck()</span><br><span class="line">turkey_adapter.quack()</span><br><span class="line">turkey_adapter.fly()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>共识算法</title>
    <url>/2019/11/25/blockchain/consensus/</url>
    <content><![CDATA[<p>区块链架构是一种分布式的架构。其部署模式有</p>
<blockquote>
<p>公共链  中心化分布式系统<br>联盟链  部分去中心化分布式系统<br>私有链  弱中心分布式系统</p>
</blockquote>
<a id="more"></a>

<p>在分布式系统中，多个主机通过异步通信方式组成网络集群。在这样的一个异步系统中，需要主机之间进行状态复制，以保证每个主机达成一致的状态共识。然而，异步系统中，可能出现无法通信的故障主机，而主机的性能可能下降，网络可能拥塞，这些可能导致错误信息在系统内传播。因此需要在默认不可靠的异步网络中定义容错协议，以确保各主机达成安全可靠的状态共识。</p>
<p>所谓共识，简单理解就是指大家都达成一致的意思。其实在现实生活中，有很多需要达成共识的场景，比如开会讨论，双方或多方签订一份合作协议等。而在区块链系统中，每个节点必须要做的事情就是让自己的账本跟其他节点的账本保持一致。如果是在传统的软件结构中，这几乎就不是问题，因为有一个中心服务器存在，也就是所谓的主库，其他的从库向主库看齐就行了。在实际生活中，很多事情人们也都是按照这种思路来的，比如企业老板发布一个通知，员工照着做。但是区块链是一个分布式的对等网络结构，在这个结构中没有哪个节点是“老大”，一切都要商量着来。</p>
<p>所以在区块链系统中，如何让每个节点通过一个规则将各自的数据保持一致是一个很核心的问题，这个问题的解决方案就是制定一套共识算法，实现不同账本节点上的账本数据的一致性和正确性。这就需要借鉴已有的在分布式系统中实现状态共识的算法，确定网络中选择记账节点的机制，以及如何保障账本数据在全网中形成正确、一致的共识。</p>
<p>共识算法其实就是一个规则，每个节点都按照这个规则去确认各自的数据。我们暂且抛开算法的原理，先来想一想在生活中我们会如何解决这样一个问题：假设一群人开会，这群人中没有一个领导或者说老大，大家各抒己见，那么最后如何统一出一个决定出来呢？实际处理的时候，我们一般会在某一个时间段中选出一个人，那个人负责汇总大家的内容，然后发布完整的意见，其他人投票表决，每个人都有机会来做汇总发表，最后谁的支持者多就以谁的最终意见为准。这种思路其实就算是一种共识算法了。然而在实际过程中，如果人数不多并且数量是确定的，还好处理；如果人数很多且数量也不固定，那就很难通过这种方式投票决定了，效率太低。我们需要通过一种机制筛选出最有代表性的人，在共识算法中就是筛选出具有代表性的节点。</p>
<p>那如何筛选呢？其实就是设置一组条件，就像筛选尖子生一样，给一组指标让大家来完成，谁能更好地完成指标，谁就能有机会被选上。在区块链系统中，存在着多种这样的筛选方案，比如PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）、PoW（Proof of Work，工作量证明）、PoS（Proof of Stake，权益证明）、DPoS（Delegate Proof of Stake，委托权益证明）、Ripple（瑞波）等，各种不同的算法，其实就是不同的游戏玩法。</p>
<h1 id="一-拜占庭容错技术（Byzantine-Fault-Tolerance，BFT）"><a href="#一-拜占庭容错技术（Byzantine-Fault-Tolerance，BFT）" class="headerlink" title="一.拜占庭容错技术（Byzantine Fault Tolerance，BFT）"></a>一.拜占庭容错技术（Byzantine Fault Tolerance，BFT）</h1><p>拜占庭容错技术（Byzantine Fault Tolerance，BFT）是一类分布式计算领域的容错技术。拜占庭假设是对现实世界的模型化，由于硬件错误、网络拥塞或中断以及遭到恶意攻击等原因，计算机和网络可能出现不可预料的行为。拜占庭容错技术被设计用来处理这些异常行为，并满足所要解决的问题的规范要求。</p>
<p>在分布式系统中，特别是在区块链网络环境中，也和拜占庭将军的环境类似，有运行正常的服务器（类似忠诚的拜占庭将军），有故障的服务器，还有破坏者的服务器（类似叛变的拜占庭将军）。共识算法的核心是在正常的节点间形成对网络状态的共识。</p>
<p>通常，这些发生故障节点被称为拜占庭节点，而正常的节点即为非拜占庭节点。</p>
<p>拜占庭容错系统是一个拥有n台节点的系统，整个系统对于每一个请求，满足以下条件：</p>
<ol>
<li>所有非拜占庭节点使用相同的输入信息，产生同样的结果；</li>
<li>如果输入的信息正确，那么所有非拜占庭节点必须接收这个信息，并计算相应的结果。</li>
</ol>
<p>拜占庭系统普遍采用的假设条件包括：</p>
<ol>
<li>拜占庭节点的行为可以是任意的，拜占庭节点之间可以共谋；</li>
<li>节点之间的错误是不相关的；</li>
<li>节点之间通过异步网络连接，网络中的消息可能丢失、乱序并延时到达，但大部分协议假设消息在有限的时间里能传达到目的地；</li>
<li>服务器之间传递的信息，第三方可以嗅探到，但是不能篡改、伪造信息的内容和验证信息的完整性。</li>
</ol>
<p>原始的拜占庭容错系统由于需要展示其理论上的可行性而缺乏实用性。另外，还需要额外的时钟同步机制支持，算法的复杂度也是随节点增加而指数级增加。</p>
<h1 id="二-PBFT：Practical-Byzantine-Fault-Tolerance，实用拜占庭容错算法。"><a href="#二-PBFT：Practical-Byzantine-Fault-Tolerance，实用拜占庭容错算法。" class="headerlink" title="二.PBFT：Practical Byzantine Fault Tolerance，实用拜占庭容错算法。"></a>二.PBFT：Practical Byzantine Fault Tolerance，实用拜占庭容错算法。</h1><p>实用拜占庭容错系统（PBFT）降低了拜占庭协议的运行复杂度，从指数级别降低到多项式级别（Polynomial），使拜占庭协议在分布式系统中应用成为可能。</p>
<p>PBFT是一种状态机副本复制算法，即服务作为状态机进行建模，状态机在分布式系统的不同节点进行副本复制。每个状态机的副本都保存了服务的状态，同时也实现了服务的操作。将所有的副本组成的集合使用大写字母R表示，使用0到|R|-1的整数表示每一个副本。为了描述方便，通常假设故障节点数为m个，整个服务节点数为|R|=3m+1个，这里m是有可能失效的副本的最大个数。尽管可以存在多于3m+1个副本，但是额外的副本除了降低性能之外不能提高可靠性。</p>
<p>PBFT要求共同维护一个状态，所有节点采取的行动一致。为此，需要运行三类基本协议，包括一致性协议、检查点协议和视图更换协议。我们主要关注支持系统日常运行的一致性协议。一致性协议至少包含若干个阶段：请求（request）、序号分配（pre-prepare）和响应（reply）。根据协议设计的不同，可能包含相互交互（prepare），序号确认（commit）等阶段。</p>
<p>上图为PBFT协议通信模式，每一个客户端的请求需要经过5个阶段，通过采用两次两两交互的方式在服务器达成一致之后再执行客户端的请求。由于客户端不能从服务器端获得任何服务器运行状态的信息，PBFT中主节点是否发生错误只能由服务器监测。如果服务器在一段时间内都不能完成客户端的请求，则会触发视图更换协议。其中C为客户端，N0~N3表示服务节点，特别的，N0为主节点，N3为故障节点。整个协议的基本过程如下：</p>
<p>1）客户端发送请求，激活主节点的服务操作。</p>
<p>2）当主节点接收请求后，启动三阶段的协议以向各从节点广播请求。</p>
<p>［2.1］序号分配阶段，主节点给请求赋值一个序列号n，广播序号分配消息和客户端的请求消息m，并将构造PRE-PREPARE消息给各从节点；</p>
<p>［2.2］交互阶段，从节点接收PRE-PREPARE消息，向其他服务节点广播PREPARE消息；</p>
<p>［2.3］序号确认阶段，各节点对视图内的请求和次序进行验证后，广播COMMIT消息，执行收到的客户端的请求并给客户端以响应。</p>
<p>3）客户端等待来自不同节点的响应，若有m+1个响应相同，则该响应即为运算的结果。</p>
<p>　　PBFT在很多场景都有应用，在区块链场景中，一般适合于对强一致性有要求的私有链和联盟链场景。例如，在IBM主导的区块链超级账本项目中，PBFT是一个可选的共识协议。在Hyperledger的Fabric项目中，共识模块被设计成可插拔的模块，支持像PBFT、Raft等共识算法。</p>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Flyweight_Pattern/</url>
    <content><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>数据库连接池</li>
<li>如果一个应用程序使用了大量的对象，而这些对象造成了很大的存储开销的时候就可以考虑是否可以使用享元模式。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="享元模式-1"><a href="#享元模式-1" class="headerlink" title="享元模式"></a>享元模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightBase</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">offer</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;享元基类&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span>(<span class="params">FlyweightBase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;共享享元类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_price</span>(<span class="params">self, price</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;产品类型：&#123;&#125; 详情：&#123;&#125;&#x27;</span>.format(self.name, price))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryFlyweight</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;享元工厂类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.product = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Getproduct</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.product.get(key, <span class="literal">None</span>):</span><br><span class="line">            self.product[key] = Flyweight(key)</span><br><span class="line">        <span class="keyword">return</span> self.product[key]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = FactoryFlyweight()</span><br><span class="line">    A = test.Getproduct(<span class="string">&quot;高端&quot;</span>)</span><br><span class="line">    A.get_price(<span class="string">&quot;香水：80&quot;</span>)</span><br><span class="line">    B = test.Getproduct(<span class="string">&quot;高端&quot;</span>)</span><br><span class="line">    B.get_price(<span class="string">&quot;面膜：800&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">产品类型：高端 详情：香水：80</span></span><br><span class="line"><span class="string">产品类型：高端 详情：面膜：800</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Interpreter_Pattern/</url>
    <content><![CDATA[<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>开发者自定义一种“有内涵”的语言（或者叫字符串），并设定相关的解释规则，输入该字符串后可以输出公认的解释，或者执行程序可以理解的动作。这种模式被用在 SQL 解析、符号处理引擎等</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="解释器模式-1"><a href="#解释器模式-1" class="headerlink" title="解释器模式"></a>解释器模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="string">&quot;&quot;&quot;实现一段简单的中文编程&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Code</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义语言&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, text=None</span>):</span></span><br><span class="line">        self.text = text</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterpreterBase</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;自定义解释器基类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, code</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Interpreter</span>(<span class="params">InterpreterBase</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;实现解释器方法，实现终结符表达式字典&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self, code</span>):</span></span><br><span class="line">        code = code.text</span><br><span class="line">        code_dict = &#123;<span class="string">&#x27;获取当前时间戳&#x27;</span>: time.time(), <span class="string">&quot;获取当前日期&quot;</span>: datetime.datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)&#125;</span><br><span class="line">        print(code_dict.get(code))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = Code()</span><br><span class="line">    test.text = <span class="string">&#x27;获取当前时间戳&#x27;</span></span><br><span class="line">    data1 = Interpreter().run(test)</span><br><span class="line">    test.text = <span class="string">&#x27;获取当前日期&#x27;</span></span><br><span class="line">    data2 = Interpreter().run(test)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">-----------------</span></span><br><span class="line"><span class="string">1550156061.1181707</span></span><br><span class="line"><span class="string">2019-02-14 22:54:21</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="解释器模式要实现两个核心角色："><a href="#解释器模式要实现两个核心角色：" class="headerlink" title="解释器模式要实现两个核心角色："></a>解释器模式要实现两个核心角色：</h2><ul>
<li><p>终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。</p>
</li>
<li><p>非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Factory_Pattern/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通过一个指定的“工厂”获得需要的“产品”，在设计模式中主要用于抽象对象的创建过程，让用户可以指定自己想要的对象而不必关心对象的实例化过程。这样做的好处是用户只需通过固定的接口而不是直接去调用类的实例化方法来获得一个对象的实例，隐藏了实例创建过程的复杂度，解耦了生产实例和使用实例的代码，降低了维护的复杂性。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>简单工厂模式适用于需创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂的情况下，而且用户只关心那种类型的实例被创建，并不关心其初始化过程时，比如多种数据库(MySQL/MongoDB)的实例，多种格式文件的解析器(XML/JSON)等。</p>
<p>工厂方法模式继承了简单工厂模式的优点又有所改进，其不再通过一个工厂类来负责所有产品的创建，而是将具体创建工作交给相应的子类去做，这使得工厂方法模式可以允许系统能够更高效的扩展。实际应用中可以用来实现系统的日志系统等，比如具体的程序运行日志，网络日志，数据库日志等都可以用具体的工厂类来创建。</p>
<p>抽象工厂模式在工厂方法基础上扩展了工厂对多个产品创建的支持，更适合一些大型系统，比如系统中有多于一个的产品族，且这些产品族类的产品需实现同样的接口，像很多软件系统界面中不同主题下不同的按钮、文本框、字体等等。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mercedes</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;梅赛德斯</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mercedes-Benz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宝马</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BMW&quot;</span></span><br><span class="line"><span class="comment"># ====================</span></span><br><span class="line">mercedes = Mercedes()</span><br><span class="line">bmw = BMW()</span><br></pre></td></tr></table></figure>


<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>虽然有了一个简单的工厂，但在实际使用工厂的过程中，我们会发现新问题：如果我们要新增一个“产品”，例如<code>Audi</code>的汽车，我们除了新增一个<code>Audi</code>类外还要修改<code>SimpleCarFactory</code>内的<code>product_car</code>方法。这样就违背了软件设计中的开闭原则，即在扩展新的类时，尽量不要修改原有代码。所以我们在简单工厂的基础上把<code>SimpleCarFactory</code>抽象成不同的工厂，每个工厂对应生成自己的产品，这就是工厂方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;抽象工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MercedesFactory</span>(<span class="params">AbstractFactory</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;梅赛德斯工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Mercedes()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span>(<span class="params">AbstractFactory</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宝马工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> BMW()</span><br><span class="line"><span class="comment"># ==================</span></span><br><span class="line">c1 = MercedesFactory().product_car()</span><br><span class="line">c2 = BMWFactory().product_car()</span><br></pre></td></tr></table></figure>

<p>每个工厂负责生产自己的产品也避免了我们在新增产品时需要修改工厂的代码，而只要增加相应的工厂即可。如新增一个Audi产品，只需新增一个<strong>Mouse</strong>类和<strong>MouseFactory</strong></p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种小汽车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mercedes_C63</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;梅赛德斯 C63</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mercedes-Benz: C63&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW_M3</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宝马 M3</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BMW: M3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#　两种SUV</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mercedes_G63</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;梅赛德斯 G63</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mercedes-Benz: G63&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW_X5</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宝马 X5</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;BMW: X5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;抽象工厂</span></span><br><span class="line"><span class="string">    可以生产小汽车外，还可以生产SUV</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    __metaclass__ = abc.ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_suv</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MercedesFactory</span>(<span class="params">AbstractFactory</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;梅赛德斯工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Mercedes_C63()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_suv</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Mercedes_G63()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMWFactory</span>(<span class="params">AbstractFactory</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宝马工厂</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_car</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> BMW_M3()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">product_suv</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> BMW_X5()</span><br><span class="line"><span class="comment"># ====================</span></span><br><span class="line">c1 = MercedesFactory().product_car()</span><br><span class="line">s1 = MercedesFactory().product_suv()</span><br><span class="line">print(c1, s1)</span><br><span class="line">s2 = BMWFactory().product_suv()</span><br><span class="line">c2 = BMWFactory().product_car()</span><br><span class="line">print(c2, s2)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Facade_Pattern/</url>
    <content><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。</li>
<li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="外观模式-1"><a href="#外观模式-1" class="headerlink" title="外观模式"></a>外观模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">API1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Save</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;保存数据A&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Del</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;删除数据A&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">API2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Save</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;保存数据B&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Del</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;删除数据B&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Facade</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._api1 = API1()</span><br><span class="line">        self._api2 = API2()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SaveAll</span>(<span class="params">self</span>):</span></span><br><span class="line">        [obj.Save() <span class="keyword">for</span> obj <span class="keyword">in</span> [self._api1, self._api2]]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">DelAll</span>(<span class="params">self</span>):</span></span><br><span class="line">        [obj.Save() <span class="keyword">for</span> obj <span class="keyword">in</span> [self._api1, self._api2]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = Facade()</span><br><span class="line">    test.SaveAll()</span><br><span class="line">    test.DelAll()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">保存数据A</span></span><br><span class="line"><span class="string">保存数据B</span></span><br><span class="line"><span class="string">删除数据A</span></span><br><span class="line"><span class="string">删除数据B</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式python实现</title>
    <url>/2019/11/25/design_pattern/python/Decorator_Pattern/</url>
    <content><![CDATA[<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>当用于实现横切关注点</li>
<li>数据校验</li>
<li>事务处理（这里的事务类似于数据库事务，意味着要么所有步骤都成功完成，要么事务失败） 缓存</li>
<li>日志</li>
<li>监控</li>
<li>调试</li>
<li>业务规则</li>
<li>压缩</li>
<li>加密</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="装饰器模式-1"><a href="#装饰器模式-1" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>修饰器模式和Python修饰器之间并不是一对一的等价关系。Python修饰器能做的实际上比修饰器模式多得多，其中之一就是实现修饰器模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makebold</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="keyword">return</span> getwrapped(fn, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeitalic</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="keyword">return</span> getwrapped(fn, <span class="string">&quot;i&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getwrapped</span>(<span class="params">fn, tag</span>):</span></span><br><span class="line"><span class="meta">    @wraps(fn)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span>():</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;</span> % (tag, fn(), tag)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@makebold</span></span><br><span class="line"><span class="meta">@makeitalic</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;a decorated hello world&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(<span class="string">&#x27;result:&#123;&#125;   name:&#123;&#125;   doc:&#123;&#125;&#x27;</span>.format(hello(), hello.__name__, hello.__doc__))</span><br><span class="line"></span><br><span class="line"><span class="comment">### OUTPUT ###</span></span><br><span class="line"><span class="comment"># result:&lt;b&gt;&lt;i&gt;hello world&lt;/i&gt;&lt;/b&gt;   name:hello   doc:a decorated hello world</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;original f1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;original f2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo_decorator</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, decoratee</span>):</span></span><br><span class="line">        self._decoratee = decoratee</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;decorated f1&quot;</span>)</span><br><span class="line">        self._decoratee.f1()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._decoratee, name) <span class="comment"># 这个不是delegation么</span></span><br><span class="line"></span><br><span class="line">u = foo()</span><br><span class="line">v = foo_decorator(u)</span><br><span class="line">v.f1()</span><br><span class="line">v.f2()</span><br><span class="line"></span><br><span class="line"><span class="comment">#decorated f1</span></span><br><span class="line"><span class="comment">#original f1</span></span><br><span class="line"><span class="comment">#original f2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>RAID 磁盘阵列介绍</title>
    <url>/2019/09/26/linux/raid/</url>
    <content><![CDATA[<h1 id="磁盘阵列（Redundant-Arrays-of-Independent-Disks，RAID）"><a href="#磁盘阵列（Redundant-Arrays-of-Independent-Disks，RAID）" class="headerlink" title="磁盘阵列（Redundant Arrays of Independent Disks，RAID）"></a>磁盘阵列（Redundant Arrays of Independent Disks，RAID）</h1><ol>
<li><p>存储的数据一定分片；</p>
</li>
<li><p>分基于软件的软RAID（如mdadm）和基于硬件的硬RAID（如RAID卡）；</p>
</li>
<li><p>RAID卡如同网卡一样有集成板载的也有独立的(PCI-e)，一般独立RAID卡性能相对较好，淘宝一搜便可看到他们的原形；</p>
</li>
<li><p>现在基本上服务器都原生硬件支持几种常用的RAID;</p>
</li>
<li><p>当然还有更加高大上的专用于存储的磁盘阵列柜产品，有专用存储技术，规格有如12/24/48盘一柜等，盘可选机械/固态，3.5/2.5寸等。</p>
<a id="more"></a>

</li>
</ol>
<table>
<thead>
<tr>
<th><strong>级别</strong></th>
<th><strong>特征</strong></th>
<th><strong>原理</strong></th>
<th><strong>单元</strong></th>
<th><strong>冗余</strong></th>
<th><strong>性能</strong></th>
<th><strong>利用率</strong></th>
<th><strong>最多坏</strong></th>
<th><strong>用途</strong></th>
<th><strong>缺陷</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RAID0</td>
<td>条带</td>
<td>分片分散存入2块硬盘</td>
<td>2</td>
<td>否</td>
<td>读写速度2倍</td>
<td>100%</td>
<td>0/2</td>
<td>SWAP/TMP</td>
<td>不冗余，数据难恢复</td>
</tr>
<tr>
<td>RAID1</td>
<td>镜像</td>
<td>相同数据存入2块硬盘</td>
<td>2</td>
<td>是</td>
<td>写速度不变读速度2倍</td>
<td>50%</td>
<td>1/2</td>
<td>数据备份</td>
<td>读写速度没加，利用率低</td>
</tr>
<tr>
<td>RAID4</td>
<td>校验</td>
<td>分片分散存入2块硬盘校验码存入第3块硬盘</td>
<td>3</td>
<td>是</td>
<td>读写速度2倍</td>
<td>2/3=66%</td>
<td>1/3</td>
<td>用的很少</td>
<td>1. 坏盘时另外2块需要重新计算还原坏盘数据2. 校验码盘压力大成为瓶颈</td>
</tr>
<tr>
<td>RAID5</td>
<td>校验</td>
<td>分片和校验码混合存储</td>
<td>3</td>
<td>是</td>
<td>读写速度2倍</td>
<td>2/3=66%</td>
<td>1/3</td>
<td>用的不多</td>
<td>坏盘时另外2块需要重新计算还原坏盘数据</td>
</tr>
<tr>
<td>RAID6</td>
<td>校验</td>
<td>分片盘校验码盘分别2个数据分片校验码计算2次</td>
<td>4</td>
<td>是</td>
<td>读写速度2倍</td>
<td>2/4</td>
<td>2/41∈2</td>
<td>用的很少</td>
<td>“部队中有一半是搞后勤的，感觉还是不太爽。”</td>
</tr>
<tr>
<td>RAID10</td>
<td>1+0</td>
<td>2块硬盘1组先做RAID1多组RAID1再做RAID0</td>
<td>4</td>
<td>是</td>
<td>读写速度N倍N为组数</td>
<td>2/4</td>
<td>2/41∈2</td>
<td>用的最多</td>
<td>-</td>
</tr>
<tr>
<td>RAID50</td>
<td>5+0</td>
<td>3块硬盘1组先做RAID5多组再做RAID0</td>
<td>6</td>
<td>是</td>
<td>读写数读2N倍N为组数</td>
<td>4/6</td>
<td>2/61∈3</td>
<td>土豪用的</td>
<td>“好是好，就是贵！”</td>
</tr>
</tbody></table>
<h2 id="一、RAID模式优缺点的简要介绍"><a href="#一、RAID模式优缺点的简要介绍" class="headerlink" title="一、RAID模式优缺点的简要介绍"></a>一、RAID模式优缺点的简要介绍</h2><p> 目前被运用较多的RAID模式其优缺点大致是这样的：</p>
<h3 id="1、RAID0模式"><a href="#1、RAID0模式" class="headerlink" title="1、RAID0模式"></a>1、RAID0模式</h3><blockquote>
<p>优点：在RAID 0状态下，存储数据被分割成两部分，分别存储在两块硬盘上，此时移动硬盘的理论存储速度是单块硬盘的2倍，实际容量等于两块硬盘中较小一块硬盘的容量的2倍。</p>
</blockquote>
<blockquote>
<p>缺点：任何一块硬盘发生故障，整个RAID上的数据将不可恢复。</p>
</blockquote>
<blockquote>
<p>备注：存储高清电影比较适合。</p>
</blockquote>
<h3 id="2、RAID1模式"><a href="#2、RAID1模式" class="headerlink" title="2、RAID1模式"></a>2、RAID1模式</h3><blockquote>
<p>优点：此模式下，两块硬盘互为镜像。当一个硬盘受损时，换上一块全新硬盘(大于或等于原硬盘容量)替代原硬盘即可自动恢复资料和继续使用，移动硬盘的实际容量等于较小一块硬盘的容量，存储速度与单块硬盘相同。RAID 1的优势在于任何一块硬盘出现故障是，所存储的数据都不会丢失。</p>
</blockquote>
<blockquote>
<p>缺点：该模式可使用的硬盘实际容量比较小，仅仅为两颗硬盘中最小硬盘的容量。</p>
</blockquote>
<blockquote>
<p>备注：非常重要的资料，如数据库，个人资料，是万无一失的存储方案。</p>
</blockquote>
<h3 id="3、RAID-0-1模式"><a href="#3、RAID-0-1模式" class="headerlink" title="3、RAID 0+1模式"></a>3、RAID 0+1模式</h3><blockquote>
<p>RAID 0+1是磁盘分段及镜像的结合，采用2组RAID0的磁盘阵列互为镜像，它们之间又成为一个RAID1的阵列。硬盘使用率只有50%，但是提供最佳的速度及可靠度。</p>
</blockquote>
<h3 id="4、RAID-3模式"><a href="#4、RAID-3模式" class="headerlink" title="4、RAID 3模式"></a>4、RAID 3模式</h3><blockquote>
<p>RAID3是把数据分成多个“块”，按照一定的容错算法，存放在N+1个硬盘上，实际数据占用的有效空间为N个硬盘的空间总和，而第N+1个硬盘存储的数据是校验容错信息，当这N+1个硬盘中的其中一个硬盘出现故障时，从其它N个硬盘中的数据也可以恢复原始数据。</p>
</blockquote>
<h3 id="5、RAID-5模式"><a href="#5、RAID-5模式" class="headerlink" title="5、RAID 5模式"></a>5、RAID 5模式</h3><blockquote>
<p>RAID5不对存储的数据进行备份，而是把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。</p>
</blockquote>
<h3 id="6、RAID-10模式"><a href="#6、RAID-10模式" class="headerlink" title="6、RAID 10模式"></a>6、RAID 10模式</h3><blockquote>
<p>RAID10最少需要4块硬盘才能完成。把2块硬盘组成一个RAID1，然后两组RAID1组成一个RAID0。虽然RAID10方案造成了50%的磁盘浪费，但是它提供了200%的速度和单磁盘损坏的数据安全性。</p>
</blockquote>
<h2 id="二、另外三种硬件快速硬件设置模式简介"><a href="#二、另外三种硬件快速硬件设置模式简介" class="headerlink" title="二、另外三种硬件快速硬件设置模式简介"></a>二、另外三种硬件快速硬件设置模式简介</h2><p>在收集资料时看到有的硬件设备提供快速磁盘模式设置，也很方便大家的使用，具体情况如下：</p>
<h3 id="1、Clone模式"><a href="#1、Clone模式" class="headerlink" title="1、Clone模式"></a>1、Clone模式</h3><p>克隆模式，磁盘全部数据一样，以最小硬盘的为准。</p>
<h3 id="2、Large模式"><a href="#2、Large模式" class="headerlink" title="2、Large模式"></a>2、Large模式</h3><p>硬盘容量简单相加，将几个硬盘变成一个硬盘，容量为几个硬盘容量之和，此模式下可以获得最大的硬盘空间。</p>
<h3 id="3、Normal模式"><a href="#3、Normal模式" class="headerlink" title="3、Normal模式"></a>3、Normal模式</h3><p>硬盘分别处于正常、独立的状态，可以分别独立的写入或读取资料，能使用的实际容量分别为4个硬盘的容量。如果其中一个硬盘受损，其他几个硬盘不会受影响。</p>
<h2 id="三、RAID使用简明注意事项"><a href="#三、RAID使用简明注意事项" class="headerlink" title="三、RAID使用简明注意事项"></a>三、RAID使用简明注意事项</h2><blockquote>
<p>使用前请先备份硬盘的资料，一旦进行RAID设定或是变更RAID模式，将会清除硬盘里的所有资料，以及无法恢复；</p>
</blockquote>
<blockquote>
<p>建立RAID时，建议使用相同品牌、型号和容量的硬盘，以确保性能和稳定；</p>
</blockquote>
<blockquote>
<p>请勿随意更换或取出硬盘，如果取出了硬盘，请记下硬盘放入两个仓位的顺序不得更改，以及请勿只插入某一块硬盘使用，以避免造成资料损坏或丢失；</p>
</blockquote>
<blockquote>
<p>如果旧硬盘曾经在RAID模式下使用，请先进清除硬盘RAID信息，让硬盘回复至出厂状态，以免RAID建立失败；</p>
</blockquote>
<blockquote>
<p>RAID0模式下，其中一个硬盘损坏时，其它硬盘所有资料都将丢失；</p>
</blockquote>
<blockquote>
<p>RAID1模式下，如果某一块硬盘受损，可以用一块大于或等于受损硬盘容量的新硬盘替换坏硬盘然后开机即可自动恢复和修复资料以及RAID模式。此过程需要一定时间，请耐心等待</p>
</blockquote>
<h2 id="四、细数RAID模式"><a href="#四、细数RAID模式" class="headerlink" title="四、细数RAID模式"></a>四、细数RAID模式</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>磁盘阵列（Redundant Arrays of Inexpensive Disks，RAID），有“价格便宜且多余的磁盘阵列”之意。原理是利用数组方式来作磁盘组，配合数据分散排列的设计，提升数据的安全性。磁盘阵列是由很多便宜、容量较小、稳定性较高、速度较慢磁盘，组合成一个大型的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。同时利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。磁盘阵列还能利用同位检查（Parity Check）的观念，在数组中任一颗硬盘故障时，仍可读出数据，在数据重构时，将数据经计算后重新置入新硬盘中。</p>
<h3 id="2、规范"><a href="#2、规范" class="headerlink" title="2、规范"></a>2、规范</h3><p>RAID技术主要包含RAID 0～RAID 50等数个规范，它们的侧重点各不相同，常见的规范有如下几种：</p>
<blockquote>
<p>RAID 0：RAID 0连续以位或字节为单位分割数据，并行读/写于多个磁盘上，因此具有很高的数据传输率，但它没有数据冗余，因此并不能算是真正的RAID结构。RAID 0只是单纯地提高性能，并没有为数据的可靠性提供保证，而且其中的一个磁盘失效将影响到所有数据。因此，RAID 0不能应用于数据安全性要求高的场合。</p>
</blockquote>
<blockquote>
<p>RAID 1：它是通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据。当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能。RAID 1是磁盘阵列中单位成本最高的，但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。</p>
</blockquote>
<blockquote>
<p>RAID 0+1: 也被称为RAID 10标准，实际是将RAID 0和RAID 1标准结合的产物，在连续地以位或字节为单位分割数据并且并行读/写多个磁盘的同时，为每一块磁盘作磁盘镜像进行冗余。它的优点是同时拥有RAID 0的超凡速度和RAID 1的数据高可靠性，但是CPU占用率同样也更高，而且磁盘的利用率比较低。</p>
</blockquote>
<blockquote>
<p>RAID 2：将数据条块化地分布于不同的硬盘上，条块单位为位或字节，并使用称为“加重平均纠错码（海明码）”的编码技术来提供错误检查及恢复。这种编码技术需要多个磁盘存放检查及恢复信息，使得RAID 2技术实施更复杂，因此在商业环境中很少使用。</p>
</blockquote>
<blockquote>
<p>RAID 3：它同RAID 2非常类似，都是将数据条块化分布于不同的硬盘上，区别在于RAID 3使用简单的奇偶校验，并用单块磁盘存放奇偶校验信息。如果一块磁盘失效，奇偶盘及其他数据盘可以重新产生数据；如果奇偶盘失效则不影响数据使用。RAID 3对于大量的连续数据可提供很好的传输率，但对于随机数据来说，奇偶盘会成为写操作的瓶颈。</p>
</blockquote>
<blockquote>
<p>RAID 4：RAID 4同样也将数据条块化并分布于不同的磁盘上，但条块单位为块或记录。RAID 4使用一块磁盘作为奇偶校验盘，每次写操作都需要访问奇偶盘，这时奇偶校验盘会成为写操作的瓶颈，因此RAID 4在商业环境中也很少使用。</p>
</blockquote>
<blockquote>
<p>RAID 5：RAID 5不单独指定的奇偶盘，而是在所有磁盘上交叉地存取数据及奇偶校验信息。在RAID 5上，读/写指针可同时对阵列设备进行操作，提供了更高的数据流量。RAID 5更适合于小数据块和随机读写的数据。RAID 3与RAID 5相比，最主要的区别在于RAID 3每进行一次数据传输就需涉及到所有的阵列盘；而对于RAID 5来说，大部分数据传输只对一块磁盘操作，并可进行并行操作。在RAID 5中有“写损失”，即每一次写操作将产生四个实际的读/写操作，其中两次读旧的数据及奇偶信息，两次写新的数据及奇偶信息。</p>
</blockquote>
<blockquote>
<p>RAID 6：与RAID 5相比，RAID 6增加了第二个独立的奇偶校验信息块。两个独立的奇偶系统使用不同的算法，数据的可靠性非常高，即使两块磁盘同时失效也不会影响数据的使用。但RAID 6需要分配给奇偶校验信息更大的磁盘空间，相对于RAID 5有更大的“写损失”，因此“写性能”非常差。较差的性能和复杂的实施方式使得RAID 6很少得到实际应用。</p>
</blockquote>
<blockquote>
<p>RAID 7：这是一种新的RAID标准，其自身带有智能化实时操作系统和用于存储管理的软件工具，可完全独立于主机运行，不占用主机CPU资源。RAID 7可以看作是一种存储计算机（Storage Computer），它与其他RAID标准有明显区别。除了以上的各种标准（如表1），我们可以如RAID 0+1那样结合多种RAID规范来构筑所需的RAID阵列，例如RAID 5+3（RAID 53）就是一种应用较为广泛的阵列形式。用户一般可以通过灵活配置磁盘阵列来获得更加符合其要求的磁盘存储系统。</p>
</blockquote>
<blockquote>
<p>RAID 5E(RAID 5 Enhencement): RAID 5E是在RAID 5级别基础上的改进，与RAID 5类似，数据的校验信息均匀分布在各硬盘上，但是，在每个硬盘上都保留了一部分未使用的空间，这部分空间没有进行条带化，最多允许两块物理硬盘出现故障。看起来，RAID 5E和RAID 5加一块热备盘好象差不多，其实由于RAID 5E是把数据分布在所有的硬盘上，性能会比RAID5 加一块热备盘要好。当一块硬盘出现故障时，有故障硬盘上的数据会被压缩到其它硬盘上未使用的空间，逻辑盘保持RAID 5级别。</p>
</blockquote>
<blockquote>
<p>RAID 5EE: 与RAID 5E相比，RAID 5EE的数据分布更有效率，每个硬盘的一部分空间被用作分布的热备盘，它们是阵列的一部分，当阵列中一个物理硬盘出现故障时，数据重建的速度会更快。</p>
</blockquote>
<blockquote>
<p>RAID 50：RAID50是RAID5与RAID0的结合。此配置在RAID5的子磁盘组的每个磁盘上进行包括奇偶信息在内的数据的剥离。每个RAID5子磁盘组要求三个硬盘。RAID50具备更高的容错能力，因为它允许某个组内有一个磁盘出现故障，而不会造成数据丢失。而且因为奇偶位分部于RAID5子磁盘组上，故重建速度有很大提高。优势：更高的容错能力，具备更快数据读取速率的潜力。需要注意的是：磁盘故障会影响吞吐量。故障后重建信息的时间比镜像配置情况下要长。</p>
</blockquote>
<h3 id="3、优点"><a href="#3、优点" class="headerlink" title="3、优点"></a>3、优点</h3><p>提高传输速率。RAID通过在多个磁盘上同时存储和读取数据来大幅提高存储系统的数据吞吐量（Throughput）。在RAID中，可以让很多磁盘驱动器同时传输数据，而这些磁盘驱动器在逻辑上又是一个磁盘驱动器，所以使用RAID可以达到单个磁盘驱动器几倍、几十倍甚至上百倍的速率。这也是RAID最初想要解决的问题。因为当时CPU的速度增长很快，而磁盘驱动器的数据传输速率无法大幅提高，所以需要有一种方案解决二者之间的矛盾。RAID最后成功了。</p>
<p>通过数据校验提供容错功能。普通磁盘驱动器无法提供容错功能，如果不包括写在磁盘上的CRC（循环冗余校验）码的话。RAID容错是建立在每个磁盘驱动器的硬件容错功能之上的，所以它提供更高的安全性。在很多RAID模式中都有较为完备的相互校验/恢复的措施，甚至是直接相互的镜像备份，从而大大提高了RAID系统的容错度，提高了系统的稳定冗余性。</p>
<h3 id="4、实现"><a href="#4、实现" class="headerlink" title="4、实现"></a>4、实现</h3><p>磁盘阵列有两种方式可以实现，那就是“软件阵列”与“硬件阵列”。</p>
<p>软件阵列是指通过网络操作系统自身提供的磁盘管理功能将连接的普通SCSI卡上的多块硬盘配置成逻辑盘，组成阵列。软件阵列可以提供数据冗余功能，但是磁盘子系统的性能会有所降低，有的降低幅度还比较大，达30%左右。</p>
<p>硬件阵列是使用专门的磁盘阵列卡来实现的。硬件阵列能够提供在线扩容、动态修改阵列级别、自动数据恢复、驱动器漫游、超高速缓冲等功能。它能提供性能、数据保护、可靠性、可用性和可管理性的解决方案。阵列卡专用的处理单元来进行操作，它的性能要远远高于常规非阵列硬盘，并且更安全更稳定。</p>
<p>磁盘阵列其实也分为软阵列 (Software Raid)和硬阵列 (Hardware Raid) 两种. 软阵列即通过软件程序并由计算机的 CPU提供运行能力所成. 由于软件程式不是一个完整系统故只能提供最基本的 RAID容错功能. 其他如热备用硬盘的设置, 远程管理等功能均一一欠奉. 硬阵列是由独立操作的硬件提供整个磁盘阵列的控制和计算功能. 不依靠系统的CPU资源.</p>
<p>由于硬阵列是一个完整的系统, 所有需要的功能均可以做进去. 所以硬阵列所提供的功能和性能均比软阵列好. 而且, 如果你想把系统也做到磁盘阵列中, 硬阵列是唯一的选择. 故我们可以看市场上 RAID 5 级的磁盘阵列均为硬阵列. 软 阵列只适用于 Raid 0 和 Raid 1. 对于我们做镜像用的镜像塔, 肯定不会用 Raid 0或 Raid 1。作为高性能的存储系统，已经得到了越来越广泛的应用。RAID的级别从RAID概念的提出到现在，已经发展了六个级别，其级别分别是0、1、2、3、4、5等。但是最常用的是0、1、3、5四个级别。</p>
<h2 id="五、个人用户该选那种RAID模式"><a href="#五、个人用户该选那种RAID模式" class="headerlink" title="五、个人用户该选那种RAID模式"></a>五、个人用户该选那种RAID模式</h2><p>首先要分析清楚，我们需要存储的文件有什么样的属性。这其中需要大量存储的和占用存储量大的文件是两回事儿。</p>
<p>从使用角度粗略分，个人需要存储的文件大致有文本文件、照片录像、影音文件、应用程序等。</p>
<ol>
<li>文本文件：大量长期存放，阶段性更新，但其占用空间小，安全性要求个别较高，大部分一般；</li>
<li>照片录像：大量长期存放，永久性记录，占用空间大，安全性要求高，一旦损失很难弥补；</li>
<li>影音文件：一部分大量长期存放，一部分大量短期存放，阶段性更新，占用空间大，安全性要求一般，即便损失了，也可以再从网络上下载恢复；</li>
<li>应用程序：这其中包括一些软件和硬件的驱动等，对于软件，目前基本可以从网络上获得，驱动程序有时需要预先备份，安装设备时随时可用，属于量少但要长期存放的，阶段性更新，安全性要求一般。</li>
</ol>
<p>看看自己需要对哪种类型的文件进行存储，再选择自己需要的RAID模式即可。</p>
<p>本人的照片和私人录影资料较多，平时喜欢收集APE等无损格式的音乐文件，对于个人来说这都是至宝，不可有所损失，再有就是一些硬件的驱动程序，相对比较重要，另外会编辑少量的个人文件，阶段性比较重要，最后是影片，看完也就删除了，不太重要。而照片录像和无损音乐占用的空间又是巨大的，安全性要求又很高，权衡后，在节约资金确保安全的前提下，准备购置五块大容量硬盘，组成NAS存储服务器，选择RAID5模式。</p>
<p>顺便说，购置五快硬盘的原因还有一个，就是我使用的是老机箱改造NAS服务器，市面上有3转5的硬盘笼子可以简单将原有的3个光驱位变成5块硬盘的存储位，考虑到家用存储8T的容量已经足够了，10T基本上可以无忧了，所以选择了5块硬盘，每块2T容量。当然组成RAOD5后会少于10T，那也足够了！</p>
<p>NAS的好处很多，这里就不在赘述，有兴趣的朋友建议深入了解。它既可以完成集中存储还可以完成诸如自动BT下载，网络打印机，苹果媒体服务器等众多私有云功能，是很好的家庭网络应用解决方案。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll多路复用介绍</title>
    <url>/2019/09/25/linux/epoll/</url>
    <content><![CDATA[<p>epoll是开发linux高性能服务器的必备技术至，epoll本质，是服务端程序员的必须掌握的知识。</p>
<a id="more"></a>
<h1 id="一、从网卡接收数据说起"><a href="#一、从网卡接收数据说起" class="headerlink" title="一、从网卡接收数据说起"></a>一、从网卡接收数据说起</h1><p>下图是一个典型的计算机结构图，计算机由CPU、存储器（内存）、网络接口等部件组成。了解epoll本质的第一步，要从硬件的角度看计算机怎样接收网络数据。</p>
<p><img src="/images/linux/epoll/epoll-1.jpg" alt="计算机结构图"></p>
<p>下图展示了网卡接收数据的过程。在①阶段，网卡收到网线传来的数据；经过②阶段的硬件电路的传输；最终将数据写入到内存中的某个地址上（③阶段）。这个过程涉及到DMA传输、IO通路选择等硬件有关的知识，但我们只需知道：<strong>网卡会把接收到的数据写入内存</strong>。</p>
<p><img src="/images/linux/epoll/epoll-2.jpg" alt="网卡接收数据的过程"></p>
<p>通过硬件传输，网卡接收的数据存放到内存中。操作系统就可以去读取它们。</p>
<h1 id="二、如何知道接收了数据？"><a href="#二、如何知道接收了数据？" class="headerlink" title="二、如何知道接收了数据？"></a>二、如何知道接收了数据？</h1><p>了解epoll本质的第二步，要从CPU的角度来看数据接收。要理解这个问题，要先了解一个概念——中断。</p>
<p>计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时（电容可以保存少许电量，供CPU运行很短的一小段时间），它应立即去保存数据，保存数据的程序具有较高的优先级。</p>
<p>一般而言，由硬件产生的信号需要cpu立马做出回应（不然数据可能就丢失），所以它的优先级很高。cpu理应中断掉正在执行的程序，去做出响应；当cpu完成对硬件的响应后，再重新执行用户程序。中断的过程如下图，和函数调用差不多。只不过函数调用是事先定好位置，而中断的位置由“信号”决定。</p>
<p><img src="/images/linux/epoll/epoll-3.jpg" alt="中断程序调用"></p>
<p>以键盘为例，当用户按下键盘某个按键时，键盘会给cpu的中断引脚发出一个高电平。cpu能够捕获这个信号，然后执行键盘中断程序。下图展示了各种硬件通过中断与cpu交互。</p>
<p><img src="/images/linux/epoll/epoll-4.jpg" alt="cpu中断"></p>
<p>现在可以回答本节提出的问题了：当网卡把数据写入到内存后，<strong>网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来</strong>，再通过网卡中断程序去处理数据。</p>
<h1 id="三、进程阻塞为什么不占用cpu资源？"><a href="#三、进程阻塞为什么不占用cpu资源？" class="headerlink" title="三、进程阻塞为什么不占用cpu资源？"></a>三、进程阻塞为什么不占用cpu资源？</h1><p>了解epoll本质的第三步，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select和epoll都是阻塞方法。了解“进程阻塞为什么不占用cpu资源？”，也就能够了解这一步。</p>
<p>为简单起见，我们从普通的recv接收开始分析，先看看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建socket</span><br><span class="line">int s &#x3D; socket(AF_INET, SOCK_STREAM, 0);   </span><br><span class="line">&#x2F;&#x2F;绑定</span><br><span class="line">bind(s, ...)</span><br><span class="line">&#x2F;&#x2F;监听</span><br><span class="line">listen(s, ...)</span><br><span class="line">&#x2F;&#x2F;接受客户端连接</span><br><span class="line">int c &#x3D; accept(s, ...)</span><br><span class="line">&#x2F;&#x2F;接收客户端数据</span><br><span class="line">recv(c, ...);</span><br><span class="line">&#x2F;&#x2F;将数据打印出来</span><br><span class="line">printf(...)</span><br></pre></td></tr></table></figure>

<p>这是一段最基础的网络编程代码，先新建socket对象，依次调用bind、listen、accept，最后调用recv接收数据。recv是个阻塞方法，当程序运行到recv时，它会一直等待，直到接收到数据才往下执行。</p>
<p>那么阻塞的原理是什么？</p>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得cpu使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到recv时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p>
<p>下图中的计算机中运行着A、B、C三个进程，其中进程A执行着上述基础网络程序，一开始，这3个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。</p>
<p><img src="/images/linux/epoll/epoll-5.jpg" alt="工作队列中有A、B和C三个进程"></p>
<h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p>当进程A执行到创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象（如下图）。这个socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程。</p>
<p><img src="/images/linux/epoll/epoll-6.jpg" alt="创建socket"></p>
<p>当程序执行到recv时，操作系统会将进程A从工作队列移动到该socket的等待队列中（如下图）。由于工作队列只剩下了进程B和C，依据进程调度，cpu会轮流执行这两个进程的程序，不会执行进程A的程序。<strong>所以进程A被阻塞，不会往下执行代码，也不会占用cpu资源</strong>。</p>
<p><img src="/images/linux/epoll/epoll-7.jpg" alt="socket的等待队列"></p>
<p>ps：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p>
<h2 id="唤醒进程"><a href="#唤醒进程" class="headerlink" title="唤醒进程"></a>唤醒进程</h2><p>当socket接收到数据后，操作系统将该socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。也由于socket的接收缓冲区已经有了数据，recv可以返回接收到的数据。</p>
<h1 id="四、内核接收网络数据全过程"><a href="#四、内核接收网络数据全过程" class="headerlink" title="四、内核接收网络数据全过程"></a>四、内核接收网络数据全过程</h1><p>如下图所示，进程在recv阻塞期间，计算机收到了对端传送的数据（步骤①）。数据经由网卡传送到内存（步骤②），然后网卡通过中断信号通知cpu有数据到达，cpu执行中断程序（步骤③）。此处的中断程序主要有两项功能，先将网络数据写入到对应socket的接收缓冲区里面（步骤④），再唤醒进程A（步骤⑤），重新将进程A放入工作队列中。</p>
<p><img src="/images/linux/epoll/epoll-8.jpg" alt="内核接收数据全过程"></p>
<p>唤醒进程的过程如下图所示。</p>
<p><img src="/images/linux/epoll/epoll-9.jpg" alt="唤醒进程"></p>
<h3 id="操作系统如何知道网络数据对应于哪个socket"><a href="#操作系统如何知道网络数据对应于哪个socket" class="headerlink" title="操作系统如何知道网络数据对应于哪个socket"></a>操作系统如何知道网络数据对应于哪个socket</h3><p>因为一个socket对应着一个端口号，而网络数据包中包含了ip和端口的信息，内核可以通过端口号找到对应的socket。当然，为了提高处理速度，操作系统会维护端口号到socket的索引结构，以快速读取。</p>
<h1 id="五、同时监视多个socket的简单方法"><a href="#五、同时监视多个socket的简单方法" class="headerlink" title="五、同时监视多个socket的简单方法"></a>五、同时监视多个socket的简单方法</h1><p>服务端需要管理多个客户端连接，而recv只能监视单个socket，这种矛盾下，人们开始寻找监视多个socket的方法。epoll的要义是高效的监视多个socket。从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进。只有先理解了不太高效的方法，才能够理解epoll的本质。</p>
<p>假如能够预先传入一个socket列表，<strong>如果列表中的socket都没有数据，挂起进程，直到有一个socket收到数据，唤醒进程</strong>。这种方法很直接，也是select的设计思想。</p>
<p>为方便理解，我们先复习select的用法。在如下的代码中，先准备一个数组（下面代码中的fds），让fds存放着所有需要监视的socket。然后调用select，如果fds中的所有socket都没有数据，select会阻塞，直到有一个socket接收到数据，select返回，唤醒进程。用户可以遍历fds，通过FD_ISSET判断具体哪个socket收到数据，然后做出处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int s &#x3D; socket(AF_INET, SOCK_STREAM, 0);  </span><br><span class="line">bind(s, ...)</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line">int fds[] &#x3D;  存放需要监听的socket</span><br><span class="line"></span><br><span class="line">while(1)&#123;</span><br><span class="line">    int n &#x3D; select(..., fds, ...)</span><br><span class="line">    for(int i&#x3D;0; i &lt; fds.count; i++)&#123;</span><br><span class="line">        if(FD_ISSET(fds[i], ...))&#123;</span><br><span class="line">            &#x2F;&#x2F;fds[i]的数据处理</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="select的流程"><a href="#select的流程" class="headerlink" title="select的流程"></a>select的流程</h2><p>select的实现思路很直接。假如程序同时监视如下图的sock1、sock2和sock3三个socket，那么在调用select之后，操作系统把进程A分别加入这三个socket的等待队列中。</p>
<p><img src="/images/linux/epoll/epoll-10.jpg" alt="操作系统把进程A分别加入这三个socket的等待队列中"></p>
<p>当任何一个socket收到数据后，中断程序将唤起进程。下图展示了sock2接收到了数据的处理流程。</p>
<blockquote>
<p>ps：recv和select的中断回调可以设置成不同的内容。</p>
</blockquote>
<p><img src="/images/linux/epoll/epoll-11.jpg" alt="sock2接收到了数据，中断程序唤起进程A"></p>
<p>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面。如下图所示。</p>
<p><img src="/images/linux/epoll/epoll-12.jpg" alt="将进程A从所有等待队列中移除，再加入到工作队列里面"></p>
<p>经由这些步骤，当进程A被唤醒后，它知道至少有一个socket接收了数据。程序只需遍历一遍socket列表，就可以得到就绪的socket。</p>
<p>这种简单方式行之有效，在几乎所有操作系统都有对应的实现。</p>
<p><strong>但是简单的方法往往有缺点，主要是：</strong></p>
<p>其一，每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket。</p>
<p>其二，进程被唤醒后，程序并不知道哪些socket收到数据，还需要遍历一次。</p>
<p>那么，有没有减少遍历的方法？有没有保存就绪socket的方法？这两个问题便是epoll技术要解决的。</p>
<blockquote>
<p>补充说明： 本节只解释了select的一种情形。当程序调用select时，内核会先遍历一遍socket，如果有一个以上的socket接收缓冲区有数据，那么select直接返回，不会阻塞。这也是为什么select的返回值有可能大于1的原因之一。如果没有socket有数据，进程才会阻塞。</p>
</blockquote>
<h1 id="六、epoll的设计思路"><a href="#六、epoll的设计思路" class="headerlink" title="六、epoll的设计思路"></a>六、epoll的设计思路</h1><p>epoll是在select出现N多年后才被发明的，是select和poll的增强版本。epoll通过以下一些措施来改进效率。</p>
<h2 id="措施一：功能分离"><a href="#措施一：功能分离" class="headerlink" title="措施一：功能分离"></a>措施一：功能分离</h2><p>select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。如下图所示，每次调用select都需要这两步操作，然而大多数应用场景中，需要监视的socket相对固定，并不需要每次都修改。epoll将这两个操作分开，先用epoll_ctl维护等待队列，再调用epoll_wait阻塞进程。显而易见的，效率就能得到提升。</p>
<p><img src="/images/linux/epoll/epoll-13.jpg" alt="相比select，epoll拆分了功能"></p>
<p>为方便理解后续的内容，我们先复习下epoll的用法。如下的代码中，先用epoll_create创建一个epoll对象epfd，再通过epoll_ctl将需要监视的socket添加到epfd中，最后调用epoll_wait等待数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int s &#x3D; socket(AF_INET, SOCK_STREAM, 0);   </span><br><span class="line">bind(s, ...)</span><br><span class="line">listen(s, ...)</span><br><span class="line"></span><br><span class="line">int epfd &#x3D; epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); &#x2F;&#x2F;将所有需要监听的socket添加到epfd中</span><br><span class="line"></span><br><span class="line">while(1)&#123;</span><br><span class="line">    int n &#x3D; epoll_wait(...)</span><br><span class="line">    for(接收到数据的socket)&#123;</span><br><span class="line">        &#x2F;&#x2F;处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能分离，使得epoll有了优化的可能。</p>
<h2 id="措施二：就绪列表"><a href="#措施二：就绪列表" class="headerlink" title="措施二：就绪列表"></a>措施二：就绪列表</h2><p>select低效的另一个原因在于程序不知道哪些socket收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的socket，就能避免遍历。如下图所示，计算机共有三个socket，收到数据的sock2和sock3被rdlist（就绪列表）所引用。当进程被唤醒后，只要获取rdlist的内容，就能够知道哪些socket收到数据。</p>
<p><img src="/images/linux/epoll/epoll-14.jpg" alt="就绪列表示意图"></p>
<h1 id="七、epoll的原理和流程"><a href="#七、epoll的原理和流程" class="headerlink" title="七、epoll的原理和流程"></a>七、epoll的原理和流程</h1><h2 id="创建epoll对象"><a href="#创建epoll对象" class="headerlink" title="创建epoll对象"></a>创建epoll对象</h2><p>如下图所示，当某个进程调用epoll_create方法时，内核会创建一个eventpoll对象（也就是程序中epfd所代表的对象）。eventpoll对象也是文件系统中的一员，和socket一样，它也会有等待队列。</p>
<p><img src="/images/linux/epoll/epoll-15.jpg" alt="内核创建eventpoll对象 "></p>
<p>创建一个代表该epoll的eventpoll对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为eventpoll的成员。</p>
<h2 id="维护监视列表"><a href="#维护监视列表" class="headerlink" title="维护监视列表"></a>维护监视列表</h2><p>创建epoll对象后，可以用epoll_ctl添加或删除所要监听的socket。以添加socket为例，如下图，如果通过epoll_ctl添加sock1、sock2和sock3的监视，内核会将eventpoll添加到这三个socket的等待队列中。</p>
<p><img src="/images/linux/epoll/epoll-16.jpg" alt="添加所要监听的socket "></p>
<p>当socket收到数据后，中断程序会操作eventpoll对象，而不是直接操作进程。</p>
<h2 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h2><p>当socket收到数据后，中断程序会给eventpoll的“就绪列表”添加socket引用。如下图展示的是sock2和sock3收到数据后，中断程序让rdlist引用这两个socket。</p>
<p><img src="/images/linux/epoll/epoll-17.jpg" alt="给就绪列表添加引用"></p>
<p>eventpoll对象相当于是socket和进程之间的中介，socket的数据接收并不直接影响进程，而是通过改变eventpoll的就绪列表来改变进程状态。</p>
<p>当程序执行到epoll_wait时，如果rdlist已经引用了socket，那么epoll_wait直接返回，如果rdlist为空，阻塞进程。</p>
<h2 id="阻塞和唤醒进程"><a href="#阻塞和唤醒进程" class="headerlink" title="阻塞和唤醒进程"></a>阻塞和唤醒进程</h2><p>假设计算机中正在运行进程A和进程B，在某时刻进程A运行到了epoll_wait语句。如下图所示，内核会将进程A放入eventpoll的等待队列中，阻塞进程。</p>
<p><img src="/images/linux/epoll/epoll-18.jpg" alt="epoll_wait阻塞进程"></p>
<p>当socket接收到数据，中断程序一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，进程A再次进入运行状态（如下图）。也因为rdlist的存在，进程A可以知道哪些socket发生了变化。</p>
<p><img src="/images/linux/epoll/epoll-19.jpg" alt="epoll唤醒进程"></p>
<h1 id="八、epoll的实现细节"><a href="#八、epoll的实现细节" class="headerlink" title="八、epoll的实现细节"></a>八、epoll的实现细节</h1><p>如下图所示，eventpoll包含了lock、mtx、wq（等待队列）、rdlist等成员。rdlist和rbr是我们所关心的。</p>
<p><img src="/images/linux/epoll/epoll-20.jpg" alt="epoll原理示意图"></p>
<h2 id="就绪列表的数据结构"><a href="#就绪列表的数据结构" class="headerlink" title="就绪列表的数据结构"></a>就绪列表的数据结构</h2><p>就绪列表引用着就绪的socket，所以它应能够快速的插入数据。</p>
<p>程序可能随时调用epoll_ctl添加监视socket，也可能随时删除。当删除时，若该socket已经存放在就绪列表中，它也应该被移除。</p>
<p>所以就绪列表应是一种能够快速插入和删除的数据结构。双向链表就是这样一种数据结构，epoll使用双向链表来实现就绪队列（对应上图的rdllist）。</p>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>既然epoll将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的socket。至少要方便的添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好。epoll使用了红黑树作为索引结构（对应上图的rbr）。</p>
<blockquote>
<p>ps：因为操作系统要兼顾多种功能，以及由更多需要保存的数据，rdlist并非直接引用socket，而是通过epitem间接引用，红黑树的节点也是epitem对象。同样，文件系统也并非直接引用着socket。为方便理解，本文中省略了一些间接结构。</p>
</blockquote>
<h1 id="九、结论"><a href="#九、结论" class="headerlink" title="九、结论"></a>九、结论</h1><p>epoll在select和poll（poll和select基本一样，有少量改进）的基础引入了eventpoll作为中间层，使用了先进的数据结构，是一种高效的多路复用技术。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Salt各模块用法说明</title>
    <url>/2019/09/17/salt/modules/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="ACME-加密"><a href="#ACME-加密" class="headerlink" title="ACME 加密"></a>ACME 加密</h1><h2 id="acme-cert"><a href="#acme-cert" class="headerlink" title="acme.cert"></a><code>acme.cert</code></h2><p>参数</p>
<blockquote>
<p><code>name</code> Common Name of the certificate (DNS name of certificate)</p>
</blockquote>
<blockquote>
<p><code>aliases=None</code> subjectAltNames (Additional DNS names on certificate)</p>
</blockquote>
<blockquote>
<p><code>email=None</code> e-mail address for interaction with ACME provider</p>
</blockquote>
<blockquote>
<p><code>webroot=None</code> True or full path to webroot used for authentication</p>
</blockquote>
<blockquote>
<p><code>test_cert=False</code> Request a certificate from the Happy Hacker Fake CA (mutually exclusive with ‘server’)</p>
</blockquote>
<blockquote>
<p><code>renew=None</code> True/‘force’ to force a renewal, or a window of renewal before expiry in days</p>
</blockquote>
<blockquote>
<p><code>keysize=None</code> RSA key bits</p>
</blockquote>
<blockquote>
<p><code>server=None</code>  API endpoint to talk to</p>
</blockquote>
<blockquote>
<p><code>owner=&#39;root&#39;</code> owner of private key</p>
</blockquote>
<blockquote>
<p><code>group=&#39;root&#39;</code> group of private key</p>
</blockquote>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">salt &#39;gitlab.example.com&#39; acme.cert dev.example.com &quot;[gitlab.example.com]&quot; test_cert&#x3D;True renew&#x3D;14 webroot&#x3D;&#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-rails&#x2F;public</span><br></pre></td></tr></table></figure>

<h2 id="acme-certs"><a href="#acme-certs" class="headerlink" title="acme.certs"></a><code>acme.certs</code></h2><p>参数：</p>
<blockquote>
<p>无</p>
</blockquote>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">salt &#39;vhost.example.com&#39; acme.certs</span><br></pre></td></tr></table></figure>

<h2 id="acme-info"><a href="#acme-info" class="headerlink" title="acme.info"></a><code>acme.info</code></h2><h2 id="acme-expires"><a href="#acme-expires" class="headerlink" title="acme.expires"></a><code>acme.expires</code></h2><h2 id="acme-has"><a href="#acme-has" class="headerlink" title="acme.has"></a><code>acme.has</code></h2><h2 id="acme-renew-by"><a href="#acme-renew-by" class="headerlink" title="acme.renew_by"></a><code>acme.renew_by</code></h2><h2 id="acme-needs-renewal"><a href="#acme-needs-renewal" class="headerlink" title="acme.needs_renewal"></a><code>acme.needs_renewal</code></h2><h1 id="group-管理主机上的组信息"><a href="#group-管理主机上的组信息" class="headerlink" title="group 管理主机上的组信息"></a>group 管理主机上的组信息</h1><h2 id="group-add"><a href="#group-add" class="headerlink" title="group.add"></a><code>group.add</code></h2><h2 id="group-delete"><a href="#group-delete" class="headerlink" title="group.delete"></a><code>group.delete</code></h2><h2 id="group-info"><a href="#group-info" class="headerlink" title="group.info"></a><code>group.info</code></h2><h2 id="group-getent"><a href="#group-getent" class="headerlink" title="group.getent"></a><code>group.getent</code></h2><h2 id="group-chgid"><a href="#group-chgid" class="headerlink" title="group.chgid"></a><code>group.chgid</code></h2><h2 id="group-adduser"><a href="#group-adduser" class="headerlink" title="group.adduser"></a><code>group.adduser</code></h2><h2 id="group-deluser"><a href="#group-deluser" class="headerlink" title="group.deluser"></a><code>group.deluser</code></h2><h2 id="group-members"><a href="#group-members" class="headerlink" title="group.members"></a><code>group.members</code></h2><h1 id="aliases-管理别名文件中的信息"><a href="#aliases-管理别名文件中的信息" class="headerlink" title="aliases 管理别名文件中的信息"></a>aliases 管理别名文件中的信息</h1><h2 id="aliases-list-aliases"><a href="#aliases-list-aliases" class="headerlink" title="aliases.list_aliases"></a><code>aliases.list_aliases</code></h2><h2 id="aliases-get-target"><a href="#aliases-get-target" class="headerlink" title="aliases.get_target"></a><code>aliases.get_target</code></h2><h2 id="aliases-set-target"><a href="#aliases-set-target" class="headerlink" title="aliases.set_target"></a><code>aliases.set_target</code></h2><h2 id="aliases-has-target"><a href="#aliases-has-target" class="headerlink" title="aliases.has_target"></a><code>aliases.has_target</code></h2><h2 id="aliases-rm-alias"><a href="#aliases-rm-alias" class="headerlink" title="aliases.rm_alias"></a><code>aliases.rm_alias</code></h2><h1 id="alternatives-替代系统"><a href="#alternatives-替代系统" class="headerlink" title="alternatives 替代系统"></a>alternatives 替代系统</h1><h2 id="alternatives-display"><a href="#alternatives-display" class="headerlink" title="alternatives.display"></a><code>alternatives.display</code></h2><h2 id="alternatives-show-link"><a href="#alternatives-show-link" class="headerlink" title="alternatives.show_link"></a><code>alternatives.show_link</code></h2><h2 id="alternatives-show-current"><a href="#alternatives-show-current" class="headerlink" title="alternatives.show_current"></a><code>alternatives.show_current</code></h2><h2 id="alternatives-check-exists"><a href="#alternatives-check-exists" class="headerlink" title="alternatives.check_exists"></a><code>alternatives.check_exists</code></h2><h2 id="alternatives-check-installed"><a href="#alternatives-check-installed" class="headerlink" title="alternatives.check_installed"></a><code>alternatives.check_installed</code></h2><h2 id="alternatives-install"><a href="#alternatives-install" class="headerlink" title="alternatives.install"></a><code>alternatives.install</code></h2><h2 id="alternatives-remove"><a href="#alternatives-remove" class="headerlink" title="alternatives.remove"></a><code>alternatives.remove</code></h2><h2 id="alternatives-auto"><a href="#alternatives-auto" class="headerlink" title="alternatives.auto"></a><code>alternatives.auto</code></h2><h2 id="alternatives-set"><a href="#alternatives-set" class="headerlink" title="alternatives.set"></a><code>alternatives.set</code></h2><h1 id="apache"><a href="#apache" class="headerlink" title="apache"></a>apache</h1><h2 id="apache-version"><a href="#apache-version" class="headerlink" title="apache.version"></a><code>apache.version</code></h2><h2 id="apache-fullversion"><a href="#apache-fullversion" class="headerlink" title="apache.fullversion"></a><code>apache.fullversion</code></h2><h2 id="apache-modules"><a href="#apache-modules" class="headerlink" title="apache.modules"></a><code>apache.modules</code></h2><h2 id="apache-servermods"><a href="#apache-servermods" class="headerlink" title="apache.servermods"></a><code>apache.servermods</code></h2><h2 id="apache-directives"><a href="#apache-directives" class="headerlink" title="apache.directives"></a><code>apache.directives</code></h2><h2 id="apache-vhosts"><a href="#apache-vhosts" class="headerlink" title="apache.vhosts"></a><code>apache.vhosts</code></h2><h2 id="apache-signal"><a href="#apache-signal" class="headerlink" title="apache.signal"></a><code>apache.signal</code></h2><h2 id="apache-useradd"><a href="#apache-useradd" class="headerlink" title="apache.useradd"></a><code>apache.useradd</code></h2><h2 id="apache-userdel"><a href="#apache-userdel" class="headerlink" title="apache.userdel"></a><code>apache.userdel</code></h2><h2 id="apache-server-status"><a href="#apache-server-status" class="headerlink" title="apache.server_status"></a><code>apache.server_status</code></h2><h2 id="apache-config"><a href="#apache-config" class="headerlink" title="apache.config"></a><code>apache.config</code></h2><h1 id="apcupsd"><a href="#apcupsd" class="headerlink" title="apcupsd"></a>apcupsd</h1><h2 id="apcupsd-status"><a href="#apcupsd-status" class="headerlink" title="apcupsd.status"></a><code>apcupsd.status</code></h2><h2 id="apcupsd-status-load"><a href="#apcupsd-status-load" class="headerlink" title="apcupsd.status_load"></a><code>apcupsd.status_load</code></h2><h2 id="apcupsd-status-charge"><a href="#apcupsd-status-charge" class="headerlink" title="apcupsd.status_charge"></a><code>apcupsd.status_charge</code></h2><h2 id="apcupsd-status-battery"><a href="#apcupsd-status-battery" class="headerlink" title="apcupsd.status_battery"></a><code>apcupsd.status_battery</code></h2><h1 id="apf"><a href="#apf" class="headerlink" title="apf"></a>apf</h1><h2 id="apf-running"><a href="#apf-running" class="headerlink" title="apf.running"></a><code>apf.running</code></h2><h2 id="apf-disable"><a href="#apf-disable" class="headerlink" title="apf.disable"></a><code>apf.disable</code></h2><h2 id="apf-enable"><a href="#apf-enable" class="headerlink" title="apf.enable"></a><code>apf.enable</code></h2><h2 id="apf-reload"><a href="#apf-reload" class="headerlink" title="apf.reload"></a><code>apf.reload</code></h2><h2 id="apf-refresh"><a href="#apf-refresh" class="headerlink" title="apf.refresh"></a><code>apf.refresh</code></h2><h2 id="apf-allow"><a href="#apf-allow" class="headerlink" title="apf.allow"></a><code>apf.allow</code></h2><h2 id="apf-deny"><a href="#apf-deny" class="headerlink" title="apf.deny"></a><code>apf.deny</code></h2><h2 id="apf-remove"><a href="#apf-remove" class="headerlink" title="apf.remove"></a><code>apf.remove</code></h2><h1 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h1><h2 id="pkg-latest-version"><a href="#pkg-latest-version" class="headerlink" title="pkg.latest_version"></a><code>pkg.latest_version</code></h2><h2 id="pkg-version"><a href="#pkg-version" class="headerlink" title="pkg.version"></a><code>pkg.version</code></h2><h2 id="pkg-refresh-db"><a href="#pkg-refresh-db" class="headerlink" title="pkg.refresh_db"></a><code>pkg.refresh_db</code></h2><h2 id="pkg-install"><a href="#pkg-install" class="headerlink" title="pkg.install"></a><code>pkg.install</code></h2><h2 id="pkg-autoremove"><a href="#pkg-autoremove" class="headerlink" title="pkg.autoremove"></a><code>pkg.autoremove</code></h2><h2 id="pkg-remove"><a href="#pkg-remove" class="headerlink" title="pkg.remove"></a><code>pkg.remove</code></h2><h2 id="pkg-purge"><a href="#pkg-purge" class="headerlink" title="pkg.purge"></a><code>pkg.purge</code></h2><h2 id="pkg-upgrade"><a href="#pkg-upgrade" class="headerlink" title="pkg.upgrade"></a><code>pkg.upgrade</code></h2><h2 id="pkg-hold"><a href="#pkg-hold" class="headerlink" title="pkg.hold"></a><code>pkg.hold</code></h2><h2 id="pkg-unhold"><a href="#pkg-unhold" class="headerlink" title="pkg.unhold"></a><code>pkg.unhold</code></h2><h2 id="pkg-list-pkgs"><a href="#pkg-list-pkgs" class="headerlink" title="pkg.list_pkgs"></a><code>pkg.list_pkgs</code></h2><h2 id="pkg-list-upgrades"><a href="#pkg-list-upgrades" class="headerlink" title="pkg.list_upgrades"></a><code>pkg.list_upgrades</code></h2><h2 id="pkg-upgrade-available"><a href="#pkg-upgrade-available" class="headerlink" title="pkg.upgrade_available"></a><code>pkg.upgrade_available</code></h2><h2 id="pkg-version-cmp"><a href="#pkg-version-cmp" class="headerlink" title="pkg.version_cmp"></a><code>pkg.version_cmp</code></h2><h2 id="pkg-list-repos"><a href="#pkg-list-repos" class="headerlink" title="pkg.list_repos"></a><code>pkg.list_repos</code></h2><h2 id="pkg-get-repo"><a href="#pkg-get-repo" class="headerlink" title="pkg.get_repo"></a><code>pkg.get_repo</code></h2><h2 id="pkg-del-repo"><a href="#pkg-del-repo" class="headerlink" title="pkg.del_repo"></a><code>pkg.del_repo</code></h2><h2 id="pkg-del-repo-key"><a href="#pkg-del-repo-key" class="headerlink" title="pkg.del_repo_key"></a><code>pkg.del_repo_key</code></h2><h2 id="pkg-mod-repo"><a href="#pkg-mod-repo" class="headerlink" title="pkg.mod_repo"></a><code>pkg.mod_repo</code></h2><h2 id="pkg-file-list"><a href="#pkg-file-list" class="headerlink" title="pkg.file_list"></a><code>pkg.file_list</code></h2><h2 id="pkg-file-dict"><a href="#pkg-file-dict" class="headerlink" title="pkg.file_dict"></a><code>pkg.file_dict</code></h2><h2 id="pkg-set-selections"><a href="#pkg-set-selections" class="headerlink" title="pkg.set_selections"></a><code>pkg.set_selections</code></h2><h2 id="pkg-owner"><a href="#pkg-owner" class="headerlink" title="pkg.owner"></a><code>pkg.owner</code></h2><h2 id="pkg-info-installed"><a href="#pkg-info-installed" class="headerlink" title="pkg.info_installed"></a><code>pkg.info_installed</code></h2>]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>salt</tag>
      </tags>
  </entry>
  <entry>
    <title>最大TCP连接数</title>
    <url>/2019/08/26/linux/max_tcp/</url>
    <content><![CDATA[<h1 id="linux-的TCP最大连接"><a href="#linux-的TCP最大连接" class="headerlink" title="linux 的TCP最大连接"></a>linux 的TCP最大连接</h1><h2 id="最大理论连接数"><a href="#最大理论连接数" class="headerlink" title="最大理论连接数"></a>最大理论连接数</h2><p>接受端口：65535<br>发送端口:65535<br>那么 ip A –&gt; ipB，组合起来有 65535*65535 </p>
<a id="more"></a>
<h2 id="如何标识一个TCP连接"><a href="#如何标识一个TCP连接" class="headerlink" title="如何标识一个TCP连接"></a>如何标识一个TCP连接</h2><p>在确定最大连接数之前，先来看看系统如何标识一个tcp连接。系统用一个4四元组来唯一标识一个TCP连接：{local ip, local port,remote ip,remote port}。</p>
<h2 id="client最大tcp连接数"><a href="#client最大tcp连接数" class="headerlink" title="client最大tcp连接数"></a>client最大tcp连接数</h2><p>client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned short（无符号短整型0~65535），因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大tcp连接数为65535，这些连接可以连到不同的server ip。</p>
<h2 id="server最大tcp连接数"><a href="#server最大tcp连接数" class="headerlink" title="server最大tcp连接数"></a>server最大tcp连接数</h2><p>server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的。<br>因此server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。</p>
<h2 id="实际的tcp连接数"><a href="#实际的tcp连接数" class="headerlink" title="实际的tcp连接数"></a>实际的tcp连接数</h2><p>上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（句柄），每个tcp连接都要占用一定内存，每个socket就是一个文件描述符（Linux系统中，<strong>万物皆文件</strong>，所有的都是依赖于文件），另外1024以下的端口通常为保留端口。</p>
<p>对server端，通过增加内存、修改句柄个数等参数，单机最大并发TCP连接数超过10万 是没问题的，国外 Urban Airship 公司在产品环境中已做到 50 万并发 。在实际应用中，对大规模网络应用，还需要考虑C10K 问题。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>HOTP和TOTP算法图解</title>
    <url>/2019/08/21/principles/HOTP_and_TOTP/</url>
    <content><![CDATA[<p>两步验证已经被广泛应用于各种互联网应用当中，用来提供安全性。对于如何使用两步验证，大家并不陌生，无非是开启两步验证，然后出现一个二维码，使用支持两步验证的移动应用比如<code> Google Authenticator</code>或者 <code>LassPass Authenticator</code>扫一下二维码。这时候应用会出现一个6位数的一次性密码，首次需要输入验证从而完成开启过程。以后在登陆的时候，除了输入用户名和密码外，还需要把当前的移动应用上显示的6位数编码输入才能完成登陆。</p>
<a id="more"></a>

<h1 id="协议解决的核心问题"><a href="#协议解决的核心问题" class="headerlink" title="协议解决的核心问题"></a>协议解决的核心问题</h1><p>通过前面两步验证的使用场景分析，不难看出问题的核心在于如何能够让用户手机应用产生的验证码和服务器产生的验证码一致，或者是在一定范围内一致。参考下图</p>
<p><img src="/images/principles/HOTP_and_TOTP_1.png" alt="HOTP_and_TOTP_1"></p>
<p>所以我们的算法就是在解决如何更好的生成这个验证码，既能保证服务器端和客户端同步，还能保证验证码不重复并且不容易被别人反向破解出共享密钥。其中如果是计数，则是 <code>HOTP</code>， 如果是使用时间来生成验证码，则是 <code>TOTP</code>。</p>
<h2 id="HOTP-算法图解"><a href="#HOTP-算法图解" class="headerlink" title="HOTP 算法图解"></a>HOTP 算法图解</h2><h3 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h3><p>对于 HOTP，通过上图我们已经看到输入算法的主要有两个元素，一个是共享密钥，另外一个是计数。在 RFC 算法中用一下字母表示：</p>
<p><strong>K</strong> 共享密钥，这个密钥的要求是每个 HOTP 的生成器都必须是唯一的。一般我们都是通过一些随机生成种子的库来实现。</p>
<p><strong>C</strong> 计数器，RFC 中把它称为移动元素（moving factor）是一个 8个 byte的数值，而且需要服务器和客户端同步。</p>
<p>另外一个参数比较好理解，</p>
<p><strong>Digit</strong> 表示产生的验证码的位数</p>
<p>最后两个参数可能暂时不好理解，我们先放在这，等用到在解释</p>
<p><strong>T</strong> 称为限制参数（Throttling Parameter）表示当用户尝试 T 次 OTP 授权后不成功将拒绝该用户的连接。</p>
<p><strong>s</strong> 称为重新同步参数（Resynchronization Parameter）表示服务器将通过累加计数器，来尝试多次验证输入的一次性密码，而这个尝试的次数及为 <code>s</code>。该参数主要是有效的容忍用户在客户端无意中生成了额外不用于验证的验证码，导致客户端和服务端不一致，但同时也限制了用户无限制的生成不用于验证的一次性密码。</p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="/images/principles/HOTP_and_TOTP_2.png" alt="HOTP_and_TOTP_2"></p>
<p>核心步骤主要是使用 K C 和 Digit。</p>
<p>第一步：使用 <strong>HMAC-SHA-1</strong> 算法基于 K 和 C 生成一个20个字节的十六进制字符串（HS）。关于如何生成这个是另外一个协议来规定的，<a class="link"   href="https://link.jianshu.com/?t=https://tools.ietf.org/html/rfc2104" >RFC 2104 HMAC Keyed-Hashing for Message Authentication<i class="fas fa-external-link-alt"></i></a>. 实际上这里的算法并不唯一，还可以使用 <strong>HMAC-SHA-256</strong> 和 <strong>HMAC-SHA-512</strong> 生成更长的序列。对应到协议中的算法标识就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HS &#x3D; HMAC-SHA-1(K,C)</span><br></pre></td></tr></table></figure>



<p>第二步：选择这个20个字节的十六进制字符串（HS 下文使用 HS 代替 ）的最后一个字节，取其低4位数并转化为十进制。比如图中的例子，第二个字节是 <strong>5a</strong>，第四位就是 <strong>a</strong>，十六进制也就是 <strong>0xa</strong>，转化为十进制就是 <strong>10</strong>。该数字我们定义为 <strong>Offset</strong>，也就是偏移量。</p>
<p>第三步：根据偏移量 Offset，我们从 HS 中的第 <strong>10</strong>（偏移量）个字节开始选取 <strong>4</strong> 个字节，作为我们生成 OTP 的基础数据。图中例子就是选择 <strong>50ef7f19</strong>，十六进制表示就是 <strong>0x50ef7f19</strong>，我们成为 <strong>Sbits</strong></p>
<p>以上两步在协议中的成为 Dynamic Truncation （DT）算法，具体参考以下伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Let Sbits = DT(HS)  <span class="comment">// DT, defined below, </span></span><br><span class="line">                    <span class="comment">// returns a 31-bit string</span></span><br></pre></td></tr></table></figure>

<p>展开就是</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">DT(<span class="built_in">String</span>) <span class="comment">// String = String[0]...String[19]</span></span><br><span class="line">    Let OffsetBits be the low-order <span class="number">4</span> bits <span class="keyword">of</span> <span class="built_in">String</span>[<span class="number">19</span>] </span><br><span class="line">    Offset = StToNum(OffsetBits) <span class="comment">// 0 &lt;= OffSet &lt;= 15 </span></span><br><span class="line">    Let P = <span class="built_in">String</span>[OffSet]...String[OffSet+<span class="number">3</span>] </span><br><span class="line">    Return the Last <span class="number">31</span> bits <span class="keyword">of</span> P</span><br></pre></td></tr></table></figure>

<p>第四步：将上一步4个字节的十六进制字符串 <strong>Sbits</strong> 转化为十进制，然后用该十进制数对 <strong>10的Digit次幂</strong> 进行取模运算。其原理很简单根据取模运算的性质，比如 <em>比10大的数 MOD 10 结果必然是 0到9， MOD 100 结果必然是 0-99</em>。图中的例子，<strong>50ef7f19</strong> 转化为十进制为 <strong>1357872921</strong>，然后如果需要6位 OTP 验证码，则 <strong>1357872921 MOD 10^6 = 872921</strong>。 <strong>872921</strong> 就是我们最终生成的 OTP。</p>
<p>对应到协议中的算法为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Let Snum = StToNum(Sbits) <span class="comment">// Convert S to a number in</span></span><br><span class="line">                          <span class="comment">// 0...2^&#123;31&#125;-1 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Return</span> D = Snum mod <span class="number">10</span>^Digit <span class="comment">// D is a number in the range</span></span><br><span class="line">                             <span class="comment">// 0...10^&#123;Digit&#125;-1</span></span><br></pre></td></tr></table></figure>



<p>这一步可能还需要注意一点就是图中案例 Digit 不能超过10，因为即使超过10，<br>1357872921 取模后也不会超过10位了。所以如果我们希望获取更长的验证码，需要在三步中拿到更多的十六进制字节，从而得到更大的十进制数。这个十进制决定了生成的 OTP 编码的长度。</p>
<h2 id="TOTP-算法图解"><a href="#TOTP-算法图解" class="headerlink" title="TOTP 算法图解"></a>TOTP 算法图解</h2><p>在 <code>HOTP</code> 算法的基础上，对于 <code>TOTP</code> 算法的解释是不难了，因为 <code>TOTP</code> 实际上是基础 <code>HOTP</code> 的，只不过 <code>HOTP</code> 的计数器在 <code>TOTP</code> 中不再是直接的计数器了，而是使用时间来简介计数的。下图将会详细介绍 <code>TOTP</code> 是如何在 <code>HOTP</code> 基础上使用时间来计数的。</p>
<h3 id="符号定义-1"><a href="#符号定义-1" class="headerlink" title="符号定义"></a>符号定义</h3><p>时间窗口 <strong>X</strong> ：表示多长时间算作计数器的一步，通常会设为30秒</p>
<p>初始计数时间戳 $T_0$： 使用 Unix 时间戳来表示 OTP 生成的时候的初始计数时间。</p>
<h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><p><code>TOTP</code> 算法的关键在于如何更具当前时间和时间窗口计算出计数，也就是如何根据当前时间和 X 来计算 <code>HOTP</code> 算法中的 C。</p>
<p><img src="/images/principles/HOTP_and_TOTP_3.png" alt="HOTP_and_TOTP_3"></p>
<p><code>HOTP</code> 算法中的 C 是使用当前 Unix 时间戳 减去初始计数时间戳，然后除以时间窗口而获得的。</p>
<h2 id="算法安全性分析"><a href="#算法安全性分析" class="headerlink" title="算法安全性分析"></a>算法安全性分析</h2><p>上一节我们的算法中有两个参数没有用，<strong>T</strong> 和 <strong>s</strong>。这两个参数对安全有重要的作用。</p>
<p>官方协议在这里给出了5点安全要求，其中第一点是协议本身的要求，理论上进行约束，我们主要关心另外4点，分别是 <code>HOTP</code> 的验证，限制访问参数，重新同步参数以及共享密钥的管理。</p>
<p>对于二步验证的安全问题实际上就是<strong>如何保证第二步验证尽可能不被攻击的前提下向用户提供更方便的服务</strong>。</p>
<p>通过下图我们可以详细的了解 <code>HOTP</code> 的验证过程，同时还可以了解参数 <strong>s</strong> 和 <strong>T</strong> 的用途。</p>
<p><img src="/images/principles/HOTP_and_TOTP_4.png" alt="HOTP_and_TOTP_4"></p>
<p>如果用户严格按照生成一次 <code>OTP</code>，然后验证一次的话，服务器直接可以验证成功。因为算法将会输入相同的参数。</p>
<p>如果用户无意间多生成了若干次 <code>OTP</code> 但是没有用来验证，服务器和客户端就产生差异，这时候服务器端会自动累积计数器来尝试匹配用户输入的 <code>OTP</code>，但是这种尝试是有限制的，这也就是前面说到的参数 <strong>s</strong> 的作用。一旦服务器尝试 <strong>s</strong> 次仍未匹配成功，那么就会通知客户端需要重新生成验证来验证，只要验证成功。</p>
<p>协议中对于参数 <strong>s</strong> 给出的建议是：服务器建议设置该参数，但是在保证可用性的前提下，尽可能小。另外还可以要求用户输入一个 <code>HOTP</code> 序列（比如连续生成多个 <code>OTP</code> 发送到服务器进行验证）来进行重新同步计数器。</p>
<p>既然涉及到重试，服务器同样对重试次数有所限制，从而防止暴力破解。这里当用户重试次数超过了阈值 <strong>T</strong>，服务器就应该将该账号标记为有安全风险，需要提醒用户。</p>
<p>协议中对个参数 <strong>T</strong> 给出的建议是：同样 <strong>T</strong> 也不建议设的很大。另外还提供了另外一个基于延时的策略还防止暴力破解攻击，服务器设置一个惩罚时间，一旦用户验证失败，需要在<strong>惩罚时间乘以失败次数</strong>的时间内禁止用户重新尝试验证。这个延时需要跨不同的登陆会话，以防止并发的攻击。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>内置名词解释</title>
    <url>/2019/07/24/k8s/built_in_word_interpretation/</url>
    <content><![CDATA[<h1 id="名词解释-Pods"><a href="#名词解释-Pods" class="headerlink" title="名词解释 Pods"></a>名词解释 Pods</h1><p>在Kubernetes中，最小的管理元素不是一个个独立的容器，而是Pod,Pod是最小的，管理，创建，计划的最小单元.</p>
<a id="more"></a>
<h2 id="什么是Pod"><a href="#什么是Pod" class="headerlink" title="什么是Pod"></a><strong>什么是Pod</strong></h2><p>一个<strong>Pod</strong>（就像一群鲸鱼，或者一个豌豆夹）相当于一个共享context的配置组，在同一个context下，应用可能还会有独立的cgroup隔离机制，一个Pod是一个容器环境下的“逻辑主机”，它可能包含一个或者多个紧密相连的应用，这些应用可能是在同一个物理主机或虚拟机上。</p>
<p>Pod 的context可以理解成多个linux命名空间的联合</p>
<ul>
<li>PID 命名空间（同一个Pod中应用可以看到其它进程）</li>
<li>网络 命名空间（同一个Pod的中的应用对相同的IP地址和端口有权限）</li>
<li>IPC 命名空间（同一个Pod中的应用可以通过VPC或者POSIX进行通信）</li>
<li>UTS 命名空间（同一个Pod中的应用共享一个主机名称）</li>
</ul>
<p>同一个Pod中的应用可以共享磁盘，磁盘是Pod级的，应用可以通过文件系统调用，额外的，一个Pod可能会定义顶级的cgroup隔离，这样的话绑定到任何一个应用（好吧，这句是在没怎么看懂，就是说Pod，应用，隔离）</p>
<p>由于docker的架构，一个Pod是由多个相关的并且共享磁盘的容器组成，Pid的命名空间共享还没有应用到Docker中</p>
<p>和相互独立的容器一样，Pod是一种相对短暂的存在，而不是持久存在的，正如我们在Pod的生命周期中提到的，Pod被安排到结点上，并且保持在这个节点上直到被终止（根据重启的设定）或者被删除，当一个节点死掉之后，上面的所有Pod均会被删除。特殊的Pod永远不会被转移到的其他的节点，作为替代，他们必须被replace.</p>
<h2 id="Pod的发展"><a href="#Pod的发展" class="headerlink" title="Pod的发展"></a><strong>Pod的发展</strong></h2><h3 id="资源的共享及通信"><a href="#资源的共享及通信" class="headerlink" title="资源的共享及通信"></a><strong>资源的共享及通信</strong></h3><p>Pod使Pod内的数据共享及通信变得容易</p>
<p>Pod的中的应用均使用相同的网络命名空间及端口，并且可以通过localhost发现并沟通其他应用，每个Pod都有一个扁平化的网络命名空间下IP地址，它是Pod可以和其他的物理机及其他的容器进行无障碍通信，（The hostname is set to the pod’s Name for the application containers within the pod）主机名被设置为Pod的名称（这个没翻译出来…）</p>
<p>除了定义了在Pod中运行的应用之外，Pod还定义了一系列的共享的磁盘，磁盘让这些数据在容器重启的时候不回丢失并且可以将这些数据在Pod中的应用进行共享</p>
<h3 id="管理"><a href="#管理" class="headerlink" title="管理"></a><strong>管理</strong></h3><p>Pod通过提供一个高层次抽象而不是底层的接口简化了应用的部署及管理，Pod 作为最小的部署及管理单位，位置管理，拷贝复制，资源共享，依赖关系都是自动处理的。（fate sharing估计就说什么时候该死了，什么时候该新增一个了…）</p>
<h2 id="Pod的使用"><a href="#Pod的使用" class="headerlink" title="Pod的使用"></a><strong>Pod的使用</strong></h2><p>Pod可以作为垂直应用整合的载体，但是它的主要特点是支持同地协作，同地管理程序，例如：</p>
<ul>
<li>内容管理系统，文件和数据加载，本地缓存等等</li>
<li>日志和检查点备份，压缩，循环，快照等等</li>
<li>数据交换监控，日志追踪，日志记录和监控适配器，以及事件发布等等</li>
<li>代理，网桥，适配器</li>
<li>控制，管理，配置，更新</li>
</ul>
<p>总体来说，独立的Pod不会去加载多个相同的应用实例</p>
<h2 id="考虑过的其他方案"><a href="#考虑过的其他方案" class="headerlink" title="考虑过的其他方案"></a>考虑过的其他方案</h2><p><strong>为什么不直接在一个容器上运行所有的应用？</strong></p>
<ol>
<li>透明，<strong>Pod</strong>中的容器对基础设施可见使的基础设施可以给容器提供服务，例如线程管理和资源监控，这为用户提供很多便利</li>
<li>解耦软件依赖关系,独立的容器可以独立的进行重建和重新发布，Kubernetes 甚至会在将来支持独立容器的实时更新</li>
<li>易用，用户不需要运行自己的线程管理器，也不需要关心程序的信号以及异常结束码等</li>
<li>高效，因为基础设施承载了更多的责任，所以容器可以更加高效</li>
</ol>
<p><strong>为什么不支持容器的协同调度</strong></p>
<p>容器的协同调度可以提供，但是它不具备Pod的大多数优点，比如资源共享，IPC，选择机制，简单管理等</p>
<h2 id="Pod的持久性"><a href="#Pod的持久性" class="headerlink" title="Pod的持久性"></a><strong>Pod的持久性</strong></h2><p>Pod并不是被设计成一个持久化的资源，它不会在调度失败，节点崩溃，或者其他回收中（比如因为资源的缺乏，或者其他的维护中）幸存下来</p>
<p>总体来说，用户因该直接去创建Pod，并且一直使用controller(replication controller),即使是一个节点的情况，这是因为controller提供了集群范围内的自我修复，以及复制还有展示管理</p>
<p>集群API的使用是用户的主要使用方式，这是相对普遍的在如下云管理平台中（ Borg, Marathon, Aurora, and Tupperware.）</p>
<p><strong>Pod的直接暴露是如下操作变得更容器</strong></p>
<ol>
<li>调度和管理的易用性</li>
<li>在没有代理的情况下通过API可以对Pod进行操作</li>
<li>Pod的生命周期与管理器的生命周期的分离</li>
<li>解偶控制器和服务，后段管理器仅仅监控Pod</li>
<li>划分清楚了Kubelet级别的功能与云平台级别的功能，kubelet 实际上是一个Pod管理器</li>
<li>高可用，当发生一些删除或者维护的过程时，Pod会自动的在他们被终止之前创建新的替代</li>
</ol>
<p>目前对于宠物的最佳实践是，创建一个副本等于1和有对应service的一个replication控制器。如果你觉得这太麻烦，请在这里留下你的意见。</p>
<h2 id="容器的终止"><a href="#容器的终止" class="headerlink" title="容器的终止"></a>容器的终止</h2><p>因为pod代表着一个集群中节点上运行的进程，让这些进程不再被需要，优雅的退出是很重要的（与粗暴的用一个KILL信号去结束，让应用没有机会进行清理操作）。用户应该能请求删除，并且在室进程终止的情况下能知道，而且也能保证删除最终完成。当一个用户请求删除pod，系统记录想要的优雅退出时间段，在这之前Pod不允许被强制的杀死，TERM信号会发送给容器主要的进程。一旦优雅退出的期限过了，KILL信号会送到这些进程，pod会从API服务器其中被删除。如果在等待进程结束的时候，Kubelet或者容器管理器重启了，结束的过程会带着完整的优雅退出时间段进行重试。</p>
<p>一个示例流程：</p>
<p>\1. 用户发送一个命令来删除Pod，默认的优雅退出时间是30秒</p>
<p>\2. API服务器中的Pod更新时间，超过该时间Pod被认为死亡</p>
<p>\3. 在客户端命令的的里面，Pod显示为”Terminating（退出中）”的状态</p>
<p>\4. （与第3同时）当Kubelet看到Pod标记为退出中的时候，因为第2步中时间已经设置了，它开始pod关闭的流程</p>
<p>i. 如果该Pod定义了一个停止前的钩子，其会在pod内部被调用。如果钩子在优雅退出时间段超时仍然在运行，第二步会意一个很小的优雅时间断被调用</p>
<p>ii. 进程被发送TERM的信号</p>
<p>\5. （与第三步同时进行）Pod从service的列表中被删除，不在被认为是运行着的pod的一部分。缓慢关闭的pod可以继续对外服务，当负载均衡器将他们轮流移除。</p>
<p>\6. 当优雅退出时间超时了，任何pod中正在运行的进程会被发送SIGKILL信号被杀死。</p>
<p>\7. Kubelet会完成pod的删除，将优雅退出的时间设置为0（表示立即删除）。pod从API中删除，不在对客户端可见。</p>
<p>默认情况下，所有的删除操作的优雅退出时间都在30秒以内。kubectl delete命令支持–graceperiod=的选项，以运行用户来修改默认值。0表示删除立即执行，并且立即从API中删除pod这样一个新的pod会在同时被创建。在节点上，被设置了立即结束的的pod，仍然会给一个很短的优雅退出时间段，才会开始被强制杀死。</p>
<h2 id="使用Volume"><a href="#使用Volume" class="headerlink" title="使用Volume"></a>使用Volume</h2><p>Volume可以为容器提供持久化存储，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: redis</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: redis</span><br><span class="line">    image: redis</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: redis-storage</span><br><span class="line">      mountPath: &#x2F;data&#x2F;redis</span><br><span class="line">  volumes:</span><br><span class="line">  - name: redis-storage</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>更多挂载存储卷的方法参考<a class="link"   href="https://feisky.gitbooks.io/kubernetes/concepts/volume.html" >Volume<i class="fas fa-external-link-alt"></i></a>。</p>
<h2 id="私有镜像"><a href="#私有镜像" class="headerlink" title="私有镜像"></a>私有镜像</h2><p>在使用私有镜像时，需要创建一个docker registry secret，并在容器中引用。</p>
<p>创建docker registry secret：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry regsecret --docker-server&#x3D;&lt;your-registry-server&gt; --docker-username&#x3D;&lt;your-name&gt; --docker-password&#x3D;&lt;your-pword&gt; --docker-email&#x3D;&lt;your-email&gt;</span><br></pre></td></tr></table></figure>

<p>容器中引用该secret：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: private-reg</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: private-reg-container</span><br><span class="line">      image: &lt;your-private-image&gt;</span><br><span class="line">  imagePullSecrets:</span><br><span class="line">    - name: regsecret</span><br></pre></td></tr></table></figure>

<h2 id="RestartPoliy"><a href="#RestartPoliy" class="headerlink" title="RestartPoliy"></a>RestartPoliy</h2><p>支持三种RestartPolicy</p>
<ul>
<li>Always：只要退出就重启</li>
<li>OnFailure：失败退出（exit code不等于0）时重启</li>
<li>Never：只要退出就不再重启</li>
</ul>
<p>注意，这里的重启是指在Pod所在Node上面本地重启，并不会调度到其他Node上去。</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量为容器提供了一些重要的资源，包括容器和Pod的基本信息以及集群中服务的信息等：</p>
<p>(1) hostname</p>
<p><code>HOSTNAME</code>环境变量保存了该Pod的hostname。</p>
<p>（2）容器和Pod的基本信息</p>
<p>Pod的名字、命名空间、IP以及容器的计算资源限制等可以以Downward API的方式获取并存储到环境变量中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: test-container</span><br><span class="line">      image: gcr.io&#x2F;google_containers&#x2F;busybox</span><br><span class="line">      command: [ &quot;sh&quot;, &quot;-c&quot;]</span><br><span class="line">      args:</span><br><span class="line">      - env</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          memory: &quot;32Mi&quot;</span><br><span class="line">          cpu: &quot;125m&quot;</span><br><span class="line">        limits:</span><br><span class="line">          memory: &quot;64Mi&quot;</span><br><span class="line">          cpu: &quot;250m&quot;</span><br><span class="line">      env:</span><br><span class="line">        - name: MY_NODE_NAME</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: spec.nodeName</span><br><span class="line">        - name: MY_POD_NAME</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: metadata.name</span><br><span class="line">        - name: MY_POD_NAMESPACE</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: metadata.namespace</span><br><span class="line">        - name: MY_POD_IP</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: status.podIP</span><br><span class="line">        - name: MY_POD_SERVICE_ACCOUNT</span><br><span class="line">          valueFrom:</span><br><span class="line">            fieldRef:</span><br><span class="line">              fieldPath: spec.serviceAccountName</span><br><span class="line">        - name: MY_CPU_REQUEST</span><br><span class="line">          valueFrom:</span><br><span class="line">            resourceFieldRef:</span><br><span class="line">              containerName: test-container</span><br><span class="line">              resource: requests.cpu</span><br><span class="line">        - name: MY_CPU_LIMIT</span><br><span class="line">          valueFrom:</span><br><span class="line">            resourceFieldRef:</span><br><span class="line">              containerName: test-container</span><br><span class="line">              resource: limits.cpu</span><br><span class="line">        - name: MY_MEM_REQUEST</span><br><span class="line">          valueFrom:</span><br><span class="line">            resourceFieldRef:</span><br><span class="line">              containerName: test-container</span><br><span class="line">              resource: requests.memory</span><br><span class="line">        - name: MY_MEM_LIMIT</span><br><span class="line">          valueFrom:</span><br><span class="line">            resourceFieldRef:</span><br><span class="line">              containerName: test-container</span><br><span class="line">              resource: limits.memory</span><br><span class="line">  restartPolicy: Never</span><br></pre></td></tr></table></figure>

<p>(3) 集群中服务的信息</p>
<p>容器的环境变量中还包括了容器运行前创建的所有服务的信息，比如默认的kubernetes服务对应了环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KUBERNETES_PORT_443_TCP_ADDR&#x3D;10.0.0.1</span><br><span class="line">KUBERNETES_SERVICE_HOST&#x3D;10.0.0.1</span><br><span class="line">KUBERNETES_SERVICE_PORT&#x3D;443</span><br><span class="line">KUBERNETES_SERVICE_PORT_HTTPS&#x3D;443</span><br><span class="line">KUBERNETES_PORT&#x3D;tcp:&#x2F;&#x2F;10.0.0.1:443</span><br><span class="line">KUBERNETES_PORT_443_TCP&#x3D;tcp:&#x2F;&#x2F;10.0.0.1:443</span><br><span class="line">KUBERNETES_PORT_443_TCP_PROTO&#x3D;tcp</span><br><span class="line">KUBERNETES_PORT_443_TCP_PORT&#x3D;443</span><br></pre></td></tr></table></figure>

<p>由于环境变量存在创建顺序的局限性（环境变量中不包含后来创建的服务），推荐使用DNS来解析服务。</p>
<h2 id="ImagePullPolicy"><a href="#ImagePullPolicy" class="headerlink" title="ImagePullPolicy"></a>ImagePullPolicy</h2><p>支持三种ImagePullPolicy</p>
<ul>
<li>Always：不管镜像是否存在都会进行一次拉取。</li>
<li>Never：不管镜像是否存在都不会进行拉取</li>
<li>IfNotPresent：只有镜像不存在时，才会进行镜像拉取。</li>
</ul>
<p>注意：</p>
<ul>
<li>默认为<code>IfNotPresent</code>，但<code>:latest</code>标签的镜像默认为<code>Always</code>。</li>
<li>拉取镜像时docker会进行校验，如果镜像中的MD5码没有变，则不会拉取镜像数据。</li>
<li>生产环境中应该尽量避免使用<code>:latest</code>标签，而开发环境中可以借助<code>:latest</code>标签自动拉取最新的镜像。</li>
</ul>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><p>Kubernetes通过cgroups限制容器的CPU和内存等计算资源，包括requests（请求，调度器保证调度到资源充足的Node上）和limits（上限）等：</p>
<ul>
<li><code>spec.containers[].resources.limits.cpu</code>：CPU上限，可以短暂超过，容器也不会被停止</li>
<li><code>spec.containers[].resources.limits.memory</code>：内存上限，不可以超过；如果超过，容器可能会被停止或调度到其他资源充足的机器上</li>
<li><code>spec.containers[].resources.requests.cpu</code>：CPU请求，可以超过</li>
<li><code>spec.containers[].resources.requests.memory</code>：内存请求，可以超过；但如果超过，容器可能会在Node内存不足时清理</li>
</ul>
<p>比如nginx容器请求30%的CPU和56MB的内存，但限制最多只用50%的CPU和128MB的内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - image: nginx</span><br><span class="line">      name: nginx</span><br><span class="line">      resources:</span><br><span class="line">        requests:</span><br><span class="line">          cpu: &quot;300m&quot;</span><br><span class="line">          memory: &quot;56Mi&quot;</span><br><span class="line">        limits:</span><br><span class="line">          cpu: &quot;500m&quot;</span><br><span class="line">          memory: &quot;128Mi&quot;</span><br></pre></td></tr></table></figure>

<p>注意，CPU的单位是milicpu，500mcpu=0.5cpu；而内存的单位则包括E, P, T, G, M, K, Ei, Pi, Ti, Gi, Mi, Ki等。</p>
<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>为了确保容器在部署后确实处在正常运行状态，Kubernetes提供了两种探针（Probe，支持exec、tcp和httpGet方式）来探测容器的状态：</p>
<ul>
<li>LivenessProbe：探测应用是否处于健康状态，如果不健康则删除重建改容器</li>
<li>ReadinessProbe：探测应用是否启动完成并且处于正常服务状态，如果不正常则更新容器的状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">    containers:</span><br><span class="line">    - image: nginx</span><br><span class="line">      imagePullPolicy: Always</span><br><span class="line">      name: http</span><br><span class="line">      livenessProbe:</span><br><span class="line">        httpGet:</span><br><span class="line">        path: &#x2F;</span><br><span class="line">        port: 80</span><br><span class="line">        initialDelaySeconds: 15</span><br><span class="line">        timeoutSeconds: 1</span><br><span class="line">      readinessProbe:</span><br><span class="line">        httpGet:</span><br><span class="line">        path: &#x2F;ping</span><br><span class="line">        port: 80</span><br><span class="line">        initialDelaySeconds: 5</span><br><span class="line">        timeoutSeconds: 1</span><br></pre></td></tr></table></figure>

<h2 id="Init-Container"><a href="#Init-Container" class="headerlink" title="Init Container"></a>Init Container</h2><p>Init Container在所有容器运行之前执行（run-to-completion），常用来初始化配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: init-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: workdir</span><br><span class="line">      mountPath: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">  # These containers are run during pod initialization</span><br><span class="line">  initContainers:</span><br><span class="line">  - name: install</span><br><span class="line">    image: busybox</span><br><span class="line">    command:</span><br><span class="line">    - wget</span><br><span class="line">    - &quot;-O&quot;</span><br><span class="line">    - &quot;&#x2F;work-dir&#x2F;index.html&quot;</span><br><span class="line">    - http:&#x2F;&#x2F;kubernetes.io</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: workdir</span><br><span class="line">      mountPath: &quot;&#x2F;work-dir&quot;</span><br><span class="line">  dnsPolicy: Default</span><br><span class="line">  volumes:</span><br><span class="line">  - name: workdir</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容器生命周期钩子"><a href="#容器生命周期钩子" class="headerlink" title="容器生命周期钩子"></a>容器生命周期钩子</h2><p>容器生命周期钩子（Container Lifecycle Hooks）监听容器生命周期的特定事件，并在事件发生时执行已注册的回调函数。支持两种钩子：</p>
<ul>
<li>postStart： 容器启动后执行，注意由于是异步执行，它无法保证一定在ENTRYPOINT之后运行。如果失败，容器会被杀死，并根据RestartPolicy决定是否重启</li>
<li>preStop：容器停止前执行，常用于资源清理。如果失败，容器同样也会被杀死</li>
</ul>
<p>而钩子的回调函数支持两种方式：</p>
<ul>
<li>exec：在容器内执行命令</li>
<li>httpGet：向指定URL发起GET请求</li>
</ul>
<p>postStart和preStop钩子示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: lifecycle-demo</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: lifecycle-demo-container</span><br><span class="line">    image: nginx</span><br><span class="line">    lifecycle:</span><br><span class="line">      postStart:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;bin&#x2F;sh&quot;, &quot;-c&quot;, &quot;echo Hello from the postStart handler &gt; &#x2F;usr&#x2F;share&#x2F;message&quot;]</span><br><span class="line">      preStop:</span><br><span class="line">        exec:</span><br><span class="line">          command: [&quot;&#x2F;usr&#x2F;sbin&#x2F;nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="指定Node"><a href="#指定Node" class="headerlink" title="指定Node"></a>指定Node</h2><p>通过nodeSelector，一个Pod可以指定它所想要运行的Node节点。</p>
<p>首先给Node加上标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl label nodes &lt;your-node-name&gt; disktype&#x3D;ssd</span><br></pre></td></tr></table></figure>

<p>接着，指定该Pod只想运行在带有<code>disktype=ssd</code>标签的Node上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    env: test</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: nginx</span><br><span class="line">    image: nginx</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">  nodeSelector:</span><br><span class="line">    disktype: ssd</span><br></pre></td></tr></table></figure>

<h2 id="使用Capabilities"><a href="#使用Capabilities" class="headerlink" title="使用Capabilities"></a>使用Capabilities</h2><p>默认情况下，容器都是以非特权容器的方式运行。比如，不能在容器中创建虚拟网卡、配置虚拟网络。</p>
<p>Kubernetes提供了修改<a class="link"   href="http://man7.org/linux/man-pages/man7/capabilities.7.html" >Capabilities<i class="fas fa-external-link-alt"></i></a>的机制，可以按需要给给容器增加或删除。比如下面的配置给容器增加了<code>CAP_NET_ADMIN</code>并删除了<code>CAP_KILL</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: hello-world</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: friendly-container</span><br><span class="line">    image: &quot;alpine:3.4&quot;</span><br><span class="line">    command: [&quot;&#x2F;bin&#x2F;echo&quot;, &quot;hello&quot;, &quot;world&quot;]</span><br><span class="line">    securityContext:</span><br><span class="line">      capabilities:</span><br><span class="line">        add:</span><br><span class="line">        - NET_ADMIN</span><br><span class="line">        drop:</span><br><span class="line">        - KILL</span><br></pre></td></tr></table></figure>

<h2 id="限制网络带宽"><a href="#限制网络带宽" class="headerlink" title="限制网络带宽"></a>限制网络带宽</h2><p>可以通过给Pod增加<code>kubernetes.io/ingress-bandwidth</code>和<code>kubernetes.io/egress-bandwidth</code>这两个annotation来限制Pod的网络带宽</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: qos</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io&#x2F;ingress-bandwidth: 3M</span><br><span class="line">    kubernetes.io&#x2F;egress-bandwidth: 4M</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: iperf3</span><br><span class="line">    image: networkstatic&#x2F;iperf3</span><br><span class="line">    command:</span><br><span class="line">    - iperf3</span><br><span class="line">    - -s</span><br></pre></td></tr></table></figure>

<blockquote>
<p> <strong>仅kubenet支持限制带宽</strong></p>
<p>目前只有kubenet网络插件支持限制网络带宽，其他CNI网络插件暂不支持这个功能。</p>
</blockquote>
<p>kubenet的网络带宽限制其实是通过tc来实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># setup qdisc (only once)</span><br><span class="line">tc qdisc add dev cbr0 root handle 1: htb default 30</span><br><span class="line"># download rate</span><br><span class="line">tc class add dev cbr0 parent 1: classid 1:2 htb rate 3Mbit</span><br><span class="line">tc filter add dev cbr0 protocol ip parent 1:0 prio 1 u32 match ip dst 10.1.0.3&#x2F;32 flowid 1:2</span><br><span class="line"># upload rate</span><br><span class="line">tc class add dev cbr0 parent 1: classid 1:3 htb rate 4Mbit</span><br><span class="line">tc filter add dev cbr0 protocol ip parent 1:0 prio 1 u32 match ip src 10.1.0.3&#x2F;32 flowid 1:3</span><br></pre></td></tr></table></figure>

<h2 id="调度到指定的Node上"><a href="#调度到指定的Node上" class="headerlink" title="调度到指定的Node上"></a>调度到指定的Node上</h2><p>可以通过nodeSelector、nodeAffinity、podAffinity以及Taints和tolerations等来将Pod调度到需要的Node上。具体使用方法请参考<a class="link"   href="https://feisky.gitbooks.io/kubernetes/components/scheduler.html" >调度器章节<i class="fas fa-external-link-alt"></i></a>。</p>
<h1 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h1><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a><strong>标签</strong></h2><p>标签其实就一对 key/value ，被关联到对象上，比如Pod,标签的使用我们倾向于能够标示对象的特殊特点，并且对用户而言是有意义的（就是一眼就看出了这个Pod是尼玛数据库），但是标签对内核系统是没有直接意义的。标签可以用来划分特定组的对象（比如，所有女的），标签可以在创建一个对象的时候直接给与，也可以在后期随时修改，每一个对象可以拥有多个标签，但是，key值必须是唯一的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;labels&quot;: &#123;</span><br><span class="line"> &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line"> &quot;key2&quot; : &quot;value2&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们最终会索引并且反向索引（reverse-index）labels，以获得更高效的查询和监视，把他们用到UI或者CLI中用来排序或者分组等等。我们不想用那些不具有指认效果的label来污染label，特别是那些体积较大和结构型的的数据。不具有指认效果的信息应该使用annotation来记录。</p>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a><strong>Motivation</strong></h2><p>Label可以让用户将他们自己的有组织目的的结构以一种松耦合的方式应用到系统的对象上，且不需要客户端存放这些对应关系（mappings）。</p>
<p>服务部署和批处理管道通常是多维的实体（例如多个分区或者部署，多个发布轨道，多层，每层多微服务）。管理通常需要跨越式的切割操作，这会打破有严格层级展示关系的封装，特别对那些是由基础设施而非用户决定的很死板的层级关系。</p>
<p>Label例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">“release” : “stable”, “release” : “canary”, …</span><br><span class="line"> “environment” : “dev”, “environment” : “qa”, “environment” : “production”</span><br><span class="line"> “tier” : “frontend”, “tier” : “backend”, “tier” : “middleware”</span><br><span class="line"> “partition” : “customerA”, “partition” : “customerB”, …</span><br><span class="line"> “track” : “daily”, “track” : “weekly”</span><br></pre></td></tr></table></figure>

<h2 id="Label的语法和字符集"><a href="#Label的语法和字符集" class="headerlink" title="Label的语法和字符集"></a><strong>Label的语法和字符集</strong></h2><p>Label其实是一对 key/value，有效的Label keys必须是部分：一个可选前缀+名称，通过/来区分，名称部分是必须的，并且最多63个字符，开始和结束的字符必须是字母或者数字，中间是字母数字和”_”，”-“，”.”，前缀是刻有可无的，如果指定了，那么前缀必须是一个DNS子域，一系列的DNSlabel通过”.”来划分，长度不超过253个字符，“/”来结尾。如果前缀被省略了，这个Label的key被假定为对用户私有的，自动系统组成部分（比如kube-scheduler, kube-controller-manager, kube-apiserver, kubectl）,这些为最终用户添加标签的必须要指定一个前缀，Kuberentes.io 前缀是为Kubernetes 内核部分保留的。</p>
<p>合法的label值必须是63个或者更短的字符。要么是空，要么首位字符必须为字母数字字符，中间必须是横线，下划线，点或者数字字母。</p>
<h2 id="Label-选择器"><a href="#Label-选择器" class="headerlink" title="Label**选择器**"></a><strong>Label**</strong>选择器**</h2><p>与name和UID不同，label不提供唯一性。通常，我们会看到很多对象有着一样的label。</p>
<p>通过label选择器，客户端/用户能方便辨识出一组对象。label选择器是kubernetes中核心的组织原语。</p>
<p>API目前支持两种选择器：基于相等的和基于集合的。一个label选择器一可以由多个必须条件组成，由逗号分隔。在多个必须条件指定的情况下，所有的条件都必须满足，因而逗号起着AND逻辑运算符的作用。</p>
<p>一个空的label选择器（即有0个必须条件的选择器）会选择集合中的每一个对象。</p>
<p>一个null型label选择器（仅对于可选的选择器字段才可能）不会返回任何对象。</p>
<h3 id="Equality-based-requirement"><a href="#Equality-based-requirement" class="headerlink" title="Equality-based requirement"></a>Equality-based requirement</h3><p>基于相等性或者不相等性的条件允许用label的键或者值进行过滤。匹配的对象必须满足所有指定的label约束，尽管他们可能也有额外的label。有三种运算符是允许的，“=”，“==”和“!=”。前两种代表相等性（他们是同义运算符），后一种代表非相等性。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">environment &#x3D; production</span><br><span class="line"> tier !&#x3D; frontend</span><br></pre></td></tr></table></figure>

<p>第一个选择所有键等于 environment 值为 production 的资源。后一种选择所有键为 tier 值不等于 frontend 的资源，和那些没有键为 tier 的label的资源。</p>
<p>要过滤所有处于 production 但不是 frontend 的资源，可以使用逗号操作符， environment=production,tier!=frontend 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">environment&#x3D;production,tier!&#x3D;frontend</span><br></pre></td></tr></table></figure>

<h3 id="基于set的条件"><a href="#基于set的条件" class="headerlink" title="基于set的条件"></a>基于set的条件</h3><p>基于集合的label条件允许用一组值来过滤键。支持三种操作符: in ， notin ,和 exists(仅针对于key符号) 。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">environment in (production, qa)</span><br><span class="line">tier notin (frontend, backend)</span><br><span class="line">partition</span><br><span class="line">!partitio</span><br></pre></td></tr></table></figure>

<p>第一个例子，选择所有键等于 environment ，且value等于 production 或者 qa 的资源。 第二个例子，选择所有键等于 tier 且值是除了 frontend 和 backend 之外的资源，和那些没有label的键是 tier 的资源。 第三个例子，选择所有所有有一个label的键为partition的资源；值是什么不会被检查。 第四个例子，选择所有的没有lable的键名为 partition 的资源；值是什么不会被检查。</p>
<p>类似的，逗号操作符相当于一个AND操作符。因而要使用一个 partition 键（不管值是什么），并且 environment 不是 qa 过滤资源可以用 partition,environment notin (qa) 。</p>
<p>基于集合的选择器是一个相等性的宽泛的形式，因为 environment=production 相当于environment in (production) ，与 != and notin 类似。</p>
<p>基于集合的条件可以与基于相等性 的条件混合。例如， partition in (customerA,customerB),environment!=qa 。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="LIST-和WATCH过滤"><a href="#LIST-和WATCH过滤" class="headerlink" title="LIST 和WATCH过滤"></a>LIST 和WATCH过滤</h3><p>LIST和WATCH操作，可以使用query参数来指定label选择器来过滤返回对象的集合。两种条件都可以使用： 基于相等性条件： ?labelSelector=environment%3Dproduction,tier%3Dfrontend基于集合条件的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">labelSelector&#x3D;environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</span><br></pre></td></tr></table></figure>

<p>两种label选择器风格都可以用来通过REST客户端来列表或者监视资源。比如使用 kubectl 来针对 apiserver ，并且使用基于相等性的条件，可以用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -l environment&#x3D;production,tier&#x3D;frontend</span><br></pre></td></tr></table></figure>

<p>or using set-based requirements: 或者使用基于集合的条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -l &#39;environment in (production),tier in (frontend)&#39;</span><br></pre></td></tr></table></figure>

<p>如以上已经提到的，基于集合的条件表达性更强。例如，他们可以实现值上的OR操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -l &#39;environment in (production, qa)&#39;</span><br></pre></td></tr></table></figure>

<p>或者通过exists操作符进行否定限制匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods -l &#39;environment,environment notin (frontend)&#39;</span><br></pre></td></tr></table></figure>

<h3 id="Set-references-in-API-objects"><a href="#Set-references-in-API-objects" class="headerlink" title="Set references in API objects"></a>Set references in API objects</h3><p>一些Kubernetes对象，比如service和replication controlle的，也使用label选择器来指定其他资源的集合，比如pods。</p>
<h3 id="Service-and-ReplicationController"><a href="#Service-and-ReplicationController" class="headerlink" title="Service and ReplicationController"></a>Service and ReplicationController</h3><p>一个service针对的pods的集合是用label选择器来定义的。类似的，一个replicationcontroller管理的pods的群体也是用label选择器来定义的。</p>
<p>对于这两种对象的Label选择器是用map定义在json或者yaml文件中的，并且只支持基于相等性的条件：</p>
<blockquote>
<p>“selector”: {<br>“component” : “redis”,<br>}</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>selector:<br>component: redis</p>
</blockquote>
<p>这个选择器（分别是位于json或者yaml格式的）相等于 component=redis 或者 component in(redis) 。</p>
<h3 id="Job-and-other-new-resources"><a href="#Job-and-other-new-resources" class="headerlink" title="Job and other new resources"></a>Job and other new resources</h3><h4 id="Job和其他新的资源"><a href="#Job和其他新的资源" class="headerlink" title="Job和其他新的资源"></a>Job和其他新的资源</h4><p>较新的资源，如job，也支持基于集合的条件。</p>
<blockquote>
<p>selector:<br>matchLabels:相当于一个<br>component: redis<br>matchExpressions:<br>– {key: tier, operator: In, values: [cache]}<br>– {key: environment, operator: NotIn, values: [dev]}</p>
</blockquote>
<p>matchLabels 是一个键值对的映射。一个单独的 {key,value} 相当于 matchExpressions 的一个元素，它的键字段是”key”,操作符是 In ，并且值数组值包含”value”。 matchExpressions 是一个pod的选择器条件的列表。合法的操作符包含In, NotIn, Exists, and DoesNotExist。在In和NotIn的情况下，值的组必须不能为空。所有的条件，包含 matchLabels andmatchExpressions 中的，会用AND符号连接，他们必须都被满足以完成匹配。</p>
<p>更多参考 kubernetes.io/docs/user-guide/labels/#set-based-requirement</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>面向接口编程</title>
    <url>/2019/07/24/golang/face_to_interface/</url>
    <content><![CDATA[<h1 id="1-接口-多态"><a href="#1-接口-多态" class="headerlink" title="1. 接口[多态]"></a>1. 接口[多态]</h1><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</p>
<p>简而言之，就是允许将子类类型的指针赋值给父类类型的指针。</p>
<p>即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。多态分为编译时多态（静态多态）和运行时多态（动态多态），编译时多态一般通过方法重载实现，运行时多态一般通过方法重写实现。</p>
<a id="more"></a>

<h2 id="1-1-接口概念"><a href="#1-1-接口概念" class="headerlink" title="1.1 接口概念"></a>1.1 接口概念</h2><blockquote>
<p>接口类型可以看作是类型系统中一种特殊的类型，而实例就是实现了该接口的具体结构体类型。<br>接口类型与实现了该接口的结构体对象之间的关系好比变量类型与变量之间的关系。</p>
</blockquote>
<p>接口即一组方法定义的集合，定义了对象的一组行为，由具体的类型实例实现具体的方法。换句话说，一个接口就是定义（规范或约束），而方法就是实现，接口的作用应该是将定义与实现分离，降低耦合度。习惯用“er”结尾来命名，例如“Reader”。接口与对象的关系是多对多，即一个对象可以实现多个接口，一个接口也可以被多个对象实现。</p>
<p>接口是Go语言整个类型系统的基石，其他语言的接口是不同组件之间的契约的存在，对契约的实现是强制性的，必须显式声明实现了该接口，这类接口称之为“侵入式接口”。而Go语言的接口是隐式存在，只要实现了该接口的所有函数则代表已经实现了该接口，并不需要显式的接口声明。</p>
<h4 id="接口的比喻"><a href="#接口的比喻" class="headerlink" title="接口的比喻"></a>接口的比喻</h4><p>你的电脑上只有一个USB接口。这个USB接口可以接MP3，数码相机，摄像头，鼠标，键盘等。。。所有的上述硬件都可以公用这个接口，有很好的扩展性，该USB接口定义了一种规范，只要实现了该规范，就可以将不同的设备接入电脑，而设备的改变并不会对电脑本身有什么影响（低耦合）。</p>
<h4 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h4><p> 接口表示调用者和设计者的一种约定，在多人合作开发同一个项目时，事先定义好相互调用的接口可以大大提高开发的效率。接口是用类来实现的，实现接口的类必须严格按照接口的声明来实现接口提供的所有功能。有了接口，就可以在不影响现有接口声明的情况下，修改接口的内部实现，从而使兼容性问题最小化。</p>
<p><strong>面向接口编程可以分为三方面：制定者（或者叫协调者），实现者（或者叫生产者），调用者（或者叫消费者）。</strong></p>
<p>当其他设计者调用了接口后，就不能再随意更改接口的定义，否则项目开发者事先的约定就失去了意义。但是可以在类中修改相应的代码，完成需要改动的内容。</p>
<h2 id="1-2非侵入式接口"><a href="#1-2非侵入式接口" class="headerlink" title="1.2非侵入式接口"></a>1.2非侵入式接口</h2><p>非侵入式接口：一个类只需要实现了接口要求的所有函数就表示实现了该接口，并不需要显式声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="comment">//类的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//File类的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>,err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Write</span><span class="params">(buf []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>,err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Seek</span><span class="params">(off <span class="keyword">int64</span>,whence <span class="keyword">int</span>)</span> <span class="params">(pos <span class="keyword">int64</span>,err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">//接口1：IFile</span></span><br><span class="line"><span class="keyword">type</span> IFile <span class="keyword">interface</span>&#123;</span><br><span class="line">  Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>,err error)</span><br><span class="line">  Write(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>,err error)</span><br><span class="line">  Seek(off <span class="keyword">int64</span>,whence <span class="keyword">int</span>) (pos <span class="keyword">int64</span>,err error)</span><br><span class="line">  Close() error</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口2：IReader</span></span><br><span class="line"><span class="keyword">type</span> IReader <span class="keyword">interface</span>&#123;</span><br><span class="line">  Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>,err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口赋值,File类实现了IFile和IReader接口，即接口所包含的所有方法</span></span><br><span class="line"><span class="keyword">var</span> file1 IFile = <span class="built_in">new</span>(File)</span><br><span class="line"><span class="keyword">var</span> file2 IReader = <span class="built_in">new</span>(File)</span><br></pre></td></tr></table></figure>

<h2 id="1-3接口赋值"><a href="#1-3接口赋值" class="headerlink" title="1.3接口赋值"></a>1.3接口赋值</h2><p>只要类实现了该接口的所有方法，即可将该类赋值给这个接口，接口主要用于多态化方法。即对接口定义的方法，不同的实现方式。</p>
<p>接口赋值： </p>
<h3 id="1）将对象实例赋值给接口"><a href="#1）将对象实例赋值给接口" class="headerlink" title="1）将对象实例赋值给接口"></a>1）将对象实例赋值给接口</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IUSB <span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="comment">//定义IUSB的接口方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法定义在类外，绑定该类，以下为方便，备注写在类中</span></span><br><span class="line"><span class="keyword">type</span> MP3 <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">//实现IUSB的接口，具体实现方式是MP3的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Mouse <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">//实现IUSB的接口，具体实现方式是Mouse的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口赋值给具体的对象实例MP3</span></span><br><span class="line"><span class="keyword">var</span> usb IUSB =<span class="built_in">new</span>(MP3)</span><br><span class="line">usb.Connect()</span><br><span class="line">usb.Close()</span><br><span class="line"><span class="comment">//接口赋值给具体的对象实例Mouse</span></span><br><span class="line"><span class="keyword">var</span> usb IUSB =<span class="built_in">new</span>(Mouse)</span><br><span class="line">usb.Connect()</span><br><span class="line">usb.Close()</span><br></pre></td></tr></table></figure>

<h3 id="2）将接口赋值给另一个接口"><a href="#2）将接口赋值给另一个接口" class="headerlink" title="2）将接口赋值给另一个接口"></a>2）将接口赋值给另一个接口</h3><ol>
<li>只要两个接口拥有相同的方法列表（与次序无关），即是两个相同的接口，可以相互赋值</li>
<li>接口赋值只需要接口A的方法列表是接口B的子集（即假设接口A中定义的所有方法，都在接口B中有定义），那么B接口的实例可以赋值给A的对象。反之不成立，即子接口B包含了父接口A，因此可以将子接口的实例赋值给父接口。</li>
<li>即子接口实例实现了子接口的所有方法，而父接口的方法列表是子接口的子集，则子接口实例自然实现了父接口的所有方法，因此可以将子接口实例赋值给父接口。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span>&#123;    <span class="comment">//父接口</span></span><br><span class="line">    Write(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>,err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span>&#123;    <span class="comment">//子接口</span></span><br><span class="line">    Read(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>,err error)</span><br><span class="line">    Write(buf []<span class="keyword">byte</span>) (n <span class="keyword">int</span>,err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> file1 ReadWriter=<span class="built_in">new</span>(File)   <span class="comment">//子接口实例</span></span><br><span class="line"><span class="keyword">var</span> file2 Writer=file1           <span class="comment">//子接口实例赋值给父接口</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4接口查询"><a href="#1-4接口查询" class="headerlink" title="1.4接口查询"></a>1.4接口查询</h2><p>若要在 switch 外判断一个接口类型是否实现了某个接口，可以使用<code>_, ok</code>。</p>
<p><code>value, ok := Interfacevariable.(implementType)</code></p>
<p>其中 Interfacevariable 是接口变量（接口值），implementType 为实现此接口的类型，value 返回接口变量实际类型变量的值，如果该类型实现了此接口返回 true。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断file1接口指向的对象实例是否是File类型</span></span><br><span class="line"><span class="keyword">var</span> file1 Writer=...</span><br><span class="line"><span class="keyword">if</span> file5,ok:=file1.(File);ok&#123;  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-接口类型查询"><a href="#1-5-接口类型查询" class="headerlink" title="1.5 接口类型查询"></a>1.5 接口类型查询</h2><p>在 Go 中，要判断传递给接口值的变量类型，可以在使用 type switch 得到。(type)只能在 switch 中使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 另一个实现了 I 接口的 R 类型</span></span><br><span class="line"><span class="keyword">type</span> R <span class="keyword">struct</span> &#123; i <span class="keyword">int</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *R)</span> <span class="title">Get</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> p.i &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *R)</span> <span class="title">Put</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123; p.i = v &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(p I)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t := p.(<span class="keyword">type</span>) &#123; <span class="comment">// 判断传递给 p 的实际类型</span></span><br><span class="line">        <span class="keyword">case</span> *S: <span class="comment">// 指向 S 的指针类型</span></span><br><span class="line">        <span class="keyword">case</span> *R: <span class="comment">// 指向 R 的指针类型</span></span><br><span class="line">        <span class="keyword">case</span> S:  <span class="comment">// S 类型</span></span><br><span class="line">        <span class="keyword">case</span> R:  <span class="comment">// R 类型</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">//实现了 I 接口的其他类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-6-接口组合"><a href="#1-6-接口组合" class="headerlink" title="1.6 接口组合"></a>1.6 接口组合</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口组合类似类型组合，只不过只包含方法，不包含成员变量</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span>&#123;  <span class="comment">//接口组合，避免代码重复</span></span><br><span class="line">  Reader      <span class="comment">//接口Reader</span></span><br><span class="line">  Writer      <span class="comment">//接口Writer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7Any类型-空接口"><a href="#1-7Any类型-空接口" class="headerlink" title="1.7Any类型[空接口]"></a>1.7Any类型[空接口]</h2><p>每种类型都能匹配到空接口：interface{}。空接口类型对方法没有任何约束（因为没有方法），它能包含任意类型，也可以实现到其他接口类型的转换。如果传递给该接口的类型变量实现了转换后的接口则可以正常运行，否则出现运行时错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//interface&#123;&#125;即为可以指向任何对象的Any类型，类似Java中的Object类</span></span><br><span class="line"><span class="keyword">var</span> v1 <span class="keyword">interface</span>&#123;&#125;=<span class="keyword">struct</span>&#123;X <span class="keyword">int</span>&#125;&#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> v2 <span class="keyword">interface</span>&#123;&#125;=<span class="string">&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;   <span class="comment">//该函数可以接收任何类型的参数，因为任何类型都实现了空接口</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-8-接口的代码示例"><a href="#1-8-接口的代码示例" class="headerlink" title="1.8 接口的代码示例"></a>1.8 接口的代码示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口animal</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Dog类实现animal接口</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d Dog)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Woof!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Cat类实现animal接口</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Cat)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Meow!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Llama实现animal接口</span></span><br><span class="line"><span class="keyword">type</span> Llama <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l Llama)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;?????&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JavaProgrammer实现animal接口</span></span><br><span class="line"><span class="keyword">type</span> JavaProgrammer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j JavaProgrammer)</span> <span class="title">Speak</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Design patterns!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;, Llama&#123;&#125;, JavaProgrammer&#123;&#125;&#125;  <span class="comment">//利用接口实现多态</span></span><br><span class="line">    <span class="keyword">for</span> _, animal := <span class="keyword">range</span> animals &#123;</span><br><span class="line">        fmt.Println(animal.Speak())  <span class="comment">//打印不同实现该接口的类的方法返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-client-go中接口的使用分析"><a href="#2-client-go中接口的使用分析" class="headerlink" title="2. client-go中接口的使用分析"></a>2. client-go中接口的使用分析</h1><p>以下以<code>k8s.io/client-go/kubernetes/typed/core/v1/pod.go</code>的pod对象做分析。</p>
<h2 id="2-1-接口设计与定义"><a href="#2-1-接口设计与定义" class="headerlink" title="2.1 接口设计与定义"></a>2.1 接口设计与定义</h2><h3 id="2-1-1-接口组合"><a href="#2-1-1-接口组合" class="headerlink" title="2.1.1 接口组合"></a>2.1.1 接口组合</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PodsGetter has a method to return a PodInterface.</span></span><br><span class="line"><span class="comment">// A group&#x27;s client should implement this interface.</span></span><br><span class="line"><span class="keyword">type</span> PodsGetter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Pods(namespace <span class="keyword">string</span>) PodInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-接口定义"><a href="#2-1-2-接口定义" class="headerlink" title="2.1.2 接口定义"></a>2.1.2 接口定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PodInterface has methods to work with Pod resources.</span></span><br><span class="line"><span class="keyword">type</span> PodInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Create(*v1.Pod) (*v1.Pod, error)</span><br><span class="line">    Update(*v1.Pod) (*v1.Pod, error)</span><br><span class="line">    UpdateStatus(*v1.Pod) (*v1.Pod, error)</span><br><span class="line">    Delete(name <span class="keyword">string</span>, options *meta_v1.DeleteOptions) error</span><br><span class="line">    DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error</span><br><span class="line">    Get(name <span class="keyword">string</span>, options meta_v1.GetOptions) (*v1.Pod, error)</span><br><span class="line">    List(opts meta_v1.ListOptions) (*v1.PodList, error)</span><br><span class="line">    Watch(opts meta_v1.ListOptions) (watch.Interface, error)</span><br><span class="line">    Patch(name <span class="keyword">string</span>, pt types.PatchType, data []<span class="keyword">byte</span>, subresources ...<span class="keyword">string</span>) (result *v1.Pod, err error)</span><br><span class="line">    PodExpansion</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>PodInterface</code>接口定义了pod对象所使用的方法，一般为增删改查等。其他kubernetes资源对象的接口定义类似，区别在于入参和出参与对象相关。例如<code>Create(*v1.Pod) (*v1.Pod, error)</code>方法定义的入参出参为<code>*v1.Pod</code>。如果要实现该接口，即实现该接口的所有方法。</p>
<h2 id="2-2-接口的实现"><a href="#2-2-接口的实现" class="headerlink" title="2.2 接口的实现"></a>2.2 接口的实现</h2><h3 id="2-2-1-结构体的定义"><a href="#2-2-1-结构体的定义" class="headerlink" title="2.2.1 结构体的定义"></a>2.2.1 结构体的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pods implements PodInterface</span></span><br><span class="line"><span class="keyword">type</span> pods <span class="keyword">struct</span> &#123;</span><br><span class="line">    client rest.Interface</span><br><span class="line">    ns     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-new函数-构造函数"><a href="#2-2-2-new函数-构造函数" class="headerlink" title="2.2.2 new函数[构造函数]"></a>2.2.2 new函数[构造函数]</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newPods returns a Pods</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPods</span><span class="params">(c *CoreV1Client, namespace <span class="keyword">string</span>)</span> *<span class="title">pods</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;pods&#123;</span><br><span class="line">        client: c.RESTClient(),</span><br><span class="line">        ns:     namespace,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-方法的实现"><a href="#2-2-3-方法的实现" class="headerlink" title="2.2.3 方法的实现"></a>2.2.3 方法的实现</h3><p><strong>Get</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get takes name of the pod, and returns the corresponding pod object, and an error if there is any.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">Get</span><span class="params">(name <span class="keyword">string</span>, options meta_v1.GetOptions)</span> <span class="params">(result *v1.Pod, err error)</span></span> &#123;</span><br><span class="line">    result = &amp;v1.Pod&#123;&#125;</span><br><span class="line">    err = c.client.Get().</span><br><span class="line">        Namespace(c.ns).</span><br><span class="line">        Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">        Name(name).</span><br><span class="line">        VersionedParams(&amp;options, scheme.ParameterCodec).</span><br><span class="line">        Do().</span><br><span class="line">        Into(result)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>List</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List takes label and field selectors, and returns the list of Pods that match those selectors.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">List</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(result *v1.PodList, err error)</span></span> &#123;</span><br><span class="line">    result = &amp;v1.PodList&#123;&#125;</span><br><span class="line">    err = c.client.Get().</span><br><span class="line">        Namespace(c.ns).</span><br><span class="line">        Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">        VersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class="line">        Do().</span><br><span class="line">        Into(result)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Create</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create takes the representation of a pod and creates it.  Returns the server&#x27;s representation of the pod, and an error, if there is any.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">Create</span><span class="params">(pod *v1.Pod)</span> <span class="params">(result *v1.Pod, err error)</span></span> &#123;</span><br><span class="line">    result = &amp;v1.Pod&#123;&#125;</span><br><span class="line">    err = c.client.Post().</span><br><span class="line">        Namespace(c.ns).</span><br><span class="line">        Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">        Body(pod).</span><br><span class="line">        Do().</span><br><span class="line">        Into(result)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Update</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Update takes the representation of a pod and updates it. Returns the server&#x27;s representation of the pod, and an error, if there is any.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">Update</span><span class="params">(pod *v1.Pod)</span> <span class="params">(result *v1.Pod, err error)</span></span> &#123;</span><br><span class="line">    result = &amp;v1.Pod&#123;&#125;</span><br><span class="line">    err = c.client.Put().</span><br><span class="line">        Namespace(c.ns).</span><br><span class="line">        Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">        Name(pod.Name).</span><br><span class="line">        Body(pod).</span><br><span class="line">        Do().</span><br><span class="line">        Into(result)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Delete</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Delete takes name of the pod and deletes it. Returns an error if one occurs.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">Delete</span><span class="params">(name <span class="keyword">string</span>, options *meta_v1.DeleteOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.client.Delete().</span><br><span class="line">        Namespace(c.ns).</span><br><span class="line">        Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">        Name(name).</span><br><span class="line">        Body(options).</span><br><span class="line">        Do().</span><br><span class="line">        Error()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-接口的调用"><a href="#2-3-接口的调用" class="headerlink" title="2.3 接口的调用"></a>2.3 接口的调用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建clientset实例</span></span><br><span class="line">clientset, err := kubernetes.NewForConfig(config)</span><br><span class="line"><span class="comment">// 具体的调用</span></span><br><span class="line">pods, err := clientset.CoreV1().Pods(<span class="string">&quot;&quot;</span>).List(metav1.ListOptions&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>clientset实现了接口<code>Interface</code>，<code>Interface</code>是个接口组合，包含各个client的接口类型。例如<code>CoreV1()</code>方法对应的接口类型是<code>CoreV1Interface</code>。</p>
<p>以下是clientset的<code>CoreV1()</code>方法实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CoreV1 retrieves the CoreV1Client</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Clientset)</span> <span class="title">CoreV1</span><span class="params">()</span> <span class="title">corev1</span>.<span class="title">CoreV1Interface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.coreV1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以理解为是一个构造函数。构造函数的返回值类型是一个接口类型<code>CoreV1Interface</code>，而return的返回值是实现了该接口类型的结构体对象<code>c.coreV1</code>。</p>
<p>接口类型是一种特殊的类型，接口类型与结构体对象之间的关系好比变量类型与变量之间的关系。其中的结构体对象必须实现了该接口类型的所有方法。</p>
<p>所以clientset的<code>CoreV1()</code>方法实现是返回一个<code>CoreV1Client</code>结构体对象。该结构体对象实现了<code>CoreV1Interface</code>接口，该接口也是一个接口组合。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CoreV1Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    RESTClient() rest.Interface</span><br><span class="line">    ComponentStatusesGetter</span><br><span class="line">    ConfigMapsGetter</span><br><span class="line">    EndpointsGetter</span><br><span class="line">    EventsGetter</span><br><span class="line">    LimitRangesGetter</span><br><span class="line">    NamespacesGetter</span><br><span class="line">    NodesGetter</span><br><span class="line">    PersistentVolumesGetter</span><br><span class="line">    PersistentVolumeClaimsGetter</span><br><span class="line">    PodsGetter</span><br><span class="line">    PodTemplatesGetter</span><br><span class="line">    ReplicationControllersGetter</span><br><span class="line">    ResourceQuotasGetter</span><br><span class="line">    SecretsGetter</span><br><span class="line">    ServicesGetter</span><br><span class="line">    ServiceAccountsGetter</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而实现的<code>Pods()</code>方法是其中的<code>PodsGetter</code>接口。</p>
<p><code>Pods()</code>同<code>CoreV1()</code>一样是个构造函数，构造函数的返回值类型是<code>PodInterface</code>接口，返回值是实现了<code>PodInterface</code>接口的<code>pods</code>结构体对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CoreV1Client)</span> <span class="title">Pods</span><span class="params">(namespace <span class="keyword">string</span>)</span> <span class="title">PodInterface</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newPods(c, namespace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调用了<code>pods</code>对象的<code>List()</code>方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pods, err := clientset.CoreV1().Pods(<span class="string">&quot;&quot;</span>).List(metav1.ListOptions&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>即以上代码就是不断调用实现了某接口的结构体对象的构造函数，生成具体的结构体对象，再调用结构体对象的某个具体方法。</p>
<h1 id="3-通用接口设计"><a href="#3-通用接口设计" class="headerlink" title="3. 通用接口设计"></a>3. 通用接口设计</h1><h2 id="3-1-接口定义"><a href="#3-1-接口定义" class="headerlink" title="3.1 接口定义"></a>3.1 接口定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProjectManager manage life cycle of Deployment and Resources</span></span><br><span class="line"><span class="keyword">type</span> PodInterface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Create(*v1.Pod) (*v1.Pod, error)</span><br><span class="line">    Update(*v1.Pod) (*v1.Pod, error)</span><br><span class="line">    UpdateStatus(*v1.Pod) (*v1.Pod, error)</span><br><span class="line">    Delete(name <span class="keyword">string</span>, options *meta_v1.DeleteOptions) error</span><br><span class="line">    DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error</span><br><span class="line">    Get(name <span class="keyword">string</span>, options meta_v1.GetOptions) (*v1.Pod, error)</span><br><span class="line">    List(opts meta_v1.ListOptions) (*v1.PodList, error)</span><br><span class="line">    Watch(opts meta_v1.ListOptions) (watch.Interface, error)</span><br><span class="line">    Patch(name <span class="keyword">string</span>, pt types.PatchType, data []<span class="keyword">byte</span>, subresources ...<span class="keyword">string</span>) (result *v1.Pod, err error)</span><br><span class="line">    PodExpansion</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-结构体定义"><a href="#3-2-结构体定义" class="headerlink" title="3.2 结构体定义"></a>3.2 结构体定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pods implements PodInterface</span></span><br><span class="line"><span class="keyword">type</span> pods <span class="keyword">struct</span> &#123;</span><br><span class="line">    client rest.Interface</span><br><span class="line">    ns     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-构造函数"><a href="#3-3-构造函数" class="headerlink" title="3.3 构造函数"></a>3.3 构造函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newPods returns a Pods</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPods</span><span class="params">(c *CoreV1Client, namespace <span class="keyword">string</span>)</span> *<span class="title">pods</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;pods&#123;</span><br><span class="line">        client: c.RESTClient(),</span><br><span class="line">        ns:     namespace,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-4-结构体实现"><a href="#3-4-结构体实现" class="headerlink" title="3.4 结构体实现"></a>3.4 结构体实现</h2><p><strong>List</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List takes label and field selectors, and returns the list of Pods that match those selectors.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pods)</span> <span class="title">List</span><span class="params">(opts meta_v1.ListOptions)</span> <span class="params">(result *v1.PodList, err error)</span></span> &#123;</span><br><span class="line">    result = &amp;v1.PodList&#123;&#125;</span><br><span class="line">    err = c.client.Get().</span><br><span class="line">        Namespace(c.ns).</span><br><span class="line">        Resource(<span class="string">&quot;pods&quot;</span>).</span><br><span class="line">        VersionedParams(&amp;opts, scheme.ParameterCodec).</span><br><span class="line">        Do().</span><br><span class="line">        Into(result)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-接口调用"><a href="#3-5-接口调用" class="headerlink" title="3.5 接口调用"></a>3.5 接口调用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pods, err := clientset.CoreV1().Pods(<span class="string">&quot;&quot;</span>).List(metav1.ListOptions&#123;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="3-6-其他接口设计示例"><a href="#3-6-其他接口设计示例" class="headerlink" title="3.6 其他接口设计示例"></a>3.6 其他接口设计示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> XxxManager <span class="keyword">interface</span> &#123;</span><br><span class="line">    Create(args argsType) (*XxxStruct, error)</span><br><span class="line">    Get(args argsType) (**XxxStruct, error)</span><br><span class="line">    Update(args argsType) (*XxxStruct, error)</span><br><span class="line">    Delete(name <span class="keyword">string</span>, options *DeleleOptions) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XxxManagerImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Namespace <span class="keyword">string</span></span><br><span class="line">    kubeCli *kubernetes.Clientset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewXxxManagerImpl</span> <span class="params">(namespace, name <span class="keyword">string</span>, kubeCli *kubernetes.Clientset)</span> <span class="title">XxxManager</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;XxxManagerImpl&#123;</span><br><span class="line">        Name name,</span><br><span class="line">        Namespace namespace,</span><br><span class="line">        kubeCli: kubeCli,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(xm *XxxManagerImpl)</span> <span class="title">Create</span><span class="params">(args argsType)</span> <span class="params">(*XxxStruct, error)</span></span> &#123;</span><br><span class="line">    <span class="comment">//具体的方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerInDocker</title>
    <url>/2019/07/21/docker/DockerInDocker/</url>
    <content><![CDATA[<p>Docker技术目前在DevOps中被广泛使用，我们需要将测试或者构建的代码和自动化脚本打包成Docker镜像，然后部署在各运行环境中。而在CI/CD中，我们常用一些CI/CD服务器，比如Jenkins和GoCD来构建与部署我们的应用，从而实现CI/CD的自动化。现在一些CI/CD服务器也被Docker化运行在真实的物理机上。于是我们需要在CI/CD服务器的Docker container里面来构建（build）与运行（run）我们的Docker镜像，这就涉及到”Docker run Docker”的问题。</p>
<a id="more"></a>

<p>一个很自然的想法是，我们是不是需要在CI/CD服务器镜像中安装一个Docker Daemon和Docker命令呢？但是Docker里面跑Docker总感觉有些蹩脚，额外安装与运行Docker无疑增加了CI/CD服务器镜像的大小，同时还增加Docker的深度。</p>
<p>实际上，我们并不需要在CI/CD服务器上安装Docker。通过如下的命令在CI/CD服务器上运行我们的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run  -v /var/run/docker.sock:/var/run/docker.sock</span><br></pre></td></tr></table></figure>

<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;Docker采取的是C/S架构，Docker的成功运行需要Docker Daemon和Docker Client(客户端)的支持，当我们运行一些docker build等命令时，实际是需要Docker Client连接Docker Daemon发送命令，Docker Daemon会在宿主机操作系统分配文件、网络等资源。</p>
<p><img src="/images/docker/DockerInDocker.jpg" alt="DockerInDocker"></p>
<p>&emsp;&emsp;默认情况下，Docker守护进程会生成一个socket（/var/run/docker.sock）文件来进行本地进程通信，而不会监听任何端口，因此只能在本地使用docker客户端或者使用Docker API进行操作。一般情况下，我们访问本机的服务往往通过 127.0.0.1:8080 这种IP：端口的网络地址方式进行通信，而sock文件是 UNIX 域套接字（UNIX domain socket），它可以通过文件系统（而非网络地址）进行寻址和访问的套接字。</p>
<p>&emsp;&emsp;从表象上看，上面的命令似乎依然是在“Docker里面run docker”，其实这是个误区。docker run提供了 -v  参数让我们将宿主的文件映射到docker里面。比如通过 -v /var/run/docker.sock:/var/run/docker.sock ，我们将宿主的Docker Daemon的socket映射到Docker Container里面；当Container里面的docker 客户端通过 /var/run/docker.sock 去操作Docker Daemon时，这些操作已移花接木地转移到宿主的Docker Daemon上。</p>
<h1 id="延伸：操作远程主机"><a href="#延伸：操作远程主机" class="headerlink" title="延伸：操作远程主机"></a>延伸：操作远程主机</h1><p>&emsp;&emsp;既然docker client通过socket方式与本地的Docker Daemon进行通信，那么我们可以很自然地想到，如果想在其他主机上通过socket连接到远程DockerDaemon，是不是可以远程操作Docker主机进行镜像的构建与运行呢？答案是可以的，就需要让Docker守护进程监听一个端口，这样才能实现远程通信，同时需要修改docker客户端连接的主机是远程地址而并非本地sock文件。由于Docker C/S 之间采取Rest API作为通信协议，这为我们使用第三方客户端（如postman）操作docker乃至自己开发client提供了扩展。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2019/07/19/principles/binary_tree/</url>
    <content><![CDATA[<p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有深度遍历和广度遍历，深度遍历有前序、中序以及后序三种遍历方法，广度遍历即我们平常所说的层次遍历。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁，而对于广度遍历来说，需要其他数据结构的支撑，比如堆了。所以，对于一段代码来说，可读性有时候要比代码本身的效率要重要的多。</p>
<p>四种主要的遍历思想为：</p>
<p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>
<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>层次遍历：只需按层次遍历即可</p>
<p><img src="/images/principles/binary_tree1.jpg" alt="二叉树"></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>编码规则</title>
    <url>/2019/07/19/principles/rule/</url>
    <content><![CDATA[<h1 id="编码铁律"><a href="#编码铁律" class="headerlink" title="编码铁律"></a>编码铁律</h1><blockquote>
<p>注释</p>
</blockquote>
<blockquote>
<p>测试</p>
</blockquote>
<blockquote>
<p>日志</p>
</blockquote>
<a id="more"></a>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>docker使用过程中遇到的一些问题</title>
    <url>/2019/07/18/docker/problem/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="docker-通过http连接私有仓库"><a href="#docker-通过http连接私有仓库" class="headerlink" title="docker 通过http连接私有仓库"></a>docker 通过http连接私有仓库</h1><ol>
<li>需要在 <code>/lib/systemd/system/docker.service</code> 启动文件增加配置 <code>--insecure-registry=&#123;ip&#125;</code></li>
<li>reload 系统启动项 <code>systemctl daemon-reload</code></li>
<li>重启docker <code>systemctl restart docker</code></li>
</ol>
<p>即可在使用私有仓库 <code>docker login -u &#123;user&#125; -p &#123;password&#125; &#123;ip&#125;</code></p>
]]></content>
      <categories>
        <category>踩坑遇雷</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Go中使用grpc</title>
    <url>/2019/07/18/golang/grpc/</url>
    <content><![CDATA[<h1 id="GRPC-在golang-中的应用"><a href="#GRPC-在golang-中的应用" class="headerlink" title="GRPC 在golang 中的应用"></a>GRPC 在golang 中的应用</h1><h3 id="GRPC-vs-RestFul-API"><a href="#GRPC-vs-RestFul-API" class="headerlink" title="GRPC vs RestFul API"></a>GRPC vs RestFul API</h3><p>gRPC和restful API都提供了一套通信机制，用于server/client模型通信，而且它们都使用http作为底层的传输协议(严格地说, gRPC使用的http2.0，而restful api则不一定)。不过gRPC还是有些特有的优势，如下：</p>
<blockquote>
<p>gRPC可以通过protobuf来定义接口，从而可以有更加严格的接口约束条件</p>
</blockquote>
<blockquote>
<p>通过protobuf可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能</p>
</blockquote>
<blockquote>
<p>gRPC可以方便地支持流式通信(理论上通过http2.0就可以使用streaming模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如HLS，RTMP等，这些就不是我们通常web服务了，而是有专门的服务器应用</p>
</blockquote>
<a id="more"></a>

<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>需要对接口进行严格约束的情况，比如我们提供了一个公共的服务，很多人，甚至公司外部的人也可以访问这个服务，这时对于接口我们希望有更加严格的约束，我们不希望客户端给我们传递任意的数据，尤其是考虑到安全性的因素，我们通常需要对接口进行更加严格的约束。这时gRPC就可以通过protobuf来提供严格的接口约束。</li>
<li>对于性能有更高的要求时。有时我们的服务需要传递大量的数据，而又希望不影响我们的性能，这个时候也可以考虑gRPC服务，因为通过protobuf我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过http2我们可以实现异步的请求，从而大大提高了通信效率。</li>
</ul>
<h3 id="GRPC-的四种模式"><a href="#GRPC-的四种模式" class="headerlink" title="GRPC 的四种模式"></a>GRPC 的四种模式</h3><h4 id="一、简单模式"><a href="#一、简单模式" class="headerlink" title="一、简单模式"></a>一、简单模式</h4><p>简单模式只是使用参数和返回值作为服务器与客户端传递数据的方式，最简单。</p>
<h4 id="二、客户端流模式"><a href="#二、客户端流模式" class="headerlink" title="二、客户端流模式"></a>二、客户端流模式</h4><p>即从客户端往服务器端发送数据使用的是流，即服务器端的参数为流类型，然而在服务器相应后返还数据给客户端，使用的也是流的send方法。一般在服务器端的代码，需要先recv再send，而客户端与此相反。但是在后面的双向模式中可以使用go的协程协作。</p>
<h4 id="三、服务端流模式"><a href="#三、服务端流模式" class="headerlink" title="三、服务端流模式"></a>三、服务端流模式</h4><p>即服务器端返回结果的时候使用的是流模式，即传入的数据是通过参数形式传入的。但是在往客户端发送数据时使用send方法，与客户端返回数据的方式大同小异</p>
<h4 id="四、双向流模式"><a href="#四、双向流模式" class="headerlink" title="四、双向流模式"></a>四、双向流模式</h4><p>客户端如果不使用协程，那么发送必须在接收之前。如果使用协程，发送与接收并没有先后顺序。为了保证协程的同步，可以使用互斥量进行约束。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 基础</title>
    <url>/2019/07/17/golang/go_base/</url>
    <content><![CDATA[<h1 id="你好，Go"><a href="#你好，Go" class="headerlink" title="你好，Go"></a>你好，Go</h1><p>在开始编写应用之前，我们先从最基本的程序开始。就像你造房子之前不知道什么是地基一样，编写程序也不知道如何开始。因此，在本节中，我们要学习用最基本的语法让Go程序运行起来。</p>
<a id="more"></a>

<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>这就像一个传统，在学习大部分语言之前，你先学会如何编写一个可以输出<code>hello world</code>的程序。</p>
<p>准备好了吗？Let’s Go!</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hello, world or 你好，世界 or καλημ ́ρα κóσμ or こんにちはせかい\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<pre><code>Hello, world or 你好，世界 or καλημ ́ρα κóσμ or こんにちはせかい</code></pre>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>首先我们要了解一个概念，Go程序是通过<code>package</code>来组织的</p>
<p><code>package &lt;pkgName&gt;</code>（在我们的例子中是<code>package main</code>）这一行告诉我们当前文件属于哪个包，而包名<code>main</code>则告诉我们它是一个可独立运行的包，它在编译后会产生可执行文件。除了<code>main</code>包之外，其它的包最后都会生成<code>*.a</code>文件（也就是包文件）并放置在<code>$GOPATH/pkg/$GOOS_$GOARCH</code>中（以Mac为例就是<code>$GOPATH/pkg/darwin_amd64</code>）。</p>
<blockquote>
<p>每一个可独立运行的Go程序，必定包含一个<code>package main</code>，在这个<code>main</code>包中必定包含一个入口函数<code>main</code>，而这个函数既没有参数，也没有返回值。</p>
</blockquote>
<p>为了打印<code>Hello, world...</code>，我们调用了一个函数<code>Printf</code>，这个函数来自于<code>fmt</code>包，所以我们在第三行中导入了系统级别的<code>fmt</code>包：<code>import &quot;fmt&quot;</code>。</p>
<p>包的概念和Python中的package类似，它们都有一些特别的好处：模块化（能够把你的程序分成多个模块)和可重用性（每个模块都能被其它应用程序反复使用）。我们在这里只是先了解一下包的概念，后面我们将会编写自己的包。</p>
<p>在第五行中，我们通过关键字<code>func</code>定义了一个<code>main</code>函数，函数体被放在<code>&#123;&#125;</code>（大括号）中，就像我们平时写C、C++或Java时一样。</p>
<p>大家可以看到<code>main</code>函数是没有任何的参数的，我们接下来就学习如何编写带参数的、返回0个或多个值的函数。</p>
<p>第六行，我们调用了<code>fmt</code>包里面定义的函数<code>Printf</code>。大家可以看到，这个函数是通过<code>&lt;pkgName&gt;.&lt;funcName&gt;</code>的方式调用的，这一点和Python十分相似。</p>
<blockquote>
<p>前面提到过，包名和包所在的文件夹名可以是不同的，此处的<code>&lt;pkgName&gt;</code>即为通过<code>package &lt;pkgName&gt;</code>声明的包名，而非文件夹名。</p>
</blockquote>
<p>最后大家可以看到我们输出的内容里面包含了很多非ASCII码字符。实际上，Go是天生支持UTF-8的，任何字符都可以直接输出，你甚至可以用UTF-8中的任何字符作为标识符。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Go使用<code>package</code>（和Python的模块类似）来组织代码。<code>main.main()</code>函数(这个函数位于主包）是每一个独立的可运行程序的入口点。Go使用UTF-8字符串和标识符(因为UTF-8的发明者也就是Go的发明者之一)，所以它天生支持多语言。</p>
<h1 id="Go基础"><a href="#Go基础" class="headerlink" title="Go基础"></a>Go基础</h1><p>这小节我们将要介绍如何定义变量、常量、Go内置类型以及Go程序设计中的一些技巧。</p>
<h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><p>Go语言里面定义变量有多种方式。</p>
<p>使用<code>var</code>关键字是Go最基本的定义变量方式，与C语言不同的是Go把变量类型放在变量名后面：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义三个类型都是“type”的变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>定义变量并初始化值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//初始化“variableName”的变量为“value”值，类型是“type”</span></span><br><span class="line"><span class="keyword">var</span> variableName <span class="keyword">type</span> = value</span><br></pre></td></tr></table></figure>

<p>同时初始化多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	定义三个类型都是&quot;type&quot;的变量,并且分别初始化为相应的值</span></span><br><span class="line"><span class="comment">	vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span>= v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>你是不是觉得上面这样的定义有点繁琐？没关系，因为Go语言的设计者也发现了，有一种写法可以让它变得简单一点。我们可以直接忽略类型声明，那么上面的代码变成这样了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">	vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">	然后Go会根据其相应值的类型来帮你初始化它们</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>你觉得上面的还是有些繁琐？好吧，我也觉得。让我们继续简化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	定义三个变量，它们分别初始化为相应的值</span></span><br><span class="line"><span class="comment">	vname1为v1，vname2为v2，vname3为v3</span></span><br><span class="line"><span class="comment">	编译器会根据初始化的值自动推导出相应的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>现在是不是看上去非常简洁了？<code>:=</code>这个符号直接取代了<code>var</code>和<code>type</code>,这种形式叫做简短声明。不过它有一个限制，那就是它只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用<code>var</code>方式来定义全局变量。</p>
<p><code>_</code>（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，我们将值<code>35</code>赋予<code>b</code>，并同时丢弃<code>34</code>：</p>
<pre><code>_, b := 34, 35</code></pre>
<p>Go对于已声明但未使用的变量会在编译阶段报错，比如下面的代码就会产生一个错误：声明了<code>i</code>但未使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p>
<p>它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> constantName = value</span><br><span class="line"><span class="comment">//如果需要，也可以明确指定常量的类型：</span></span><br><span class="line"><span class="keyword">const</span> Pi <span class="keyword">float32</span> = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<p>下面是一些常量声明的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.1415926</span></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> MaxThread = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;astaxie_&quot;</span></span><br></pre></td></tr></table></figure>

<p>Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)，<br>若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit，详情参考<a class="link"   href="http://golang.org/ref/spec#Constants" >链接<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="内置基础类型"><a href="#内置基础类型" class="headerlink" title="内置基础类型"></a>内置基础类型</h2><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> isActive <span class="keyword">bool</span>  <span class="comment">// 全局变量声明</span></span><br><span class="line"><span class="keyword">var</span> enabled, disabled = <span class="literal">true</span>, <span class="literal">false</span>  <span class="comment">// 忽略类型的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> available <span class="keyword">bool</span>  <span class="comment">// 一般声明</span></span><br><span class="line">	valid := <span class="literal">false</span>      <span class="comment">// 简短声明</span></span><br><span class="line">	available = <span class="literal">true</span>    <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p>
<blockquote>
<p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错。</p>
<p>如下的代码会产生错误：invalid operation: a + b (mismatched types int8 and int32)</p>
<blockquote>
<p>   var a int8</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>   var b int32</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>   c:=a + b</p>
</blockquote>
<p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p>
</blockquote>
<p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code>。</p>
<p>这就是全部吗？No！Go还支持复数。它的默认类型是<code>complex128</code>（64位实数+64位虚数）。如果需要小一些的，也有<code>complex64</code>(32位实数+32位虚数)。复数的形式为<code>RE + IMi</code>，其中<code>RE</code>是实数部分，<code>IM</code>是虚数部分，而最后的<code>i</code>是虚数单位。下面是一个使用复数的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">complex64</span> = <span class="number">5</span>+<span class="number">5i</span></span><br><span class="line"><span class="comment">//output: (5+5i)</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Value is: %v&quot;</span>, c)</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>我们在上一节中讲过，Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（<code>&quot;&quot;</code>）或反引号（<code>`</code> <code>`</code>）括起来定义，它的类型是<code>string</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="keyword">var</span> frenchHello <span class="keyword">string</span>  <span class="comment">// 声明变量为字符串的一般方法</span></span><br><span class="line"><span class="keyword">var</span> emptyString <span class="keyword">string</span> = <span class="string">&quot;&quot;</span>  <span class="comment">// 声明了一个字符串变量，初始化为空字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	no, yes, maybe := <span class="string">&quot;no&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;maybe&quot;</span>  <span class="comment">// 简短声明，同时声明多个变量</span></span><br><span class="line">	japaneseHello := <span class="string">&quot;Konichiwa&quot;</span>  <span class="comment">// 同上</span></span><br><span class="line">	frenchHello = <span class="string">&quot;Bonjour&quot;</span>  <span class="comment">// 常规赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但如果真的想要修改怎么办呢？下面的代码可以实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">c := []<span class="keyword">byte</span>(s)  <span class="comment">// 将字符串 s 转换为 []byte 类型</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">s2 := <span class="keyword">string</span>(c)  <span class="comment">// 再转换回 string 类型</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s2)</span><br></pre></td></tr></table></figure>

<p>Go中可以使用<code>+</code>操作符来连接两个字符串：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">s := <span class="string">&quot;hello,&quot;</span></span><br><span class="line">m := <span class="string">&quot; world&quot;</span></span><br><span class="line">a := s + m</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, a)</span><br></pre></td></tr></table></figure>
<p>修改字符串也可写为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s = <span class="string">&quot;c&quot;</span> + s[<span class="number">1</span>:] <span class="comment">// 字符串虽不能更改，但可进行切片操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure>
<p>如果要声明一个多行的字符串怎么办？可以通过<code>``</code>来声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="string">`hello</span></span><br><span class="line"><span class="string">world`</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>`` ```` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">hello</span><br><span class="line"></span><br><span class="line">world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 错误类型</span><br><span class="line">Go内置有一个&#96;error&#96;类型，专门用来处理错误信息，Go的&#96;package&#96;里面还专门有一个包&#96;errors&#96;来处理错误：</span><br><span class="line">&#96;&#96;&#96;Go</span><br><span class="line"></span><br><span class="line">err :&#x3D; errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)</span><br><span class="line">if err !&#x3D; nil &#123;</span><br><span class="line">	fmt.Print(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Go数据底层的存储"><a href="#Go数据底层的存储" class="headerlink" title="Go数据底层的存储"></a>Go数据底层的存储</h3><p>下面这张图来源于<a class="link"   href="http://research.swtch.com/" >Russ Cox Blog<i class="fas fa-external-link-alt"></i></a>中一篇介绍<a class="link"   href="http://research.swtch.com/godata" >Go数据结构<i class="fas fa-external-link-alt"></i></a>的文章，大家可以看到这些基础类型底层都是分配了一块内存，然后存储了相应的值。</p>
<p><img src="/images/golang/basic.png?raw=true"></p>
<p>图2.1 Go数据格式的存储</p>
<h2 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h2><h3 id="分组声明"><a href="#分组声明" class="headerlink" title="分组声明"></a>分组声明</h3><p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。</p>
<p>例如下面的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> pi <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> prefix <span class="keyword">string</span></span><br></pre></td></tr></table></figure>
<p>可以分组写成如下形式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	i = <span class="number">100</span></span><br><span class="line">	pi = <span class="number">3.1415</span></span><br><span class="line">	prefix = <span class="string">&quot;Go_&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">	i <span class="keyword">int</span></span><br><span class="line">	pi <span class="keyword">float32</span></span><br><span class="line">	prefix <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="iota枚举"><a href="#iota枚举" class="headerlink" title="iota枚举"></a>iota枚举</h3><p>Go里面有一个关键字<code>iota</code>，这个关键字用来声明<code>enum</code>的时候采用，它默认开始值是0，const中每增加一行加1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	x = <span class="literal">iota</span> <span class="comment">// x == 0</span></span><br><span class="line">	y = <span class="literal">iota</span> <span class="comment">// y == 1</span></span><br><span class="line">	z = <span class="literal">iota</span> <span class="comment">// z == 2</span></span><br><span class="line">	w        <span class="comment">// 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> v = <span class="literal">iota</span> <span class="comment">// 每遇到一个const关键字，iota就会重置，此时v == 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	h, i, j = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//h=0,i=0,j=0 iota在同一行值相同</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a       = <span class="literal">iota</span> <span class="comment">//a=0</span></span><br><span class="line">	b       = <span class="string">&quot;B&quot;</span></span><br><span class="line">	c       = <span class="literal">iota</span>             <span class="comment">//c=2</span></span><br><span class="line">	d, e, f = <span class="literal">iota</span>, <span class="literal">iota</span>, <span class="literal">iota</span> <span class="comment">//d=3,e=3,f=3</span></span><br><span class="line">	g       = <span class="literal">iota</span>             <span class="comment">//g = 4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除非被显式设置为其它值或<code>iota</code>，每个<code>const</code>分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是<code>iota</code>，则它也被设置为<code>iota</code>。</p>
</blockquote>
<h3 id="Go程序设计的一些规则"><a href="#Go程序设计的一些规则" class="headerlink" title="Go程序设计的一些规则"></a>Go程序设计的一些规则</h3><p>Go之所以会那么简洁，是因为它有一些默认的行为：</p>
<ul>
<li>大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。</li>
<li>大写字母开头的函数也是一样，相当于<code>class</code>中的带<code>public</code>关键词的公有函数；小写字母开头的就是有<code>private</code>关键词的私有函数。</li>
</ul>
<h2 id="array、slice、map"><a href="#array、slice、map" class="headerlink" title="array、slice、map"></a>array、slice、map</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p><code>array</code>就是数组，它的定义方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr [n]<span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">10</span>]<span class="keyword">int</span>  <span class="comment">// 声明了一个int类型的数组</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">42</span>      <span class="comment">// 数组下标是从0开始的</span></span><br><span class="line">arr[<span class="number">1</span>] = <span class="number">13</span>      <span class="comment">// 赋值操作</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The first element is %d\n&quot;</span>, arr[<span class="number">0</span>])  <span class="comment">// 获取数据，返回42</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The last element is %d\n&quot;</span>, arr[<span class="number">9</span>]) <span class="comment">//返回未赋值的最后一个元素，默认返回0</span></span><br></pre></td></tr></table></figure>
<p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p>
<p>数组可以使用另一种<code>:=</code>来声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为3的int数组</span></span><br><span class="line"></span><br><span class="line">b := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">// 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span></span><br><span class="line"></span><br><span class="line">c := [...]<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125; <span class="comment">// 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span></span><br></pre></td></tr></table></figure>
<p>也许你会说，我想数组里面的值还是数组，能实现吗？当然咯，Go支持嵌套数组，即多维数组。比如下面的代码就声明了一个二维数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span></span><br><span class="line">doubleArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;[<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的声明可以简化，直接忽略内部的类型</span></span><br><span class="line">easyArray := [<span class="number">2</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>数组的分配如下所示：</p>
<p><img src="/images/golang/array.png?raw=true"></p>
<p>图2.2 多维数组的映射关系</p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>在很多应用场景中，数组并不能满足我们的需求。在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p>
<p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 和声明array一样，只是少了长度</span></span><br><span class="line"><span class="keyword">var</span> fslice []<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>接下来我们可以声明一个<code>slice</code>，并初始化数据，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">slice := []<span class="keyword">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明一个含有10个元素元素类型为byte的数组</span></span><br><span class="line"><span class="keyword">var</span> ar = [<span class="number">10</span>]<span class="keyword">byte</span> &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明两个含有byte的slice</span></span><br><span class="line"><span class="keyword">var</span> a, b []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a指向数组的第3个元素开始，并到第五个元素结束，</span></span><br><span class="line">a = ar[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b是数组ar的另一个slice</span></span><br><span class="line">b = ar[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment">// b的元素是：ar[3]和ar[4]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p>
</blockquote>
<p>它们的数据结构如下所示</p>
<p><img src="/images/gloang/slice.png?raw=true"></p>
<p>图2.3 slice和array的对应关系图</p>
<p>slice有一些简便的操作</p>
<ul>
<li><code>slice</code>的默认开始位置是0，<code>ar[:n]</code>等价于<code>ar[0:n]</code></li>
<li><code>slice</code>的第二个序列默认是数组的长度，<code>ar[n:]</code>等价于<code>ar[n:len(ar)]</code></li>
<li>如果从一个数组里面直接获取<code>slice</code>，可以这样<code>ar[:]</code>，因为默认第一个序列是0，第二个是数组的长度，即等价于<code>ar[0:len(ar)]</code></li>
</ul>
<p>下面这个例子展示了更多关于<code>slice</code>的操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="keyword">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line"><span class="comment">// 声明两个slice</span></span><br><span class="line"><span class="keyword">var</span> aSlice, bSlice []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示一些简便操作</span></span><br><span class="line">aSlice = array[:<span class="number">3</span>] <span class="comment">// 等价于aSlice = array[0:3] aSlice包含元素: a,b,c</span></span><br><span class="line">aSlice = array[<span class="number">5</span>:] <span class="comment">// 等价于aSlice = array[5:10] aSlice包含元素: f,g,h,i,j</span></span><br><span class="line">aSlice = array[:]  <span class="comment">// 等价于aSlice = array[0:10] 这样aSlice包含了全部的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从slice中获取slice</span></span><br><span class="line">aSlice = array[<span class="number">3</span>:<span class="number">7</span>]  <span class="comment">// aSlice包含元素: d,e,f,g，len=4，cap=7</span></span><br><span class="line">bSlice = aSlice[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">// bSlice 包含aSlice[1], aSlice[2] 也就是含有: e,f</span></span><br><span class="line">bSlice = aSlice[:<span class="number">3</span>]  <span class="comment">// bSlice 包含 aSlice[0], aSlice[1], aSlice[2] 也就是含有: d,e,f</span></span><br><span class="line">bSlice = aSlice[<span class="number">0</span>:<span class="number">5</span>] <span class="comment">// 对slice的slice可以在cap范围内扩展，此时bSlice包含：d,e,f,g,h</span></span><br><span class="line">bSlice = aSlice[:]   <span class="comment">// bSlice包含所有aSlice的元素: d,e,f,g</span></span><br></pre></td></tr></table></figure>
<p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>aSlice</code>中元素的值，那么<code>bSlice</code>相对应的值也会改变。</p>
<p>从概念上面来说<code>slice</code>像一个结构体，这个结构体包含了三个元素：</p>
<ul>
<li>一个指针，指向数组中<code>slice</code>指定的开始位置</li>
<li>长度，即<code>slice</code>的长度</li>
<li>最大长度，也就是<code>slice</code>开始位置到数组的最后位置的长度<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Array_a := [<span class="number">10</span>]<span class="keyword">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>&#125;</span><br><span class="line">Slice_a := Array_a[<span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
上面代码的真正存储结构如下图所示</li>
</ul>
<p><img src="/images/golang/slice2.png?raw=true"></p>
<p>图2.4 slice对应数组的信息</p>
<p>对于<code>slice</code>有几个有用的内置函数：</p>
<ul>
<li><code>len</code>    获取<code>slice</code>的长度</li>
<li><code>cap</code>    获取<code>slice</code>的最大容量</li>
<li><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></li>
<li><code>copy</code>   函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</li>
</ul>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。<br>但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<p>从Go1.2开始slice支持了三个参数的slice，之前我们一直采用这种方式在slice或者array基础上来获取一个slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">slice := array[<span class="number">2</span>:<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>这个例子里面slice的容量是8，新版本里面可以指定这个容量</p>
<pre><code>slice = array[2:4:7]</code></pre>
<p>上面这个的容量就是<code>7-2</code>，即5。这样这个产生的新的slice就没办法访问最后的三个元素。</p>
<p>如果slice是这样的形式<code>array[:i:j]</code>，即第一个参数为空，默认值就是0。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code>也就是Python中字典的概念，它的格式为<code>map[keyType]valueType</code></p>
<p>我们看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是｀int｀类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span></span><br><span class="line"><span class="keyword">var</span> numbers <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 另一种map的声明方式</span></span><br><span class="line">numbers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">numbers[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>  <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;ten&quot;</span>] = <span class="number">10</span> <span class="comment">//赋值</span></span><br><span class="line">numbers[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;第三个数字是: &quot;</span>, numbers[<span class="string">&quot;three&quot;</span>]) <span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 打印出来如:第三个数字是: 3</span></span><br></pre></td></tr></table></figure>

<p>这个<code>map</code>就像我们平常看到的表格一样，左边列是<code>key</code>，右边列是值</p>
<p>使用map过程中需要注意的几点：</p>
<ul>
<li><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</li>
<li><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</li>
<li>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</li>
<li><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></li>
<li><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个字典</span></span><br><span class="line">rating := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float32</span>&#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line"><span class="comment">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span></span><br><span class="line">csharpRating, ok := rating[<span class="string">&quot;C#&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;C# is in the map and its rating is &quot;</span>, csharpRating)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;We have no rating associated with C# in the map&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(rating, <span class="string">&quot;C&quot;</span>)  <span class="comment">// 删除key为C的元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Bonjour&quot;</span></span><br><span class="line">m1 := m</span><br><span class="line">m1[<span class="string">&quot;Hello&quot;</span>] = <span class="string">&quot;Salut&quot;</span>  <span class="comment">// 现在m[&quot;hello&quot;]的值已经是Salut了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="make、new操作"><a href="#make、new操作" class="headerlink" title="make、new操作"></a>make、new操作</h3><p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p>
<p>内建函数<code>new</code>本质上说跟其它语言中的同名函数功能一样：<code>new(T)</code>分配了零值填充的<code>T</code>类型的内存空间，并且返回其地址，即一个<code>*T</code>类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型<code>T</code>的零值。有一点非常重要：</p>
<blockquote>
<p><code>new</code>返回指针。</p>
</blockquote>
<p>内建函数<code>make(T, args)</code>与<code>new(T)</code>有着不同的功能，make只能创建<code>slice</code>、<code>map</code>和<code>channel</code>，并且返回一个有初始值(非零)的<code>T</code>类型，而不是<code>*T</code>。本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个<code>slice</code>，是一个包含指向数据（内部<code>array</code>）的指针、长度和容量的三项描述符；在这些项目被初始化之前，<code>slice</code>为<code>nil</code>。对于<code>slice</code>、<code>map</code>和<code>channel</code>来说，<code>make</code>初始化了内部的数据结构，填充适当的值。</p>
<blockquote>
<p><code>make</code>返回初始化后的（非零）值。</p>
</blockquote>
<p>下面这个图详细的解释了<code>new</code>和<code>make</code>之间的区别。</p>
<p><img src="/images/golang/makenew.png?raw=true"></p>
<p>图2.5 make和new对应底层的内存分配</p>
<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。<br>此处罗列 部分类型 的 “零值”</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>     <span class="number">0</span></span><br><span class="line"><span class="keyword">int8</span>    <span class="number">0</span></span><br><span class="line"><span class="keyword">int32</span>   <span class="number">0</span></span><br><span class="line"><span class="keyword">int64</span>   <span class="number">0</span></span><br><span class="line"><span class="keyword">uint</span>    <span class="number">0x0</span></span><br><span class="line"><span class="keyword">rune</span>    <span class="number">0</span> <span class="comment">//rune的实际类型是 int32</span></span><br><span class="line"><span class="keyword">byte</span>    <span class="number">0x0</span> <span class="comment">// byte的实际类型是 uint8</span></span><br><span class="line"><span class="keyword">float32</span> <span class="number">0</span> <span class="comment">//长度为 4 byte</span></span><br><span class="line"><span class="keyword">float64</span> <span class="number">0</span> <span class="comment">//长度为 8 byte</span></span><br><span class="line"><span class="keyword">bool</span>    <span class="literal">false</span></span><br><span class="line"><span class="keyword">string</span>  <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="流程和函数"><a href="#流程和函数" class="headerlink" title="流程和函数"></a>流程和函数</h1><p>这小节我们要介绍Go里面的流程控制以及函数操作。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程控制在编程语言中是最伟大的发明了，因为有了它，你可以通过很简单的流程描述来表达很复杂的逻辑。Go中流程控制分三大类：条件判断，循环控制和无条件跳转。</p>
<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p><code>if</code>也许是各种编程语言中最常见的了，它的语法概括起来就是：如果满足条件就做某事，否则做另一件事。</p>
<p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go的<code>if</code>还有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span></span><br><span class="line"><span class="keyword">if</span> x := computedValue(); x &gt; <span class="number">10</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;x is greater than 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;x is less than 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个地方如果这样调用就编译出错了，因为x是条件里面的变量</span></span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>
<p>多个条件的时候如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> integer == <span class="number">3</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;The integer is equal to 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> integer &lt; <span class="number">3</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;The integer is less than 3&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;The integer is greater than 3&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><p>Go有<code>goto</code>语句——请明智地使用它。用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">Here:   <span class="comment">//这行的第一个词，以冒号结束作为标签</span></span><br><span class="line">	<span class="built_in">println</span>(i)</span><br><span class="line">	i++</span><br><span class="line">	<span class="keyword">goto</span> Here   <span class="comment">//跳转到Here去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>标签名是大小写敏感的。</p>
</blockquote>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>Go里面最强大的一个控制逻辑就是<code>for</code>，它既可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> expression1; expression2; expression3 &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，那么我们看看下面的例子吧：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sum := <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> index:=<span class="number">0</span>; index &lt; <span class="number">10</span> ; index++ &#123;</span><br><span class="line">		sum += index</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;sum is equal to &quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：sum is equal to 45</span></span><br></pre></td></tr></table></figure>
<p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p>
<p>有些时候如果我们忽略<code>expression1</code>和<code>expression3</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>;  &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>;</code>也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是<code>while</code>的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">	sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环里面有两个关键操作<code>break</code>和<code>continue</code>    ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>可以配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">10</span>; index&gt;<span class="number">0</span>; index-- &#123;</span><br><span class="line">	<span class="keyword">if</span> index == <span class="number">5</span>&#123;</span><br><span class="line">		<span class="keyword">break</span> <span class="comment">// 或者continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// break打印出来10、9、8、7、6</span></span><br><span class="line"><span class="comment">// continue打印出来10、9、8、7、6、4、3、2、1</span></span><br></pre></td></tr></table></figure>
<p><code>break</code>和<code>continue</code>还可以跟着标号，用来跳到多重循环中的外层循环</p>
<p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;map&#x27;s key:&quot;</span>,k)</span><br><span class="line">	fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值<br>例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;map&#x27;s val:&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>有些时候你需要写很多的<code>if-else</code>来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维护，这个时候<code>switch</code>就能很好的解决这个问题。它的语法如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span> sExpr &#123;</span><br><span class="line"><span class="keyword">case</span> expr1:</span><br><span class="line">	some instructions</span><br><span class="line"><span class="keyword">case</span> expr2:</span><br><span class="line">	some other instructions</span><br><span class="line"><span class="keyword">case</span> expr3:</span><br><span class="line">	some other instructions</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sExpr</code>和<code>expr1</code>、<code>expr2</code>、<code>expr3</code>的类型必须一致。Go的<code>switch</code>非常灵活，表达式不必是常量或整数，执行的过程从上至下，直到找到匹配项；而如果<code>switch</code>没有表达式，它会匹配<code>true</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">i := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;i is equal to 1&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;i is equal to 2, 3 or 4&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;i is equal to 10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;All I know is that i is an integer&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第5行中，我们把很多值聚合在了一个<code>case</code>里面，同时，Go里面<code>switch</code>默认相当于每个<code>case</code>最后带有<code>break</code>，匹配成功后不会自动向下执行其他case，而是跳出整个<code>switch</code>, 但是可以使用<code>fallthrough</code>强制执行后面的case代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">integer := <span class="number">6</span></span><br><span class="line"><span class="keyword">switch</span> integer &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;The integer was &lt;= 4&quot;</span>)</span><br><span class="line">	<span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;The integer was &lt;= 5&quot;</span>)</span><br><span class="line">	<span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;The integer was &lt;= 6&quot;</span>)</span><br><span class="line">	<span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;The integer was &lt;= 7&quot;</span>)</span><br><span class="line">	<span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;The integer was &lt;= 8&quot;</span>)</span><br><span class="line">	<span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;default case&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序将输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">The integer was &lt;= <span class="number">6</span></span><br><span class="line">The integer was &lt;= <span class="number">7</span></span><br><span class="line">The integer was &lt;= <span class="number">8</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">case</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是Go里面的核心设计，它通过关键字<code>func</code>来声明，它的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(input1 type1, input2 type2)</span> <span class="params">(output1 type1, output2 type2)</span></span> &#123;</span><br><span class="line">	<span class="comment">//这里是处理逻辑代码</span></span><br><span class="line">	<span class="comment">//返回多个值</span></span><br><span class="line">	<span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码我们看出</p>
<ul>
<li>关键字<code>func</code>用来声明一个函数<code>funcName</code></li>
<li>函数可以有一个或者多个参数，每个参数后面带有类型，通过<code>,</code>分隔</li>
<li>函数可以返回多个值</li>
<li>上面返回值声明了两个变量<code>output1</code>和<code>output2</code>，如果你不想声明也可以，直接就两个类型</li>
<li>如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号</li>
<li>如果没有返回值，那么就直接省略最后的返回信息</li>
<li>如果有返回值， 那么必须在函数的外层添加return语句</li>
</ul>
<p>下面我们来看一个实际应用函数的例子（用来计算Max值）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回a、b中最大值.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">3</span></span><br><span class="line">	y := <span class="number">4</span></span><br><span class="line">	z := <span class="number">5</span></span><br><span class="line"></span><br><span class="line">	max_xy := max(x, y) <span class="comment">//调用函数max(x, y)</span></span><br><span class="line">	max_xz := max(x, z) <span class="comment">//调用函数max(x, z)</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, y, max_xy)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, x, z, max_xz)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;max(%d, %d) = %d\n&quot;</span>, y, z, max(y,z)) <span class="comment">// 也可在这直接调用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个里面我们可以看到<code>max</code>函数有两个参数，它们的类型都是<code>int</code>，那么第一个变量的类型可以省略（即 a,b int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时我们注意到它的返回值就是一个类型，这个就是省略写法。</p>
<h3 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h3><p>Go语言比C更先进的特性，其中一点就是函数能够返回多个值。</p>
<p>我们直接上代码看例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 A+B 和 A*B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">3</span></span><br><span class="line">	y := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">	xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>, x, y, xPLUSy)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子我们可以看到直接返回了两个参数，当然我们也可以命名返回参数的变量，这个例子里面只是用了两个类型，我们也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果你的函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="keyword">int</span>)</span> <span class="params">(add <span class="keyword">int</span>, Multiplied <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	add = A+B</span><br><span class="line">	Multiplied = A*B</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变参"><a href="#变参" class="headerlink" title="变参"></a>变参</h3><p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myfunc</span><span class="params">(arg ...<span class="keyword">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, n := <span class="keyword">range</span> arg &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;And the number is: %d\n&quot;</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传值与传指针"><a href="#传值与传指针" class="headerlink" title="传值与传指针"></a>传值与传指针</h3><p>当我们传一个参数值到被调用函数里面时，实际上是传了这个值的一份copy，当在被调用函数中修改参数值的时候，调用函数中相应实参不会发生任何变化，因为数值变化只作用在copy上。</p>
<p>为了验证我们上面的说法，我们来看一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	a = a+<span class="number">1</span> <span class="comment">// 我们改变了a的值</span></span><br><span class="line">	<span class="keyword">return</span> a <span class="comment">//返回一个新值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line"></span><br><span class="line">	x1 := add1(x)  <span class="comment">//调用add1(x)</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出&quot;x+1 = 4&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出&quot;x = 3&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了吗？虽然我们调用了<code>add1</code>函数，并且在<code>add1</code>中执行<code>a = a+1</code>操作，但是上面例子中<code>x</code>变量的值没有发生变化</p>
<p>理由很简单：因为当我们调用<code>add1</code>的时候，<code>add1</code>接收的参数其实是<code>x</code>的copy，而不是<code>x</code>本身。</p>
<p>那你也许会问了，如果真的需要传这个<code>x</code>本身,该怎么办呢？</p>
<p>这就牵扯到了所谓的指针。我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。只有<code>add1</code>函数知道<code>x</code>变量所在的地址，才能修改<code>x</code>变量的值。所以我们需要将<code>x</code>所在地址<code>&amp;x</code>传入函数，并将函数的参数的类型由<code>int</code>改为<code>*int</code>，即改为指针类型，才能在函数中修改<code>x</code>变量的值。此时参数仍然是按copy传递的，只是copy的是一个指针。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">	*a = *a+<span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line">	<span class="keyword">return</span> *a <span class="comment">// 返回新值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;x = &quot;</span>, x)  <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line"></span><br><span class="line">	x1 := add1(&amp;x)  <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;x = &quot;</span>, x)    <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就达到了修改<code>x</code>的目的。那么到底传指针有什么好处呢？</p>
<ul>
<li>传指针使得多个函数能操作同一个对象。</li>
<li>传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。</li>
<li>Go语言中<code>channel</code>，<code>slice</code>，<code>map</code>这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变<code>slice</code>的长度，则仍需要取地址传递指针）</li>
</ul>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>Go语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。如下代码所示，我们一般写打开一个资源是这样操作的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="comment">// 做一些工作</span></span><br><span class="line">	<span class="keyword">if</span> failureX &#123;</span><br><span class="line">		file.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> failureY &#123;</span><br><span class="line">		file.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	file.Close()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到上面有很多重复的代码，Go的<code>defer</code>有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在<code>defer</code>后指定的函数会在函数退出前调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="keyword">if</span> failureX &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> failureY &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有很多调用<code>defer</code>，那么<code>defer</code>是采用后进先出模式，所以如下代码会输出<code>4 3 2 1 0</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数作为值、类型"><a href="#函数作为值、类型" class="headerlink" title="函数作为值、类型"></a>函数作为值、类型</h3><p>在Go中函数也是一种变量，我们可以通过<code>type</code>来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型</p>
<pre><code>type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...])</code></pre>
<p>函数作为类型到底有什么好处呢？那就是可以把这个类型的函数当做值来传递，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> testInt <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span> // 声明了一个函数类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isOdd</span><span class="params">(integer <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEven</span><span class="params">(integer <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> integer%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明的函数类型在这个地方当做了一个参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(slice []<span class="keyword">int</span>, f testInt)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">		<span class="keyword">if</span> f(value) &#123;</span><br><span class="line">			result = <span class="built_in">append</span>(result, value)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	slice := []<span class="keyword">int</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice = &quot;</span>, slice)</span><br><span class="line">	odd := filter(slice, isOdd)    <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Odd elements of slice are: &quot;</span>, odd)</span><br><span class="line">	even := filter(slice, isEven)  <span class="comment">// 函数当做值来传递了</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Even elements of slice are: &quot;</span>, even)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数当做值和类型在我们写一些通用接口的时候非常有用，通过上面例子我们看到<code>testInt</code>这个类型是一个函数类型，然后两个<code>filter</code>函数的参数和返回值与<code>testInt</code>类型是一样的，但是我们可以实现很多种的逻辑，这样使得我们的程序变得非常的灵活。</p>
<h3 id="Panic和Recover"><a href="#Panic和Recover" class="headerlink" title="Panic和Recover"></a>Panic和Recover</h3><p>Go没有像Java那样的异常机制，它不能抛出异常，而是使用了<code>panic</code>和<code>recover</code>机制。一定要记住，你应当把它作为最后的手段来使用，也就是说，你的代码中应当没有，或者很少有<code>panic</code>的东西。这是个强大的工具，请明智地使用它。那么，我们应该如何使用它呢？</p>
<p>Panic</p>
<blockquote>
<p>是一个内建函数，可以中断原有的控制流程，进入一个<code>panic</code>状态中。当函数<code>F</code>调用<code>panic</code>，函数F的执行被中断，但是<code>F</code>中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，<code>F</code>的行为就像调用了<code>panic</code>。这一过程继续向上，直到发生<code>panic</code>的<code>goroutine</code>中所有调用的函数返回，此时程序退出。<code>panic</code>可以直接调用<code>panic</code>产生。也可以由运行时错误产生，例如访问越界的数组。</p>
</blockquote>
<p>Recover</p>
<blockquote>
<p>是一个内建的函数，可以让进入<code>panic</code>状态的<code>goroutine</code>恢复过来。<code>recover</code>仅在延迟函数中有效。在正常的执行过程中，调用<code>recover</code>会返回<code>nil</code>，并且没有其它任何效果。如果当前的<code>goroutine</code>陷入<code>panic</code>状态，调用<code>recover</code>可以捕获到<code>panic</code>的输入值，并且恢复正常的执行。</p>
</blockquote>
<p>下面这个函数演示了如何在过程中使用<code>panic</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = os.Getenv(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;no value for $USER&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个函数检查作为其参数的函数在执行时是否会产生<code>panic</code>：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">throwsPanic</span><span class="params">(f <span class="keyword">func</span>()</span>) <span class="params">(b <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> x := <span class="built_in">recover</span>(); x != <span class="literal">nil</span> &#123;</span><br><span class="line">			b = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	f() <span class="comment">//执行函数f，如果f中出现了panic，那么就可以恢复回来</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main函数和init函数"><a href="#main函数和init函数" class="headerlink" title="main函数和init函数"></a><code>main</code>函数和<code>init</code>函数</h3><p>Go里面有两个保留的函数：<code>init</code>函数（能够应用于所有的<code>package</code>）和<code>main</code>函数（只能应用于<code>package main</code>）。这两个函数在定义时不能有任何的参数和返回值。虽然一个<code>package</code>里面可以写任意多个<code>init</code>函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个<code>package</code>中每个文件只写一个<code>init</code>函数。</p>
<p>Go程序会自动调用<code>init()</code>和<code>main()</code>，所以你不需要在任何地方调用这两个函数。每个<code>package</code>中的<code>init</code>函数都是可选的，但<code>package main</code>就必须包含一个<code>main</code>函数。</p>
<p>程序的初始化和执行都起始于<code>main</code>包。如果<code>main</code>包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到<code>fmt</code>包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行<code>init</code>函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对<code>main</code>包中的包级常量和变量进行初始化，然后执行<code>main</code>包中的<code>init</code>函数（如果存在的话），最后执行<code>main</code>函数。下图详细地解释了整个执行过程：</p>
<p><img src="/images/golang/init.png?raw=true"></p>
<p>图2.6 main函数引入包初始化流程图</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>我们在写Go代码的时候经常用到import这个命令用来导入包文件，而我们经常看到的方式参考如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span>(</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后我们代码里面可以通过如下的方式调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p>
<ol>
<li><p>相对路径</p>
<p> import “./model” //当前文件同一目录的model目录，但是不建议这种方式来import</p>
</li>
<li><p>绝对路径</p>
<p> import “shorturl/model” //加载gopath/src/shorturl/model模块</p>
</li>
</ol>
<p>上面展示了一些import常用的几种方式，但是还有一些特殊的import，让很多新手很费解，下面我们来一一讲解一下到底是怎么一回事</p>
<ol>
<li><p>点操作</p>
<p> 我们有时候会看到如下的方式导入包</p>
<pre><code> import(
     . &quot;fmt&quot;
 )</code></pre>
<p> 这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的fmt.Println(“hello world”)可以省略的写成Println(“hello world”)</p>
</li>
<li><p>别名操作</p>
<p> 别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字</p>
<pre><code> import(
     f &quot;fmt&quot;
 )</code></pre>
<p> 别名操作的话调用包函数时前缀变成了我们的前缀，即f.Println(“hello world”)</p>
</li>
<li><p>_操作</p>
<p> 这个操作经常是让很多人费解的一个操作符，请看下面这个import</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	<span class="keyword">import</span> (</span><br><span class="line">	    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	    _ <span class="string">&quot;github.com/ziutek/mymysql/godrv&quot;</span></span><br><span class="line">	)</span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string">	_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># struct类型</span></span><br><span class="line"><span class="string">## struct</span></span><br><span class="line"><span class="string">Go语言中，也和C或者其他语言一样，我们可以声明新的类型，作为其它类型的属性或字段的容器。例如，我们可以创建一个自定义类型`</span>person<span class="string">`代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型我们称之`</span><span class="keyword">struct</span><span class="string">`。如下代码所示:</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>Go</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string">看到了吗？声明一个struct如此简单，上面的类型包含有两个字段</span></span><br><span class="line"><span class="string">- 一个string类型的字段name，用来保存用户名称这个属性</span></span><br><span class="line"><span class="string">- 一个int类型的字段age,用来保存用户年龄这个属性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如何使用struct呢？请看下面的代码</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>Go</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> P person  <span class="comment">// P现在就是person类型的变量了</span></span><br><span class="line"></span><br><span class="line">P.name = <span class="string">&quot;Astaxie&quot;</span>  <span class="comment">// 赋值&quot;Astaxie&quot;给P的name属性.</span></span><br><span class="line">P.age = <span class="number">25</span>  <span class="comment">// 赋值&quot;25&quot;给变量P的age属性</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;The person&#x27;s name is %s&quot;</span>, P.name)  <span class="comment">// 访问P的name属性.</span></span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string">除了上面这种P的声明使用之外，还有另外几种声明使用方式：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 1.按照顺序提供初始化值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	P := person&#123;&quot;Tom&quot;, 25&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 2.通过`</span>field:value<span class="string">`的方式初始化，这样可以任意顺序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	P := person&#123;age:24, name:&quot;Tom&quot;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 3.当然也可以通过`</span><span class="built_in">new</span><span class="string">`函数分配一个指针，此处P的类型为*person</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	P := new(person)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">下面我们看一个完整的使用struct的例子</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>Go</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个新的类型</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差</span></span><br><span class="line"><span class="comment">// struct也是传值的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Older</span><span class="params">(p1, p2 person)</span> <span class="params">(person, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p1.age&gt;p2.age &#123;  <span class="comment">// 比较p1和p2这两个人的年龄</span></span><br><span class="line">		<span class="keyword">return</span> p1, p1.age-p2.age</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p2, p2.age-p1.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> tom person</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 赋值初始化</span></span><br><span class="line">	tom.name, tom.age = <span class="string">&quot;Tom&quot;</span>, <span class="number">18</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两个字段都写清楚的初始化</span></span><br><span class="line">	bob := person&#123;age:<span class="number">25</span>, name:<span class="string">&quot;Bob&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照struct定义顺序初始化值</span></span><br><span class="line">	paul := person&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">43</span>&#125;</span><br><span class="line"></span><br><span class="line">	tb_Older, tb_diff := Older(tom, bob)</span><br><span class="line">	tp_Older, tp_diff := Older(tom, paul)</span><br><span class="line">	bp_Older, bp_diff := Older(bob, paul)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">		tom.name, bob.name, tb_Older.name, tb_diff)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">		tom.name, paul.name, tp_Older.name, tp_diff)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Of %s and %s, %s is older by %d years\n&quot;</span>,</span><br><span class="line">		bob.name, paul.name, bp_Older.name, bp_diff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="struct的匿名字段"><a href="#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a>struct的匿名字段</h3><p>我们上面介绍了如何定义一个struct，定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字段名的方式，也就是匿名字段，也称为嵌入字段。</p>
</li>
</ol>
<p>当匿名字段是一个struct的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个struct。</p>
<p>让我们来看一个例子，让上面说的这些更具体化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">	speciality <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 我们初始化一个学生</span></span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">&quot;Computer Science&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 我们访问相应的字段</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;His name is &quot;</span>, mark.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;His age is &quot;</span>, mark.age)</span><br><span class="line">	fmt.Println(<span class="string">&quot;His weight is &quot;</span>, mark.weight)</span><br><span class="line">	fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">	<span class="comment">// 修改对应的备注信息</span></span><br><span class="line">	mark.speciality = <span class="string">&quot;AI&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Mark changed his speciality&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;His speciality is &quot;</span>, mark.speciality)</span><br><span class="line">	<span class="comment">// 修改他的年龄信息</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Mark become old&quot;</span>)</span><br><span class="line">	mark.age = <span class="number">46</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;His age is&quot;</span>, mark.age)</span><br><span class="line">	<span class="comment">// 修改他的体重信息</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Mark is not an athlet anymore&quot;</span>)</span><br><span class="line">	mark.weight += <span class="number">60</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;His weight is&quot;</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图例如下:</p>
<p><img src="/images/golang/student_struct.png?raw=true"></p>
<p>图2.7 struct组合，Student组合了Human struct和string基本类型</p>
<p>我们看到Student访问属性age和name的时候，就像访问自己所有用的字段一样，对，匿名字段就是这样，能够实现字段的继承。是不是很酷啊？还有比这个更酷的呢，那就是student还能访问Human这个字段作为字段名。请看下面的代码，是不是更酷了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mark.Human = Human&#123;<span class="string">&quot;Marcus&quot;</span>, <span class="number">55</span>, <span class="number">220</span>&#125;</span><br><span class="line">mark.Human.age -= <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>通过匿名访问和修改字段相当的有用，但是不仅仅是struct字段哦，所有的内置类型和自定义类型都是可以作为匿名字段的。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Skills []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">// 匿名字段，struct</span></span><br><span class="line">	Skills <span class="comment">// 匿名字段，自定义的类型string slice</span></span><br><span class="line">	<span class="keyword">int</span>    <span class="comment">// 内置类型作为匿名字段</span></span><br><span class="line">	speciality <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化学生Jane</span></span><br><span class="line">	jane := Student&#123;Human:Human&#123;<span class="string">&quot;Jane&quot;</span>, <span class="number">35</span>, <span class="number">100</span>&#125;, speciality:<span class="string">&quot;Biology&quot;</span>&#125;</span><br><span class="line">	<span class="comment">// 现在我们来访问相应的字段</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Her name is &quot;</span>, jane.name)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Her age is &quot;</span>, jane.age)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Her weight is &quot;</span>, jane.weight)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Her speciality is &quot;</span>, jane.speciality)</span><br><span class="line">	<span class="comment">// 我们来修改他的skill技能字段</span></span><br><span class="line">	jane.Skills = []<span class="keyword">string</span>&#123;<span class="string">&quot;anatomy&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Her skills are &quot;</span>, jane.Skills)</span><br><span class="line">	fmt.Println(<span class="string">&quot;She acquired two new ones &quot;</span>)</span><br><span class="line">	jane.Skills = <span class="built_in">append</span>(jane.Skills, <span class="string">&quot;physics&quot;</span>, <span class="string">&quot;golang&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Her skills now are &quot;</span>, jane.Skills)</span><br><span class="line">	<span class="comment">// 修改匿名内置类型字段</span></span><br><span class="line">	jane.<span class="keyword">int</span> = <span class="number">3</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Her preferred number is&quot;</span>, jane.<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面例子我们看出来struct不仅仅能够将struct作为匿名字段，自定义类型、内置类型都可以作为匿名字段，而且可以在相应的字段上面进行函数操作（如例子中的append）。</p>
<p>这里有一个问题：如果human里面有一个字段叫做phone，而student也有一个字段叫做phone，那么该怎么办呢？</p>
<p>Go里面很简单的解决了这个问题，最外层的优先访问，也就是当你通过<code>student.phone</code>访问的时候，是访问student里面的字段，而不是human里面的字段。</p>
<p>这样就允许我们去重载通过匿名字段继承的一些字段，当然如果我们想访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span>  <span class="comment">// Human类型拥有的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human  <span class="comment">// 匿名字段Human</span></span><br><span class="line">	speciality <span class="keyword">string</span></span><br><span class="line">	phone <span class="keyword">string</span>  <span class="comment">// 雇员的phone字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Bob := Employee&#123;Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">34</span>, <span class="string">&quot;777-444-XXXX&quot;</span>&#125;, <span class="string">&quot;Designer&quot;</span>, <span class="string">&quot;333-222&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Bob&#x27;s work phone is:&quot;</span>, Bob.phone)</span><br><span class="line">	<span class="comment">// 如果我们要访问Human的phone字段</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Bob&#x27;s personal phone is:&quot;</span>, Bob.Human.phone)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>前面两章我们介绍了函数和struct，那你是否想过函数当作struct的字段一样来处理呢？今天我们就讲解一下函数的另一种形态，带有接收者的函数，我们称为<code>method</code></p>
<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>现在假设有这么一个场景，你定义了一个struct叫做长方形，你现在想要计算他的面积，那么按照我们一般的思路应该会用下面的方式来实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">area</span><span class="params">(r Rectangle)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">	r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, area(r1))</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, area(r2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码可以计算出来长方形的面积，但是area()不是作为Rectangle的方法实现的（类似面向对象里面的方法），而是将Rectangle的对象（如r1,r2）作为参数传入函数计算面积的。</p>
<p>这样实现当然没有问题咯，但是当需要增加圆形、正方形、五边形甚至其它多边形的时候，你想计算他们的面积的时候怎么办啊？那就只能增加新的函数咯，但是函数名你就必须要跟着换了，变成<code>area_rectangle, area_circle, area_triangle...</code></p>
<p>像下图所表示的那样， 椭圆代表函数, 而这些函数并不从属于struct(或者以面向对象的术语来说，并不属于class)，他们是单独存在于struct外围，而非在概念上属于某个struct的。</p>
<p><img src="/images/golang/rect_func_without_receiver.png?raw=true"></p>
<p>图2.8 方法和struct的关系图</p>
<p>很显然，这样的实现并不优雅，并且从概念上来说”面积”是”形状”的一个属性，它是属于这个特定的形状的，就像长方形的长和宽一样。</p>
<p>基于上面的原因所以就有了<code>method</code>的概念，<code>method</code>是附属在一个给定的类型上的，他的语法和函数的声明语法几乎一样，只是在<code>func</code>后面增加了一个receiver(也就是method所依从的主体)。</p>
<p>用上面提到的形状的例子来说，method <code>area()</code> 是依赖于某个形状(比如说Rectangle)来发生作用的。Rectangle.area()的发出者是Rectangle， area()是属于Rectangle的方法，而非一个外围函数。</p>
<p>更具体地说，Rectangle存在字段 height 和 width, 同时存在方法area(), 这些字段和方法都属于Rectangle。</p>
<p>用Rob Pike的话来说就是：</p>
<blockquote>
<p>“A method is a function with an implicit first argument, called a receiver.”</p>
</blockquote>
<p>method的语法如下：</p>
<pre><code>func (r ReceiverType) funcName(parameters) (results)</code></pre>
<p>下面我们用最开始的例子用method来实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">	r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">	c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">	c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of r1 is: &quot;</span>, r1.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of r2 is: &quot;</span>, r2.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of c1 is: &quot;</span>, c1.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;Area of c2 is: &quot;</span>, c2.area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在使用method的时候重要注意几点</p>
<ul>
<li>虽然method的名字一模一样，但是如果接收者不一样，那么method就不一样</li>
<li>method里面可以访问接收者的字段</li>
<li>调用method通过<code>.</code>访问，就像struct里面访问字段一样</li>
</ul>
<p>图示如下:</p>
<p><img src="/images/golang/shapes_func_with_receiver_cp.png?raw=true"></p>
<p>图2.9 不同struct的method不同</p>
<p>在上例，method area() 分别属于Rectangle和Circle， 于是他们的 Receiver 就变成了Rectangle 和 Circle, 或者说，这个area()方法 是由 Rectangle/Circle 发出的。</p>
<blockquote>
<p>值得说明的一点是，图示中method用虚线标出，意思是此处方法的Receiver是以值传递，而非引用传递，是的，Receiver还可以是指针, 两者的差别在于, 指针作为Receiver会对实例对象的内容发生操作,而普通类型作为Receiver仅仅是以副本作为操作对象,并不对原实例对象发生操作。后文对此会有详细论述。</p>
</blockquote>
<p>那是不是method只能作用在struct上面呢？当然不是咯，他可以定义在任何你自定义的类型、内置类型、struct等各种类型上面。这里你是不是有点迷糊了，什么叫自定义类型，自定义类型不就是struct嘛，不是这样的哦，struct只是自定义类型里面一种比较特殊的类型而已，还有其他自定义类型申明，可以通过如下这样的申明来实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> typeName typeLiteral</span><br></pre></td></tr></table></figure>

<p>请看下面这个申明自定义类型的代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> ages <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> money <span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> months <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">m := months &#123;</span><br><span class="line">	<span class="string">&quot;January&quot;</span>:<span class="number">31</span>,</span><br><span class="line">	<span class="string">&quot;February&quot;</span>:<span class="number">28</span>,</span><br><span class="line">	...</span><br><span class="line">	<span class="string">&quot;December&quot;</span>:<span class="number">31</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吗？简单的很吧，这样你就可以在自己的代码里面定义有意义的类型了，实际上只是一个定义了一个别名,有点类似于c中的typedef，例如上面ages替代了int</p>
<p>好了，让我们回到<code>method</code></p>
<p>你可以在任何的自定义类型中定义任意多的<code>method</code>，接下来让我们看一个复杂一点的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	WHITE = <span class="literal">iota</span></span><br><span class="line">	BLACK</span><br><span class="line">	BLUE</span><br><span class="line">	RED</span><br><span class="line">	YELLOW</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Box <span class="keyword">struct</span> &#123;</span><br><span class="line">	width, height, depth <span class="keyword">float64</span></span><br><span class="line">	color Color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BoxList []Box <span class="comment">//a slice of boxes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b Box)</span> <span class="title">Volume</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.width * b.height * b.depth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Box)</span> <span class="title">SetColor</span><span class="params">(c Color)</span></span> &#123;</span><br><span class="line">	b.color = c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span> <span class="title">BiggestColor</span><span class="params">()</span> <span class="title">Color</span></span> &#123;</span><br><span class="line">	v := <span class="number">0.00</span></span><br><span class="line">	k := Color(WHITE)</span><br><span class="line">	<span class="keyword">for</span> _, b := <span class="keyword">range</span> bl &#123;</span><br><span class="line">		<span class="keyword">if</span> bv := b.Volume(); bv &gt; v &#123;</span><br><span class="line">			v = bv</span><br><span class="line">			k = b.color</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bl BoxList)</span> <span class="title">PaintItBlack</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> bl &#123;</span><br><span class="line">		bl[i].SetColor(BLACK)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	strings := []<span class="keyword">string</span> &#123;<span class="string">&quot;WHITE&quot;</span>, <span class="string">&quot;BLACK&quot;</span>, <span class="string">&quot;BLUE&quot;</span>, <span class="string">&quot;RED&quot;</span>, <span class="string">&quot;YELLOW&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> strings[c]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	boxes := BoxList &#123;</span><br><span class="line">		Box&#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, RED&#125;,</span><br><span class="line">		Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, YELLOW&#125;,</span><br><span class="line">		Box&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>, BLACK&#125;,</span><br><span class="line">		Box&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>, BLUE&#125;,</span><br><span class="line">		Box&#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">1</span>, WHITE&#125;,</span><br><span class="line">		Box&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, YELLOW&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;We have %d boxes in our set\n&quot;</span>, <span class="built_in">len</span>(boxes))</span><br><span class="line">	fmt.Println(<span class="string">&quot;The volume of the first one is&quot;</span>, boxes[<span class="number">0</span>].Volume(), <span class="string">&quot;cm³&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;The color of the last one is&quot;</span>,boxes[<span class="built_in">len</span>(boxes)<span class="number">-1</span>].color.String())</span><br><span class="line">	fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Let&#x27;s paint them all black&quot;</span>)</span><br><span class="line">	boxes.PaintItBlack()</span><br><span class="line">	fmt.Println(<span class="string">&quot;The color of the second one is&quot;</span>, boxes[<span class="number">1</span>].color.String())</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;Obviously, now, the biggest one is&quot;</span>, boxes.BiggestColor().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码通过const定义了一些常量，然后定义了一些自定义类型</p>
<ul>
<li>Color作为byte的别名</li>
<li>定义了一个struct:Box，含有三个长宽高字段和一个颜色属性</li>
<li>定义了一个slice:BoxList，含有Box</li>
</ul>
<p>然后以上面的自定义类型为接收者定义了一些method</p>
<ul>
<li>Volume()定义了接收者为Box，返回Box的容量</li>
<li>SetColor(c Color)，把Box的颜色改为c</li>
<li>BiggestColor()定在在BoxList上面，返回list里面容量最大的颜色</li>
<li>PaintItBlack()把BoxList里面所有Box的颜色全部变成黑色</li>
<li>String()定义在Color上面，返回Color的具体颜色(字符串格式)</li>
</ul>
<p>上面的代码通过文字描述出来之后是不是很简单？我们一般解决问题都是通过问题的描述，去写相应的代码实现。</p>
<h3 id="指针作为receiver"><a href="#指针作为receiver" class="headerlink" title="指针作为receiver"></a>指针作为receiver</h3><p>现在让我们回过头来看看SetColor这个method，它的receiver是一个指向Box的指针，是的，你可以使用*Box。想想为啥要使用指针而不是Box本身呢？</p>
<p>我们定义SetColor的真正目的是想改变这个Box的颜色，如果不传Box的指针，那么SetColor接受的其实是Box的一个copy，也就是说method内对于颜色值的修改，其实只作用于Box的copy，而不是真正的Box。所以我们需要传入指针。</p>
<p>这里可以把receiver当作method的第一个参数来看，然后结合前面函数讲解的传值和传引用就不难理解</p>
<p>这里你也许会问了那SetColor函数里面应该这样定义 <code>\*b.Color=c</code>,而不是<code>b.Color=c</code>,因为我们需要读取到指针相应的值。</p>
<p>你是对的，其实Go里面这两种方式都是正确的，当你用指针去访问相应的字段时(虽然指针没有任何的字段)，Go知道你要通过指针去获取这个值，看到了吧，Go的设计是不是越来越吸引你了。</p>
<p>也许细心的读者会问这样的问题，PaintItBlack里面调用SetColor的时候是不是应该写成<code>(&amp;bl[i]).SetColor(BLACK)</code>，因为SetColor的receiver是*Box，而不是Box。</p>
<p>你又说对了，这两种方式都可以，因为Go知道receiver是指针，他自动帮你转了。</p>
<p>也就是说：</p>
<blockquote>
<p>如果一个method的receiver是 *T ,你可以在一个T类型的实例变量V上面调用这个method，而不需要&amp;V去调用这个method</p>
</blockquote>
<p>类似的</p>
<blockquote>
<p>如果一个method的receiver是T，你可以在一个*T类型的变量P上面调用这个method，而不需要 *P去调用这个method</p>
</blockquote>
<p>所以，你不用担心你是调用的指针的method还是不是指针的method，Go知道你要做的一切，这对于有多年C/C++编程经验的同学来说，真是解决了一个很大的痛苦。</p>
<h3 id="method继承"><a href="#method继承" class="headerlink" title="method继承"></a>method继承</h3><p>前面一章我们学习了字段的继承，那么你也会发现Go的一个神奇之处，method也是可以继承的。如果匿名字段实现了一个method，那么包含这个匿名字段的struct也能调用该method。让我们来看下面这个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在human上面定义了一个method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="method重写"><a href="#method重写" class="headerlink" title="method重写"></a>method重写</h3><p>上面的例子中，如果Employee想要实现自己的SayHi,怎么办？简单，和匿名字段冲突一样的道理，我们可以在Employee上面定义一个method，重写了匿名字段的方法。请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">		e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mark := Student&#123;Human&#123;<span class="string">&quot;Mark&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-YYYY&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">45</span>, <span class="string">&quot;111-888-XXXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	mark.SayHi()</span><br><span class="line">	sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码设计的是如此的美妙，让人不自觉的为Go的设计惊叹！</p>
<p>通过这些内容，我们可以设计出基本的面向对象的程序了，但是Go里面的面向对象是如此的简单，没有任何的私有、公有关键字，通过大小写来实现(大写开头的为公有，小写开头的为私有)，方法也同样适用这个原则。</p>
<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><h2 id="interface-1"><a href="#interface-1" class="headerlink" title="interface"></a>interface</h2><p>Go语言里面设计最精妙的应该算interface，它让面向对象，内容组织实现非常的方便，当你看完这一章，你就会被interface的巧妙设计所折服。</p>
<h3 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h3><p>简单的说，interface是一组method签名的组合，我们通过interface来定义对象的一组行为。</p>
<p>我们前面一章最后一个例子中Student和Employee都能SayHi，虽然他们的内部实现不一样，但是那不重要，重要的是他们都能<code>say hi</code></p>
<p>让我们来继续做更多的扩展，Student和Employee实现另一个方法<code>Sing</code>，然后Student实现方法BorrowMoney而Employee实现SpendSalary。</p>
<p>这样Student实现了三个方法：SayHi、Sing、BorrowMoney；而Employee实现了SayHi、Sing、SpendSalary。</p>
<p>上面这些方法的组合称为interface(被对象Student和Employee实现)。例如Student和Employee都实现了interface：SayHi和Sing，也就是这两个对象是该interface类型。而Employee没有实现这个interface：SayHi、Sing和BorrowMoney，因为Employee没有实现BorrowMoney这个方法。</p>
<h3 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h3><p>interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法参考下面这个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human <span class="comment">//匿名字段Human</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">	loan <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human <span class="comment">//匿名字段Human</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">	money <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;La la, la la la, la la la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Guzzle</span><span class="params">(beerStein <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Guzzle Guzzle Guzzle...&quot;</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">		e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">BorrowMoney</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">	s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SpendSalary</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">	e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">	Guzzle(beerStein <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(song <span class="keyword">string</span>)</span><br><span class="line">	BorrowMoney(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(song <span class="keyword">string</span>)</span><br><span class="line">	SpendSalary(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们可以知道，interface可以被任意的对象实现。我们看到上面的Men interface被Human、Student和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YoungChap两个interface。</p>
<p>最后，任意的类型都实现了空interface(我们这样定义：interface{})，也就是包含0个method的interface。</p>
<h3 id="interface值"><a href="#interface值" class="headerlink" title="interface值"></a>interface值</h3><p>那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存Human、Student或者Employee值。</p>
<p>因为m能够持有这三种类型的对象，所以我们可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了Men接口的任意结构的对象，这个和我们传统意义上面的slice有所不同。</p>
<p>让我们来看一下下面这个例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human <span class="comment">//匿名字段</span></span><br><span class="line">	school <span class="keyword">string</span></span><br><span class="line">	loan <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Human <span class="comment">//匿名字段</span></span><br><span class="line">	company <span class="keyword">string</span></span><br><span class="line">	money <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human实现SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s you can call me on %s\n&quot;</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;La la la la...&quot;</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee重载Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hi, I am %s, I work at %s. Call me on %s\n&quot;</span>, e.name,</span><br><span class="line">		e.company, e.phone)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">	SayHi()</span><br><span class="line">	Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mike := Student&#123;Human&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">25</span>, <span class="string">&quot;222-222-XXX&quot;</span>&#125;, <span class="string">&quot;MIT&quot;</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">	paul := Student&#123;Human&#123;<span class="string">&quot;Paul&quot;</span>, <span class="number">26</span>, <span class="string">&quot;111-222-XXX&quot;</span>&#125;, <span class="string">&quot;Harvard&quot;</span>, <span class="number">100</span>&#125;</span><br><span class="line">	sam := Employee&#123;Human&#123;<span class="string">&quot;Sam&quot;</span>, <span class="number">36</span>, <span class="string">&quot;444-222-XXX&quot;</span>&#125;, <span class="string">&quot;Golang Inc.&quot;</span>, <span class="number">1000</span>&#125;</span><br><span class="line">	tom := Employee&#123;Human&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">37</span>, <span class="string">&quot;222-444-XXX&quot;</span>&#125;, <span class="string">&quot;Things Ltd.&quot;</span>, <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义Men类型的变量i</span></span><br><span class="line">	<span class="keyword">var</span> i Men</span><br><span class="line"></span><br><span class="line">	<span class="comment">//i能存储Student</span></span><br><span class="line">	i = mike</span><br><span class="line">	fmt.Println(<span class="string">&quot;This is Mike, a Student:&quot;</span>)</span><br><span class="line">	i.SayHi()</span><br><span class="line">	i.Sing(<span class="string">&quot;November rain&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//i也能存储Employee</span></span><br><span class="line">	i = tom</span><br><span class="line">	fmt.Println(<span class="string">&quot;This is tom, an Employee:&quot;</span>)</span><br><span class="line">	i.SayHi()</span><br><span class="line">	i.Sing(<span class="string">&quot;Born to be wild&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义了slice Men</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Let&#x27;s use a slice of Men and see what happens&quot;</span>)</span><br><span class="line">	x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">//这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">	x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, value := <span class="keyword">range</span> x&#123;</span><br><span class="line">		value.SayHi()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，你会发现interface就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现， Go通过interface实现了duck-typing:即”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。</p>
<h3 id="空interface"><a href="#空interface" class="headerlink" title="空interface"></a>空interface</h3><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 定义a为空接口</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure>
<p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值。是不是很有用啊！</p>
<h3 id="interface函数参数"><a href="#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h3><p>interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数。</p>
<p>举个例子：fmt.Println是我们常用的一个函数，但是你是否注意到它可以接受任意类型的数据。打开fmt的源码文件，你会看到这样一个定义:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">	 String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string">也就是说，任何实现了String方法的类型都能作为参数被fmt.Println调用,让我们来试一试</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>Go</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过这个方法 Human 实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;❰&quot;</span>+h.name+<span class="string">&quot; - &quot;</span>+strconv.Itoa(h.age)+<span class="string">&quot; years -  ✆ &quot;</span> +h.phone+<span class="string">&quot;❱&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Bob := Human&#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">39</span>, <span class="string">&quot;000-7777-XXX&quot;</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;This Human is : &quot;</span>, Bob)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`	</span></span><br><span class="line"><span class="string">现在我们再回顾一下前面的Box示例，你会发现Color结构也定义了一个method：String。其实这也是实现了fmt.Stringer这个interface，即如果需要某个类型能被fmt包以特殊的格式输出，你就必须实现Stringer这个接口。如果没有实现这个接口，fmt将以默认的方式输出。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>Go</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现同样的功能</span></span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor().String())</span><br><span class="line">fmt.Println(<span class="string">&quot;The biggest one is&quot;</span>, boxes.BiggestsColor())</span><br></pre></td></tr></table></figure>
<p>注：实现了error接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必再定义String()方法了。</p>
<h3 id="interface变量存储的类型"><a href="#interface变量存储的类型" class="headerlink" title="interface变量存储的类型"></a>interface变量存储的类型</h3><p>我们知道interface的变量里面可以存储任意类型的数值(该类型实现了interface)。那么我们怎么反向知道这个变量里面实际保存了的是哪个类型的对象呢？目前常用的有两种方法：</p>
<ul>
<li><p>Comma-ok断言</p>
<p>  Go语言里面有一个语法，可以直接判断是否是该类型的变量： value, ok = element.(T)，这里value就是变量的值，ok是一个bool类型，element是interface变量，T是断言的类型。</p>
<p>  如果element里面确实存储了T类型的数值，那么ok返回true，否则返回false。</p>
<p>  让我们通过一个例子来更加深入的理解。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义了String方法，实现了fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">	list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// an int</span></span><br><span class="line">	list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">// a string</span></span><br><span class="line">	list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> index, element := <span class="keyword">range</span> list &#123;</span><br><span class="line">		<span class="keyword">if</span> value, ok := element.(<span class="keyword">int</span>); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value, ok := element.(Person); ok &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;list[%d] is of a different type\n&quot;</span>, index)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  是不是很简单啊，同时你是否注意到了多个if里面，还记得我前面介绍流程时讲过，if里面允许初始化变量。</p>
<p>  也许你注意到了，我们断言的类型越多，那么if else也就越多，所以才引出了下面要介绍的switch。</p>
</li>
<li><p>switch测试</p>
<p>  最好的讲解就是代码例子，现在让我们重写上面的这个实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> List [] Element</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;(name: &quot;</span> + p.name + <span class="string">&quot; - age: &quot;</span>+strconv.Itoa(p.age)+ <span class="string">&quot; years)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	list := <span class="built_in">make</span>(List, <span class="number">3</span>)</span><br><span class="line">	list[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">//an int</span></span><br><span class="line">	list[<span class="number">1</span>] = <span class="string">&quot;Hello&quot;</span> <span class="comment">//a string</span></span><br><span class="line">	list[<span class="number">2</span>] = Person&#123;<span class="string">&quot;Dennis&quot;</span>, <span class="number">70</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> index, element := <span class="keyword">range</span> list&#123;</span><br><span class="line">		<span class="keyword">switch</span> value := element.(<span class="keyword">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;list[%d] is an int and its value is %d\n&quot;</span>, index, value)</span><br><span class="line">			<span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;list[%d] is a string and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">			<span class="keyword">case</span> Person:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;list[%d] is a Person and its value is %s\n&quot;</span>, index, value)</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">&quot;list[%d] is of a different type&quot;</span>, index)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里有一点需要强调的是：<code>element.(type)</code>语法不能在switch外的任何逻辑里面使用，如果你要在switch外面判断一个类型就使用<code>comma-ok</code>。</p>
</li>
</ul>
<h3 id="嵌入interface"><a href="#嵌入interface" class="headerlink" title="嵌入interface"></a>嵌入interface</h3><p>Go里面真正吸引人的是它内置的逻辑语法，就像我们在学习Struct时学习的匿名字段，多么的优雅啊，那么相同的逻辑引入到interface里面，那不是更加完美了。如果一个interface1作为interface2的一个嵌入字段，那么interface2隐式的包含了interface1里面的method。</p>
<p>我们可以看到源码包container/heap里面有这样的一个定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	sort.Interface <span class="comment">//嵌入字段sort.Interface</span></span><br><span class="line">	Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//a Push method to push elements into the heap</span></span><br><span class="line">	Pop() <span class="keyword">interface</span>&#123;&#125; <span class="comment">//a Pop elements that pops elements from the heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到sort.Interface其实就是嵌入字段，把sort.Interface的所有method给隐式的包含进来了。也就是下面三个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// Less returns whether the element with index i should sort</span></span><br><span class="line">	<span class="comment">// before the element with index j.</span></span><br><span class="line">	Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">	Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个例子就是io包下面的 io.ReadWriter ，它包含了io包下面的Reader和Writer两个interface：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// io.ReadWriter</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>Go语言实现了反射，所谓反射就是能检查程序在运行时的状态。我们一般用到的包是reflect包。如何运用reflect包，官方的这篇文章详细的讲解了reflect包的实现原理，<a class="link"   href="http://golang.org/doc/articles/laws_of_reflection.html" >laws of reflection<i class="fas fa-external-link-alt"></i></a></p>
<p>使用reflect一般分成三步，下面简要的讲解一下：要去反射是一个类型的值(这些值都实现了空interface)，首先需要把它转化成reflect对象(reflect.Type或者reflect.Value，根据不同的情况调用不同的函数)。这两种获取方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">t := reflect.TypeOf(i)    <span class="comment">//得到类型的元数据,通过t我们能获取类型定义里面的所有元素</span></span><br><span class="line">v := reflect.ValueOf(i)   <span class="comment">//得到实际的值，通过v我们获取存储在里面的值，还可以去改变值</span></span><br></pre></td></tr></table></figure>
<p>转化为reflect对象之后我们就可以进行一些操作了，也就是将reflect对象转化成相应的值，例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">tag := t.Elem().Field(<span class="number">0</span>).Tag  <span class="comment">//获取定义在struct里面的标签</span></span><br><span class="line">name := v.Elem().Field(<span class="number">0</span>).String()  <span class="comment">//获取存储在第一个字段里面的值</span></span><br></pre></td></tr></table></figure>
<p>获取反射值能返回相应的类型和数值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">&quot;type:&quot;</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">&quot;kind is float64:&quot;</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">&quot;value:&quot;</span>, v.Float())</span><br></pre></td></tr></table></figure>
<p>最后，反射的话，那么反射的字段必须是可修改的，我们前面学习过传值和传引用，这个里面也是一样的道理。反射的字段必须是可读写的意思是，如果下面这样写，那么会发生错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>
<p>如果要修改相应的值，必须这样写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x)</span><br><span class="line">v := p.Elem()</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>
<p>上面只是对反射的简单介绍，更深入的理解还需要自己在编程中不断的实践。</p>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>有人把Go比作21世纪的C语言，第一是因为Go语言设计简单，第二，21世纪最重要的就是并行程序设计，而Go从语言层面就支持了并行。</p>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>goroutine是Go并行设计的核心。goroutine说到底其实就是协程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p>
<p>goroutine是通过Go的runtime管理的一个线程管理器。goroutine通过<code>go</code>关键字实现了，其实就是一个普通的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">go</span> hello(a, b, c)</span><br></pre></td></tr></table></figure>
<p>通过关键字go就启动了一个goroutine。我们来看一个例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		runtime.Gosched()</span><br><span class="line">		fmt.Println(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> say(<span class="string">&quot;world&quot;</span>) <span class="comment">//开一个新的Goroutines执行</span></span><br><span class="line">	say(<span class="string">&quot;hello&quot;</span>) <span class="comment">//当前Goroutines执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上程序执行后将输出：</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到go关键字很方便的就实现了并发编程。<br>上面的多个goroutine运行在同一个进程里面，共享内存数据，不过设计上我们要遵循：不要通过共享来通信，而要通过通信来共享。</p>
<blockquote>
<p>runtime.Gosched()表示让CPU把时间片让给别人,下次某个时候继续恢复执行该goroutine。</p>
</blockquote>
<blockquote>
<p>默认情况下，在Go 1.5将标识并发系统线程个数的runtime.GOMAXPROCS的初始值由1改为了运行环境的CPU核数。</p>
</blockquote>
<p>但在Go 1.5以前调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要在我们的程序中显式调用 runtime.GOMAXPROCS(n) 告诉调度器同时使用多个线程。GOMAXPROCS 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果n &lt; 1，不会改变当前设置。</p>
<h2 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h2><p>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。那么goroutine之间如何进行数据的通信呢，Go提供了一个很好的通信机制channel。channel可以与Unix shell 中的双向管道做类比：可以通过它发送或者接收值。这些值只能是特定的类型：channel类型。定义一个channel时，也需要定义发送到channel的值的类型。注意，必须使用make 创建channel：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ci := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">cf := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>channel通过操作符<code>&lt;-</code>来接收和发送数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ch &lt;- v    <span class="comment">// 发送v到channel ch.</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从ch中接收数据，并赋值给v</span></span><br></pre></td></tr></table></figure>
<p>我们把这些应用到我们的例子中来：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	total := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">		total += v</span><br><span class="line">	&#125;</span><br><span class="line">	c &lt;- total  <span class="comment">// send total to c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sum(a[:<span class="built_in">len</span>(a)/<span class="number">2</span>], c)</span><br><span class="line">	<span class="keyword">go</span> sum(a[<span class="built_in">len</span>(a)/<span class="number">2</span>:], c)</span><br><span class="line">	x, y := &lt;-c, &lt;-c  <span class="comment">// receive from c</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(x, y, x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得Goroutines同步变的更加的简单，而不需要显式的lock。所谓阻塞，也就是如果读取（value := &lt;-ch）它将会被阻塞，直到有数据接收。其次，任何发送（ch&lt;-5）将会被阻塞，直到数据被读出。无缓冲channel是在多个goroutine之间同步很棒的工具。</p>
<h2 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h2><p>上面我们介绍了默认的非缓存类型的channel，不过Go也允许指定channel的缓冲大小，很简单，就是channel可以存储多少元素。ch:= make(chan bool, 4)，创建了可以存储4个元素的bool 型channel。在这个channel 中，前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, value)</span><br></pre></td></tr></table></figure>
<p>当 value = 0 时，channel 是无缓冲阻塞读写的，当value &gt; 0 时，channel 有缓冲、是非阻塞的，直到写满 value 个元素才阻塞写入。</p>
<p>我们看一下下面这个例子，你可以在自己本机测试一下，修改相应的value值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)<span class="comment">//修改2为1就报错，修改2为3可以正常运行</span></span><br><span class="line">	c &lt;- <span class="number">1</span></span><br><span class="line">	c &lt;- <span class="number">2</span></span><br><span class="line">	fmt.Println(&lt;-c)</span><br><span class="line">	fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//修改为1报如下的错误:</span></span><br><span class="line">        <span class="comment">//fatal error: all goroutines are asleep - deadlock!</span></span><br></pre></td></tr></table></figure>
<h2 id="Range和Close"><a href="#Range和Close" class="headerlink" title="Range和Close"></a>Range和Close</h2><p>上面这个例子中，我们需要读取两次c，这样不是很方便，Go考虑到了这一点，所以也可以通过range，像操作slice或者map一样操作缓存类型的channel，请看下面的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		c &lt;- x</span><br><span class="line">		x, y = y, x + y</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for i := range c</code>能够不断的读取channel里面的数据，直到该channel被显式的关闭。上面代码我们看到可以显式的关闭channel，生产者通过内置函数<code>close</code>关闭channel。关闭channel之后就无法再发送任何数据了，在消费方可以通过语法<code>v, ok := &lt;-ch</code>测试channel是否被关闭。如果ok返回false，那么说明channel已经没有任何数据并且已经被关闭。</p>
<blockquote>
<p>记住应该在生产者的地方关闭channel，而不是消费的地方去关闭它，这样容易引起panic</p>
</blockquote>
<blockquote>
<p>另外记住一点的就是channel不像文件之类的，不需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的</p>
</blockquote>
<h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>我们上面介绍的都是只有一个channel的情况，那么如果存在多个channel的时候，我们该如何操作呢，Go里面提供了一个关键字<code>select</code>，通过<code>select</code>可以监听channel上的数据流动。</p>
<p><code>select</code>默认是阻塞的，只有当监听的channel中有发送或接收可以进行时才会运行，当多个channel都准备好的时候，select是随机的选择一个执行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x:</span><br><span class="line">			x, y = y, x + y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>select</code>里面还有default语法，<code>select</code>其实就是类似switch的功能，default就是当监听的channel都没有准备好的时候，默认执行的（select不再阻塞等待channel）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">	<span class="comment">// use i</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">// 当c阻塞的时候执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>有时候会出现goroutine阻塞的情况，那么我们如何避免整个程序进入阻塞的情况呢？我们可以利用select来设置超时，通过如下的方式实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">					<span class="built_in">println</span>(v)</span><br><span class="line">				<span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">					<span class="built_in">println</span>(<span class="string">&quot;timeout&quot;</span>)</span><br><span class="line">					o &lt;- <span class="literal">true</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="runtime-goroutine"><a href="#runtime-goroutine" class="headerlink" title="runtime goroutine"></a>runtime goroutine</h2><p>runtime包中有几个处理goroutine的函数：</p>
<ul>
<li><p>Goexit</p>
<p>  退出当前执行的goroutine，但是defer函数还会继续调用</p>
</li>
<li><p>Gosched</p>
<p>  让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
</li>
<li><p>NumCPU</p>
<p>  返回 CPU 核数量</p>
</li>
<li><p>NumGoroutine</p>
<p>  返回正在执行和排队的任务总数</p>
</li>
<li><p>GOMAXPROCS</p>
<p>  用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这一章我们主要介绍了Go语言的一些语法，通过语法我们可以发现Go是多么的简单，只有二十五个关键字。让我们再来回顾一下这些关键字都是用来干什么的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">break</span>    <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>    <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>     <span class="keyword">defer</span>        <span class="keyword">go</span>      <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>     <span class="keyword">else</span>         <span class="keyword">goto</span>    <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>    <span class="keyword">fallthrough</span>  <span class="keyword">if</span>      <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span> <span class="keyword">for</span>          <span class="keyword">import</span>  <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure>

<ul>
<li>var和const参考2.2Go语言基础里面的变量和常量申明</li>
<li>package和import已经有过短暂的接触</li>
<li>func 用于定义函数和方法</li>
<li>return 用于从函数返回</li>
<li>defer 用于类似析构函数</li>
<li>go 用于并发</li>
<li>select 用于选择不同类型的通讯</li>
<li>interface 用于定义接口，参考2.6小节</li>
<li>struct 用于定义抽象数据类型，参考2.5小节</li>
<li>break、case、continue、for、fallthrough、else、if、switch、goto、default这些参考2.3流程介绍里面</li>
<li>chan用于channel通讯</li>
<li>type用于声明自定义类型</li>
<li>map用于声明map类型数据</li>
<li>range用于读取slice、map、channel数据</li>
</ul>
<p>上面这二十五个关键字记住了，那么Go你也已经差不多学会了。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>top命令分析</title>
    <url>/2019/07/08/linux/top/</url>
    <content><![CDATA[<p>top作为Linux最常用的命令，其中的各项参数也是很直接的展示了系统的概况。</p>
<a id="more"></a>

<p>VIRT 意味着进程虚拟空间的大小, 是真实使用的内存,加上映射进程自己使用的内存(如, X server使用显卡内存), 加上映射磁盘文件使用的内存(主要是加载共享程序库文件), 加上与其他进程共享的内存. VIRT代表进程当前时刻有多少内存可以访问.</p>
<p>RES 意味驻留内存大小, 是当前进程真正占用物理内存的精确反映. (直接与%MEM列相对应.) RES始终要比VIRT小, 因为多数程序依赖C库文件.</p>
<p>SHR 表示VIRT里有多少其实是共享部分(库文件使用的内存). 关系到库文件里, 并不是整个的库文件会驻留. 如, 如果程序仅用到了库文件里的少数函数, 整个库文件会映射并被计算到VIRT和SHR里, 但只有库文件包含用到的函数那部分真正加载到内存并被计算到RES里.</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell技巧</title>
    <url>/2019/07/07/linux/shell/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="入参和默认变量"><a href="#入参和默认变量" class="headerlink" title="入参和默认变量"></a>入参和默认变量</h1><p>对于shell脚本而言，有些内容是专门用于处理参数的，他们都有特定的含义 ，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;root&#x2F;test.sh arg1 arg2</span><br><span class="line">$0  # 脚本名</span><br><span class="line">$1  # 第一个参数</span><br><span class="line">$2  # 第二个参数</span><br><span class="line">$#  # 脚本后面跟的参数个数</span><br><span class="line">$@  # 所有参数，并且可以被遍历</span><br><span class="line">$*  # 所有参数，且作为整体，和$*很像，但是有区别</span><br><span class="line">$$  # 当前脚本的进程ID</span><br><span class="line">$?  # 上一条命令的退出状态</span><br></pre></td></tr></table></figure>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>给变量赋值，使用等号即可，但是<em>等号两边千万不要有空格</em>，等号右边有空格的字符串也必须用引号引起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arg1&#x3D;&quot;hello world&quot;  # 直接赋值</span><br><span class="line">unset arg1   # 取消赋值</span><br><span class="line">echo &quot;para1 is $arg1&quot;  # 调用变量</span><br><span class="line">echo &quot;para1 is $&#123;arg1&#125;&quot;  #调用变量</span><br></pre></td></tr></table></figure>

<h1 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;&#96;ls&#96;  # 直接执行</span><br><span class="line"># 或</span><br><span class="line">a&#x3D;$(a)</span><br><span class="line"></span><br><span class="line"># 计算</span><br><span class="line">echo &quot;1+1&#x3D;$((1+1))&quot;</span><br><span class="line"></span><br><span class="line"># 引用单条执行结果</span><br><span class="line">a&#x3D;&quot;ls&quot;</span><br><span class="line">echo &quot;$($a)&quot;</span><br><span class="line"></span><br><span class="line"># 引用多个执行结果</span><br><span class="line">a&#x3D;&quot;ls;pwd&quot;</span><br><span class="line">echo &quot;$(eval $a)&quot;  # 使用了eval，将a的内容都作为命令来执行。</span><br></pre></td></tr></table></figure>

<h1 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ $? -eq 0 ];</span><br><span class="line">then</span><br><span class="line">    eho &quot;success&quot;</span><br><span class="line">elif [ $? -eq 1 ];</span><br><span class="line">then</span><br><span class="line">    echo &quot;failed,code is 1&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;other code&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name&#x3D;&quot;aa&quot;</span><br><span class="line">case $name in</span><br><span class="line">    &quot;aa&quot;)</span><br><span class="line">    echo &quot;name is aa&quot;</span><br><span class="line">    ;;</span><br><span class="line">    &quot;&quot;)</span><br><span class="line">    echo &quot;name is null&quot;</span><br><span class="line">    ;;</span><br><span class="line">    &quot;bb&quot;)</span><br><span class="line">    echo &quot;name is bb&quot;</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">    echo &quot;name is other&quot;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># 多条件</span><br><span class="line"># -o或者||表示或。这里也有一些常见的条件判定。</span><br><span class="line">if [ 10 -gt 5 -o 10 -gt 4 ];then</span><br><span class="line">    echo &quot;10&gt;5 or 10&gt;4&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ 10 -gt 5 ] || [ 10 -gt 4 ];then</span><br><span class="line">    echo &quot;10&gt;5 or 10&gt;4&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><blockquote>
<p>-o or 或者，同||<br>-a and 与，同&amp;&amp;<br>! 非</p>
</blockquote>
<h3 id="整数判断"><a href="#整数判断" class="headerlink" title="整数判断"></a>整数判断</h3><blockquote>
<p>-eq 两数是否相等<br>-ne 两数是否不等<br>-gt 前者是否大于后者（greater then）<br>-lt 前面是否小于后者（less than）<br>-ge 前者是否大于等于后者（greater then or equal）<br>-le 前者是否小于等于后者（less than or equal）</p>
</blockquote>
<h3 id="字符串判断str1-exp-str2"><a href="#字符串判断str1-exp-str2" class="headerlink" title="字符串判断str1 exp str2"></a>字符串判断str1 exp str2</h3><blockquote>
<p>-z “$str1” str1是否为空字符串<br>-n “$str1” str1是否不是空字符串<br>“$str1” == “$str2” str1是否与str2相等<br>“$str1” != “$str2” str1是否与str2不等<br>“$str1” =~ “str2” str1是否包含str2</p>
</blockquote>
<h3 id="文件目录判断：filename"><a href="#文件目录判断：filename" class="headerlink" title="文件目录判断：filename"></a>文件目录判断：filename</h3><blockquote>
<p>-f $filename 是否为文件<br>-e $filename 是否存在<br>-d $filename 是否为目录<br>-s $filename 文件存在且不为空<br>! -s $filename 文件是否为空</p>
</blockquote>
<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#遍历输出脚本的参数</span><br><span class="line">for i in $@;do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for ((i &#x3D; 0 ; i &lt; 10 ; i++ ));do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in &#123;1..5&#125;;do</span><br><span class="line">    echo &quot;Welcome $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while[&quot;$ans&quot;!&#x3D;&quot;yes&quot;]</span><br><span class="line">do</span><br><span class="line">    read -p &quot;please input yes to exit loop:&quot; ans</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ans&#x3D;yes</span><br><span class="line">until[ $ans !&#x3D;&quot;yes&quot;]</span><br><span class="line">do</span><br><span class="line">    read -p &quot;please input yes to exit loop:&quot; ans</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in&#123;5..15..3&#125;;do</span><br><span class="line">    echo &quot;number is $i&quot;</span><br><span class="line">done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myfunc()&#123;</span><br><span class="line">    echo &quot;hello world $1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function myfunc()&#123;</span><br><span class="line">    echo &quot;hello world $1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>通常函数的return返回值只支持0-255</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myfunc()&#123;</span><br><span class="line">    local myresult&#x3D;&#39;some value&#39;</span><br><span class="line">    echo $myresult</span><br><span class="line">&#125;</span><br><span class="line">val&#x3D;$(myfunc) #val的值为some value</span><br></pre></td></tr></table></figure>

<p>通过return的方式适用于判断函数的执行是否成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myfunc()&#123;</span><br><span class="line">    #do something</span><br><span class="line">    return0</span><br><span class="line">&#125;</span><br><span class="line">if myfunc;then</span><br><span class="line">    echo &quot;success&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;failed&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 这是一行注释</span><br><span class="line">:&#39;</span><br><span class="line">这是</span><br><span class="line">多行</span><br><span class="line">注释</span><br><span class="line">&#39;</span><br><span class="line">ls</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">这也可以</span><br><span class="line">达到</span><br><span class="line">多行注释</span><br><span class="line">的目的</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h1 id="日志保存"><a href="#日志保存" class="headerlink" title="日志保存"></a>日志保存</h1><h3 id="方式一，将标准输出保存到文件中，打印标准错误："><a href="#方式一，将标准输出保存到文件中，打印标准错误：" class="headerlink" title="方式一，将标准输出保存到文件中，打印标准错误："></a>方式一，将标准输出保存到文件中，打印标准错误：</h3><blockquote>
<p><code>./test.sh &gt; log.dat</code><br>这种情况下，如果命令执行出错，错误将会打印到控制台。所以如果你在程序中调用，这样将不会讲错误信息保存在日志中。</p>
</blockquote>
<h3 id="方式二，标准输出和标准错误都保存到日志文件中："><a href="#方式二，标准输出和标准错误都保存到日志文件中：" class="headerlink" title="方式二，标准输出和标准错误都保存到日志文件中："></a>方式二，标准输出和标准错误都保存到日志文件中：</h3><blockquote>
<p><code>./test.sh &gt; log.dat 2&gt;&amp;1</code></p>
</blockquote>
<h3 id="方式三，保存日志文件的同时，也输出到控制台："><a href="#方式三，保存日志文件的同时，也输出到控制台：" class="headerlink" title="方式三，保存日志文件的同时，也输出到控制台："></a>方式三，保存日志文件的同时，也输出到控制台：</h3><blockquote>
<p><code>./test.sh |tee log.dat</code></p>
</blockquote>
<h1 id="脚本执行"><a href="#脚本执行" class="headerlink" title="脚本执行"></a>脚本执行</h1><blockquote>
<p><code>./test.sh</code> 直接执行<br><code>sh test.sh</code>  在子进程中执行<br><code>sh -x test.sh</code>  debug模式，会在终端打印执行到命令，适合调试<br><code>source test.sh</code> test.sh在父进程中执行<br><code>. test.sh</code> 不需要赋予执行权限，临时执行</p>
</blockquote>
<h1 id="脚本退出码"><a href="#脚本退出码" class="headerlink" title="脚本退出码"></a>脚本退出码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">function myfun()&#123;</span><br><span class="line">if[ $# -lt 2 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;para num error&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">echo &quot;ok&quot;</span><br><span class="line">exit 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if[ $# -lt 1 ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;para num error&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">returnVal&#x3D;&#96;myfun aa&#96;</span><br><span class="line">echo &quot;end shell&quot;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<p>这里需要特别注意的一点是，使用 returnVal=`myfun aa`</p>
<p>这样的句子执行函数，即便函数里面有exit，它也不会退出脚本执行，而只是会退出该函数，这是因为exit是退出当前进程，而这种方式执行函数，相当于fork了一个子进程，因此不会退出当前脚本。最终结果就会看到，无论你的函数参数是什么最后end shell都会打印。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python实现排序算法</title>
    <url>/2019/07/04/python/python_sort/</url>
    <content><![CDATA[<p>常见的八大排序算法，他们之间关系如下：</p>
<a id="more"></a>

<p><img src="/images/python/sort_1.jpg" alt="sort_1"></p>
<p>性能比较</p>
<p><img src="/images/python/sort_2.jpg" alt="sort_2"></p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p><img src="/images/python/sort_3.gif" alt="sort_3"></p>
<p>直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。</p>
<p>因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成：</p>
<ol>
<li><p>第一层循环：遍历待比较的所有数组元素</p>
</li>
<li><p>第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。如果：selected &gt; ordered，那么将二者交换</p>
</li>
</ol>
<blockquote>
<p>代码实现：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span>(<span class="params">L</span>):</span></span><br><span class="line">    <span class="comment"># 遍历数组中的所有元素，其中0号索引元素默认已排序，因此用1开始</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,len(L)):</span><br><span class="line">    <span class="comment"># 将该元素与已排序好的前序数组依次比较，如果该元素小，则交换</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> L[i]&gt;L[i+<span class="number">1</span>]:</span><br><span class="line">                temp=L[i+<span class="number">1</span>]</span><br><span class="line">                L[i+<span class="number">1</span>]=L[i]</span><br><span class="line">                L[i]=temp</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="/images/python/sort_4.png" alt="sort_4"></p>
<p>希尔排序的算法思想：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p>
<p>同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成：</p>
<ol>
<li>第一层循环：将gap依次折半，对序列进行分组，直到gap=1</li>
<li>第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。</li>
</ol>
<blockquote>
<p>代码实现：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_shell</span>(<span class="params">L</span>):</span></span><br><span class="line">    gap=(int)(len(L)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> gap&gt;=<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(gap,len(L)):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(x-gap,<span class="number">-1</span>,-gap):</span><br><span class="line">                <span class="keyword">if</span> L[i]&gt;L[i+gap]:</span><br><span class="line">                    temp=L[i+gap]</span><br><span class="line">                    L[i+gap]=L[i]</span><br><span class="line">                    L[i]=temp</span><br><span class="line">        gap=(int)(gap/<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p><img src="/images/python/sort_5.gif" alt="sort_5"></p>
<p>简单选择排序的基本思想：比较+交换。</p>
<ol>
<li>从待排序序列中，找到关键字最小的元素；</li>
<li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li>
<li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。</li>
</ol>
<p>因此我们可以发现，简单选择排序也是通过两层循环实现。</p>
<p>第一层循环：依次遍历序列当中的每一个元素</p>
<p>第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。</p>
<blockquote>
<p>代码实现：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span>(<span class="params">L</span>):</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>,len(L)):</span><br><span class="line">        mininum = L[x]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(x+<span class="number">1</span>,len(L)):</span><br><span class="line">            <span class="keyword">if</span> L[i]&lt;mininum:</span><br><span class="line">                temp=L[i]</span><br><span class="line">                L[i]=mininum</span><br><span class="line">                mininum=temp</span><br><span class="line">        L[x]=mininum</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ul>
<li>堆的概念：</li>
</ul>
<p>堆：本质是一种数组对象。特别重要的一点性质：任意的叶子节点小于（或大于）它所有的父节点。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。</p>
<p>利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法。下面，我们通过大顶堆来实现。</p>
<ul>
<li>基本思想：</li>
</ul>
<p>堆排序可以按照以下步骤来完成：</p>
<ol>
<li>首先将序列构建称为大顶堆（这样满足了大顶堆那条性质：位于根节点的元素一定是当前序列的最大值）；<br><img src="/images/python/sort_6.png" alt="sort_6"></li>
<li>取出当前大顶堆的根节点，将其与序列末尾元素进行交换（此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质）；</li>
<li>对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质；<br><img src="/images/python/sort_7.png" alt="sort_7"></li>
<li>重复2.3步骤，直至堆中只有1个元素为止。</li>
</ol>
<blockquote>
<p>代码实现：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取左叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LEFT</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line"><span class="comment"># 获取右叶子节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RIGHT</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line"><span class="comment"># 调整大顶堆</span></span><br><span class="line"><span class="comment"># L待调整序列， length 序列长度 i需要调整的节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adjust_max_heap</span>(<span class="params">L,length,i</span>):</span></span><br><span class="line">    <span class="comment"># 定义一个int值保存当前序列最大值的下标</span></span><br><span class="line">    largest=i</span><br><span class="line">    <span class="comment"># 执行循环：</span></span><br><span class="line">    <span class="comment"># 1.寻找最大值的下标</span></span><br><span class="line">    <span class="comment"># 2.最大值与父节点交换</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 获取序列左右叶子节点的下标</span></span><br><span class="line">        left=LEFT(i)</span><br><span class="line">        right=RIGHT(i)</span><br><span class="line">        <span class="comment"># 当左叶子节点的下标小于序列长度并且右叶子节点的值大于父节点时，将左叶子节点的下标值赋值给largest</span></span><br><span class="line">        <span class="keyword">if</span> (left&lt;length) <span class="keyword">and</span> (L[left]&gt;L[i]):</span><br><span class="line">            largest=left</span><br><span class="line">            print(<span class="string">&#x27;左叶子节点&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            largest=i</span><br><span class="line">        <span class="comment"># 当右叶子节点的下标小于序列长度并且右叶子节点的值大于父节点时，将右叶子节点的下标值赋值给largest</span></span><br><span class="line">        <span class="keyword">if</span> (right&lt;length) abd (L[right]&gt;L[largest]):</span><br><span class="line">            largest=right</span><br><span class="line">            print(<span class="string">&#x27;右叶子节点&#x27;</span>)</span><br><span class="line">        <span class="comment"># 如果largest不等于i，说明当前的父节点不是最大值，需要交换值</span></span><br><span class="line">        <span class="keyword">if</span> largest!= i:</span><br><span class="line">            temp=L[i]:</span><br><span class="line">            L[i]=L[largest]</span><br><span class="line">            L[largest]=temp</span><br><span class="line">            i=largest</span><br><span class="line">            print(largest)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 建立大顶堆</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_max_heap</span>(<span class="params">L</span>):</span></span><br><span class="line">    length=len(L)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((length<span class="number">-1</span>)/<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        adjust_max_heap(L,length,x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span>(<span class="params">L</span>):</span></span><br><span class="line">    <span class="comment"># 先建立大顶堆，保证最大值位于根节点，并且父节点的值大于叶子节点</span></span><br><span class="line">    build_max_heap(L)</span><br><span class="line">    <span class="comment"># 当前堆中序列的长度，初始化为序列的长度</span></span><br><span class="line">    i=len(L)</span><br><span class="line">    <span class="comment"># 执行循环：</span></span><br><span class="line">    <span class="comment"># 1.每次取出堆顶元素置于序列的最后(len-1,len-2,len-3...)</span></span><br><span class="line">    <span class="comment"># 2.调整堆，使其继续满足大顶堆的性质，注意实时修改堆中序列的长度</span></span><br><span class="line">    <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">        temp=L[i<span class="number">-1</span>]</span><br><span class="line">        L[i<span class="number">-1</span>]=L[<span class="number">0</span>]</span><br><span class="line">        L[<span class="number">0</span>]=temp</span><br><span class="line">        <span class="comment"># 堆中序列长度减1</span></span><br><span class="line">        i=i<span class="number">-1</span></span><br><span class="line">        <span class="comment"># 调整大顶堆</span></span><br><span class="line">        adjust_max_heap(L,i,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="/images/python/sort_8.gif" alt="sort_8"></p>
<ol>
<li>将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素（ 第一轮结束后，序列最后一个元素一定是当前序列的最大值）；</li>
<li>对序列当中剩下的n-1个元素再次执行步骤1。</li>
<li>对于长度为n的序列，一共需要执行n-1轮比较（利用while循环可以减少执行次数）。</li>
</ol>
<blockquote>
<p>代码实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">L</span>):</span></span><br><span class="line">    length=len(L)</span><br><span class="line">    <span class="comment"># 序列长度为length，需要执行length-1轮交换</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,length):</span><br><span class="line">    <span class="comment"># 每一轮交换，都将序列当中的左右元素进行比较</span></span><br><span class="line">    <span class="comment"># 每轮交换中，由于序列最后的元素一定是最大的，因此每轮循环到序列未排序的位置即可</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,length-x):</span><br><span class="line">            <span class="keyword">if</span> L[i]&gt;L[i+<span class="number">1</span>]:</span><br><span class="line">                temp=L[i]</span><br><span class="line">                L[i]=L[i+<span class="number">1</span>]</span><br><span class="line">                L[i+<span class="number">1</span>]=temp</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/images/python/sort_9.gif" alt="sort_9"></p>
<p>快速排序的基本思想：挖坑填数+分治法</p>
<ol>
<li>从序列当中选择一个基准数(pivot)，在这里我们选择序列当中第一个数最为基准数；</li>
<li>将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧；</li>
<li>重复步骤1.2，直到所有子集当中只有一个元素为止。用伪代码描述如下：<ol>
<li>i =L; j = R; 将基准数挖出形成第一个坑a[i]。</li>
<li>j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</li>
<li>i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</li>
<li>再重复执行2，3二步，直到i==j，将基准数填入a[i]中</li>
</ol>
</li>
</ol>
<blockquote>
<p>代码实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">L,start,end</span>):</span></span><br><span class="line">    <span class="keyword">if</span> start&lt;end:</span><br><span class="line">        i,j,pivot=start,end,L[start]</span><br><span class="line">        <span class="keyword">while</span> i&lt;j:</span><br><span class="line">            <span class="comment"># 从右开始向左寻找第一个小于pivot的值</span></span><br><span class="line">            <span class="keyword">while</span> (i&lt;j) <span class="keyword">and</span> (L[j]&gt;=pivot):</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 将小于pivot的值移到左边</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;j:</span><br><span class="line">                L[i]=L[j]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 从左向右寻找第一个大于pivot的值</span></span><br><span class="line">            <span class="keyword">while</span> i&lt;j <span class="keyword">and</span> L[i]&lt;pivot:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 将大于pivot的值移到右边</span></span><br><span class="line">            <span class="keyword">if</span> i&lt;j:</span><br><span class="line">                L[i]=L[j]</span><br><span class="line">                j-=<span class="number">1</span></span><br><span class="line">            <span class="comment"># 循环结束后，说明i=j，此时左边值全部小于pivot，右边的值全部大于pivot</span></span><br><span class="line">            <span class="comment"># pivot的位置移动正确，那么此时只需要对左右两侧的序列调用此函数进一步排序即可</span></span><br><span class="line">            <span class="comment"># 递归调用函数 依次对左侧序列 从0到i-1 右侧序列 从i-1到结束</span></span><br><span class="line">        L[i]=pivot</span><br><span class="line">        <span class="comment"># 左侧序列继续排序</span></span><br><span class="line">        quick_sort(L,start,i<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 右侧序列继续排序</span></span><br><span class="line">        quick_sort(L,i+<span class="number">1</span>,end)</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="/images/python/sort_10.gif" alt="sort_10"></p>
<p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个典型的应用。它的基本操作是：将已有的子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p>
<p>归并排序其实要做两件事：</p>
<ol>
<li>分解：将序列每次折半拆分</li>
<li>合并：将划分后的序列段两两排序合并</li>
</ol>
<p>因此，归并排序实际上就是两个操作，拆分+合并</p>
<p>如何合并？</p>
<p>L[first…mid]为第一段，L[mid+1…last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first…last]并且也有序。</p>
<ol>
<li>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]</li>
<li>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]</li>
<li>此时将temp[]中的元素复制给L[]，则得到的L[first…last]有序</li>
</ol>
<p>如何分解？</p>
<p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p><img src="/images/python/sort_11.gif" alt="sort_11"></p>
<p>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</p>
<ol>
<li>分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</li>
<li>收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]</li>
</ol>
<p>对新形成的序列L[]重复执行分配和收集元素中的十位、百位…直到分配完该序列中的最高位，则排序结束。<br>根据上述“基数排序”的展示，我们可以清楚的看到整个实现的过程。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 魔法方法</title>
    <url>/2019/07/04/python/python_magic_func/</url>
    <content><![CDATA[<h1 id="python-魔法方法"><a href="#python-魔法方法" class="headerlink" title="python 魔法方法"></a>python 魔法方法</h1><a id="more"></a>


<h4 id="init-self-args-kwargs"><a href="#init-self-args-kwargs" class="headerlink" title="__init__(self,*args,**kwargs)"></a>__init__(self,*args,**kwargs)</h4><p>构造函数，在实例化对象的时候会自动运行</p>
<h4 id="del-self"><a href="#del-self" class="headerlink" title="__del__(self)"></a>__del__(self)</h4><p>析构函数,在对象被回收机制回收的时候会被调用</p>
<h4 id="str-self"><a href="#str-self" class="headerlink" title="__str__(self)"></a>__str__(self)</h4><p>输出函数,在实例对象请求输出的时候会被调用.</p>
<h4 id="repr-self"><a href="#repr-self" class="headerlink" title="__repr__(self)"></a>__repr__(self)</h4><p>当直接调用实例对象的时候会被调用</p>
<h4 id="new-self-类方法"><a href="#new-self-类方法" class="headerlink" title="__new__(self) 类方法"></a>__new__(self) 类方法</h4><p>她的第一个参数是这个类,其他的参数被直接传送到 __init__ ，并且 __new__ 是一个对象实例化的时候所调用的第一个方法(所以可以在这里做点手脚)</p>
<h4 id="bool-self"><a href="#bool-self" class="headerlink" title="__bool__(self)"></a>__bool__(self)</h4><p>定义当被bool类调用的时候,应当返回的值</p>
<h4 id="len-self"><a href="#len-self" class="headerlink" title="__len__(self)"></a>__len__(self)</h4><p>定义单被len调用的时候的行为</p>
<h4 id="hash-self"><a href="#hash-self" class="headerlink" title="__hash__(self)"></a>__hash__(self)</h4><p>定义当被hash调用的时候返回的函数</p>
<h4 id="getattr-self-name"><a href="#getattr-self-name" class="headerlink" title="__getattr__(self,name)"></a>__getattr__(self,name)</h4><p>定义当用户试图访问一个不存在的属性时，所执行的行为</p>
<h4 id="getattribute-self-name"><a href="#getattribute-self-name" class="headerlink" title="__getattribute__(self,name)"></a>__getattribute__(self,name)</h4><p>定义当该属性被访问时的行为</p>
<h4 id="setattribute-self-name-value"><a href="#setattribute-self-name-value" class="headerlink" title="__setattribute__(self,name,value)"></a>__setattribute__(self,name,value)</h4><p>定义一个属性被设置时的行为</p>
<h4 id="delattr-self-name"><a href="#delattr-self-name" class="headerlink" title="__delattr__(self,name)"></a>__delattr__(self,name)</h4><p>定义一个属性被删除时的行为</p>
<h4 id="dir-self"><a href="#dir-self" class="headerlink" title="__dir__(self)"></a>__dir__(self)</h4><p>定义dir被调用时的行为</p>
<h4 id="get-self-instance-owner"><a href="#get-self-instance-owner" class="headerlink" title="__get__(self,instance,owner)"></a>__get__(self,instance,owner)</h4><p>定义当描述符被取得时的行为</p>
<h4 id="set-self-instance-owner"><a href="#set-self-instance-owner" class="headerlink" title="__set__(self,instance,owner)"></a>__set__(self,instance,owner)</h4><p>定义当描述符的值被改变是的行为</p>
<h4 id="delete-self-instance"><a href="#delete-self-instance" class="headerlink" title="__delete__(self,instance)"></a>__delete__(self,instance)</h4><p>定义当描述符被删除时的行为</p>
<h4 id="class"><a href="#class" class="headerlink" title="__class__"></a>__class__</h4><p>这个方法用于查看对象属于是哪个生成的，这样理解在python中的所有东西都是对象，类对象也是对象。如果按照以前的思维来想的话就是类是元类的实例，而实例对象是类的实例。</p>
<h4 id="bases"><a href="#bases" class="headerlink" title="__bases__"></a>__bases__</h4><p>这个方法用于得到一个对象的父类是谁，特别注意一下__base__返回单个父类，__bases__以tuple形式返回所有父类。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP 协议三次握手和四次挥手</title>
    <url>/2019/07/04/network/tcp_ip_connect/</url>
    <content><![CDATA[<h1 id="TCP-IP-协议三次握手和四次挥手"><a href="#TCP-IP-协议三次握手和四次挥手" class="headerlink" title="TCP/IP 协议三次握手和四次挥手"></a>TCP/IP 协议三次握手和四次挥手</h1><a id="more"></a>

<h3 id="什么是3次握手，4次握手"><a href="#什么是3次握手，4次握手" class="headerlink" title="什么是3次握手，4次握手"></a>什么是3次握手，4次握手</h3><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。<br>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。<br>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p>
<h4 id="TCP服务模型"><a href="#TCP服务模型" class="headerlink" title="TCP服务模型"></a>TCP服务模型</h4><p>在了解了建立连接、关闭连接的“三次握手和四次挥手”后，我们再来看下TCP相关的东西。<br>一个TCP连接由一个4元组构成，分别是两个IP地址和两个端口号。一个TCP连接通常分为三个阶段：启动、数据传输、退出（关闭）。<br>当TCP接收到另一端的数据时，它会发送一个确认，但这个确认不会立即发送，一般会延迟一会儿。ACK是累积的，一个确认字节号N的ACK表示所有直到N的字节（不包括N）已经成功被接收了。这样的好处是如果一个ACK丢失，很可能后续的ACK就足以确认前面的报文段了。<br>一个完整的TCP连接是双向和对称的，数据可以在两个方向上平等地流动。给上层应用程序提供一种双工服务。一旦建立了一个连接，这个连接的一个方向上的每个TCP报文段都包含了相反方向上的报文段的一个ACK。<br>序列号的作用是使得一个TCP接收端可丢弃重复的报文段，记录以杂乱次序到达的报文段。因为TCP使用IP来传输报文段，而IP不提供重复消除或者保证次序正确的功能。另一方面，TCP是一个字节流协议，绝不会以杂乱的次序给上层程序发送数据。因此TCP接收端会被迫先保持大序列号的数据不交给应用程序，直到缺失的小序列号的报文段被填满。</p>
<h4 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h4><p>源端口和目的端口在TCP层确定双方进程，序列号表示的是报文段数据中的第一个字节号，ACK表示确认号，该确认号的发送方期待接收的下一个序列号，即最后被成功接收的数据字节序列号加1，这个字段只有在ACK位被启用的时候才有效。<br>当新建一个连接时，从客户端发送到服务端的第一个报文段的SYN位被启用，这称为SYN报文段，这时序列号字段包含了在本次连接的这个方向上要使用的第一个序列号，即初始序列号ISN，之后发送的数据是ISN加1，因此SYN位字段会消耗一个序列号，这意味着使用重传进行可靠传输。而不消耗序列号的ACK则不是。<br>头部长度（图中的数据偏移）以32位字为单位，也就是以4bytes为单位，它只有4位，最大为15，因此头部最大长度为60字节，而其最小为5，也就是头部最小为20字节（可变选项为空）。<br>ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。<br>当一个连接被建立或被终止时，交换的报文段只包含TCP头部，而没有数据。</p>
<h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p><img src="/images/network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="三次握手"></p>
<h3 id="为什么要“三次握手，四次挥手”"><a href="#为什么要“三次握手，四次挥手”" class="headerlink" title="为什么要“三次握手，四次挥手”"></a>为什么要“三次握手，四次挥手”</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>换个易于理解的视角来看为什么要3次握手。<br>客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。<br>经历了上面的三次握手过程，客户端和服务端都确认了自己的接收、发送能力是正常的。之后就可以正常通信了。<br>每次都是接收到数据包的一方可以得到一些结论，发送的一方其实没有任何头绪。我虽然有发包的动作，但是我怎么知道我有没有发出去，而对方有没有接收到呢？<br>而从上面的过程可以看到，最少是需要三次握手过程的。两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论。其实每次收到网络包的一方至少是可以得到：对方的发送、我方的接收是正常的。而每一步都是有关联的，下一次的“响应”是由于第一次的“请求”触发，因此每次握手其实是可以得到额外的结论的。比如第三次握手时，服务端收到数据包，表明看服务端只能得到客户端的发送能力、服务端的接收能力是正常的，但是结合第二次，说明服务端在第二次发送的响应包，客户端接收到了，并且作出了响应，从而得到额外的结论：客户端的接收、服务端的发送是正常的。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。注意，接收到FIN报文的一方只能回复一个ACK, 它是无法马上返回对方一个FIN报文段的，因为结束数据传输的“指令”是上层应用层给出的，我只是一个“搬运工”，我无法了解“上层的意志”。</p>
<h3 id="“三次握手，四次挥手”怎么完成？"><a href="#“三次握手，四次挥手”怎么完成？" class="headerlink" title="“三次握手，四次挥手”怎么完成？"></a>“三次握手，四次挥手”怎么完成？</h3><p>其实3次握手的目的并不只是让通信双方都了解到一个连接正在建立，还在于利用数据包的选项来传输特殊的信息，交换初始序列号ISN。<br>3次握手是指发送了3个报文段，4次挥手是指发送了4个报文段。注意，SYN和FIN段都是会利用重传进行可靠传输的。</p>
<h4 id="三次握手-1"><a href="#三次握手-1" class="headerlink" title="三次握手"></a>三次握手</h4><ol>
<li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li>
<li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li>
<li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li>
</ol>
<h4 id="四次挥手-1"><a href="#四次挥手-1" class="headerlink" title="四次挥手"></a>四次挥手</h4><ol>
<li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </li>
<li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li>
<li>服务端发起自己的FIN段，ACK=K+1, Seq=L </li>
<li>客户端确认。ACK=L+1</li>
</ol>
<h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p>
<h3 id="“三次握手，四次挥手”进阶"><a href="#“三次握手，四次挥手”进阶" class="headerlink" title="“三次握手，四次挥手”进阶"></a>“三次握手，四次挥手”进阶</h3><h4 id="ISN"><a href="#ISN" class="headerlink" title="ISN"></a>ISN</h4><p>三次握手的一个重要功能是客户端和服务端交换ISN(Initial Sequence Number), 以便让对方知道接下来接收数据的时候如何按序列号组装数据。<br>如果ISN是固定的，攻击者很容易猜出后续的确认号。</p>
<p>$ ISN = M + F(localhost, localport, remotehost, remoteport) $</p>
<p>M是一个计时器，每隔4微秒加1。 F是一个Hash算法，根据源IP、目的IP、源端口、目的端口生成一个随机数值。要保证hash算法不能被外部轻易推算得出。</p>
<h4 id="序列号回绕"><a href="#序列号回绕" class="headerlink" title="序列号回绕"></a>序列号回绕</h4><p>因为ISN是随机的，所以序列号容易就会超过2^31-1. 而tcp对于丢包和乱序等问题的判断都是依赖于序列号大小比较的。此时就出现了所谓的tcp序列号回绕（sequence wraparound）问题。怎么解决？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** The next routines deal with comparing 32 bit unsigned ints</span><br><span class="line"> * and worry about wraparound (automatic with unsigned arithmetic).*&#x2F;</span><br><span class="line"></span><br><span class="line">staticinlineintbefore(__u32 seq1, __u32 seq2)&#123;   </span><br><span class="line">     return (__s32)(seq1-seq2) &lt;0;</span><br><span class="line">&#125;</span><br><span class="line">#define after(seq2, seq1) before(seq1, seq2)</span><br></pre></td></tr></table></figure>

<p>上述代码是内核中的解决回绕问题代码。s32是有符号整型的意思，而u32则是无符号整型。序列号发生回绕后，序列号变小，相减之后，把结果变成有符号数了，因此结果成了负数。</p>
<p>假设seq1=255， seq2=1（发生了回绕）。<br>seq1 = 1111 1111 seq2 = 0000 0001<br>我们希望比较结果是<br> seq1 - seq2= 1111 1111 -0000 0001<br> 1111 1110<br> 由于我们将结果转化成了有符号数，由于最高位是1，因此结果是一个负数，<br> 负数的绝对值为 0000 0001 + 1 = 0000 0010 = 2因此seq1 - seq2 &lt; 0</p>
<h3 id="syn-flood攻击"><a href="#syn-flood攻击" class="headerlink" title="syn flood攻击"></a>syn flood攻击</h3><p>最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。syn flood属于Dos攻击的一种。<br>如果恶意的向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一 旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p>
<p>常见的防攻击方法有：</p>
<h4 id="无效连接的监视释放"><a href="#无效连接的监视释放" class="headerlink" title="无效连接的监视释放"></a>无效连接的监视释放</h4><p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p>
<h4 id="延缓TCB分配方法"><a href="#延缓TCB分配方法" class="headerlink" title="延缓TCB分配方法"></a>延缓TCB分配方法</h4><p>消耗服务器资源主要是因为当SYN数据报文一到达，系统立即分配TCB，从而占用了资源。而SYN Flood由于很难建立起正常连接，因此，当正常连接建立起来后再分配TCB则可以有效地减轻服务器资源的消耗。常见的方法是使用Syn Cache和Syn Cookie技术。</p>
<h4 id="Syn-Cache技术"><a href="#Syn-Cache技术" class="headerlink" title="Syn Cache技术"></a>Syn Cache技术</h4><p>系统在收到一个SYN报文时，在一个专用HASH表中保存这种半连接信息，直到收到正确的回应ACK报文再分配TCB。这个开销远小于TCB的开销。当然还需要保存序列号。</p>
<h4 id="Syn-Cookie技术"><a href="#Syn-Cookie技术" class="headerlink" title="Syn Cookie技术"></a>Syn Cookie技术</h4><p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS(Maximum Segment Size，最大报文段大小，指的是TCP报文的最大数据报长度，其中不包括TCP首部长度。)、时间等，在收到对方 的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（Sequence Number-1）相同，从而决定是否分配TCB资源。</p>
<h4 id="使用SYN-Proxy防火墙"><a href="#使用SYN-Proxy防火墙" class="headerlink" title="使用SYN Proxy防火墙"></a>使用SYN Proxy防火墙</h4><p>一种方式是防止墙dqywb连接的有效性后，防火墙才会向内部服务器发起SYN请求。防火墙代服务器发出的SYN ACK包使用的序列号为c, 而真正的服务器回应的序列号为c’, 这样，在每个数据报文经过防火墙的时候进行序列号的修改。另一种方式是防火墙确定了连接的安全后，会发出一个safe reset命令，client会进行重新连接，这时出现的syn报文会直接放行。这样不需要修改序列号了。但是，client需要发起两次握手过程，因此建立连接的时间将会延长。</p>
<h3 id="连接队列"><a href="#连接队列" class="headerlink" title="连接队列"></a>连接队列</h3><p>在外部请求到达时，被服务程序最终感知到前，连接可能处于SYN_RCVD状态或是ESTABLISHED状态，但还未被应用程序接受。<br>对应地，服务器端也会维护两种队列，处于SYN_RCVD状态的半连接队列，而处于ESTABLISHED状态但仍未被应用程序accept的为全连接队列。如果这两个队列满了之后，就会出现各种丢包的情形。<br>查看是否有连接溢出<code>netstat -s | grep LISTEN</code></p>
<h4 id="半连接队列满了"><a href="#半连接队列满了" class="headerlink" title="半连接队列满了"></a>半连接队列满了</h4><p>在三次握手协议中，服务器维护一个半连接队列，该队列为每个客户端的SYN包开设一个条目(服务端在接收到SYN包的时候，就已经创建了request_sock结构，存储在半连接队列中)，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。</p>
<blockquote>
<p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s, 总共31s, 称为指数退避，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s, TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称SYN flood攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p>
</blockquote>
<p><img src="/images/network/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86.jpg" alt="半连接队列满了"></p>
<h4 id="全连接队列满了"><a href="#全连接队列满了" class="headerlink" title="全连接队列满了"></a>全连接队列满了</h4><p>当第三次握手时，当server接收到ACK包之后，会进入一个新的叫 accept 的队列。<br>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；相应的，client则会分别返回read timeout 或者 connection reset by peer。<br>另外，tcp_abort_on_overflow是0的话，server过一段时间再次发送syn+ack给client（也就是重新走握手的第二步），如果client超时等待比较短，就很容易异常了。而客户端收到多个 SYN ACK 包，则会认为之前的 ACK 丢包了。于是促使客户端再次发送 ACK ，在 accept队列有空闲的时候最终完成连接。<br>若 accept队列始终满员，则最终客户端收到 RST 包（此时服务端发送syn+ack的次数超出了tcp_synack_retries）。<br>服务端仅仅只是创建一个定时器，以固定间隔重传syn和ack到服务端</p>
<p><img src="/images/network/%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BB%A1.jpg" alt="全连接队列满"></p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="netstat-s命令"><a href="#netstat-s命令" class="headerlink" title="netstat -s命令"></a>netstat -s命令</h4><p><code>netstat -s | egrep &quot;listen|LISTEN&quot;</code></p>
<p>表示全连接队列溢出的次数，隔几秒钟执行下，如果这个数字一直在增加的话肯定全连接队列偶尔满了。</p>
<p><code>netstat -s | grep TCPBacklogDrop</code></p>
<p>查看 Accept queue 是否有溢出</p>
<h4 id="ss命令"><a href="#ss命令" class="headerlink" title="ss命令"></a>ss命令</h4><p><code>ss -lnt</code></p>
<p>如果State是listen状态，Send-Q 表示第三列的listen端口上的全连接队列最大为50，第一列Recv-Q为全连接队列当前使用了多少。 非 LISTEN 状态中 Recv-Q 表示 receive queue 中的 bytes 数量；Send-Q 表示 send queue 中的 bytes 数值。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当外部连接请求到来时，TCP模块会首先查看tcp_max_syn_backlog，如果处于SYN_RCVD状态的连接数目超过这一阈值，进入的连接会被拒绝。根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.<br>从服务端来说，三次握手中，第一步server接受到client的syn后，把相关信息放到半连接队列中，同时回复syn+ack给client. 第三步当收到客户端的ack, 将连接加入到全连接队列。<br>一般，全连接队列比较小，会先满，此时半连接队列还没满。如果这时收到syn报文，则会进入半连接队列，没有问题。但是如果收到了三次握手中的第3步(ACK)，则会根据tcp_abort_on_overflow字段来决定是直接丢弃，还是直接reset.此时，客户端发送了ACK, 那么客户端认为三次握手完成，它认为服务端已经准备好了接收数据的准备。但此时服务端可能因为全连接队列满了而无法将连接放入，会重新发送第2步的syn+ack, 如果这时有数据到来，服务器TCP模块会将数据存入队列中。一段时间后，client端没收到回复，超时，连接异常，client会主动关闭连接。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS工作流程</title>
    <url>/2019/07/04/network/https_worker/</url>
    <content><![CDATA[<h1 id="普及-HTTPS工作流程"><a href="#普及-HTTPS工作流程" class="headerlink" title="(普及)HTTPS工作流程"></a>(普及)HTTPS工作流程</h1><a id="more"></a>

<h3 id="简单回顾"><a href="#简单回顾" class="headerlink" title="简单回顾"></a>简单回顾</h3><p>在前面两篇博客中介绍了密码相关的一些基本工具，包括（对称密码，公钥密码，密码散列函数，混合密码系统，消息认证码码，数字签名，伪随机数，数字证书）这几个。其中它们之间也是互相依赖的，我们来简单的梳理一下它们的依赖关系。</p>
<ul>
<li>对称密码：无。</li>
<li>公钥密码：无。</li>
<li>密码散列函数：无。</li>
<li>伪随机数：可以利用密码散列函数来实现，也可以不使用。</li>
<li>混合密码系统：对称密码 + 公钥密码 + 密码散列函数。</li>
<li>消息认证码：密码散列函数 + 对称密码。</li>
<li>数字签名：密码散列函数 + 公钥密码。</li>
<li>数字证书：公钥密码 + 数字签名。</li>
</ul>
<p>这篇要介绍的HTTPS，则把以上这些全都派上场了。</p>
<h3 id="HTTPS-简史"><a href="#HTTPS-简史" class="headerlink" title="HTTPS 简史"></a>HTTPS 简史</h3><p>在早期HTTP诞生的这几年间，1990年~1994年，HTTP作为一个应用层协议，它是这样工作的:</p>
<p><img src="/images/network/http%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt="http工作模式"></p>
<p>后来网景公司开发了SSL（Secure Sockets Layer）技术，然后它就变成了这样的HTTP，也就是HTTPS了：</p>
<p><img src="/images/network/https%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt="https工作模式"></p>
<p>后来爆发了与IE的世纪大战，网景败北，SSL移交给了IETF（Internat Engineering Task Force）互联网工程任务组，标准化之后变成了现在的TLS，现在一般会把它们两个放在一起称为SSL/TLS。本篇并不关注SSL/TLS具体是如何工作的，只是抽象的解释下HTTPS的一个工作流程。</p>
<h3 id="HTTPS-工作流程"><a href="#HTTPS-工作流程" class="headerlink" title="HTTPS 工作流程"></a>HTTPS 工作流程</h3><p><img src="/images/network/https%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="https工作流程"></p>
<ol>
<li>Client发起一个HTTPS（https:/demo.linianhui.dev）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。</li>
<li>Server把事先配置好的公钥证书（public key certificate）返回给客户端。</li>
<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li>
<li>Client使用伪随机数生成器生成加密所使用的会话密钥，然后用证书的公钥加密这个会话密钥，发给Server。</li>
<li>Server使用自己的私钥（private key）解密这个消息，得到会话密钥。至此，Client和Server双方都持有了相同的会话密钥。</li>
<li>Server使用会话密钥加密“明文内容A”，发送给Client。</li>
<li>Client使用会话密钥解密响应的密文，得到“明文内容A”。</li>
<li>Client再次发起HTTPS的请求，使用会话密钥加密请求的“明文内容B”，然后Server使用会话密钥解密密文，得到“明文内容B”。</li>
</ol>
<p>具体的格式可以参考MDN的一个说明<a class="link"   href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format%E3%80%82" >https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format。<i class="fas fa-external-link-alt"></i></a></p>
<p>以上只是一个抽象的HTTPS的一个工作流程，实际上SSL/TLS所做的工作远不止这这些，更详细的解释请参考这篇文章：<a class="link"   href="https://infoq.cn/article/HTTPS-Connection-Jeff-Moser" >https://infoq.cn/article/HTTPS-Connection-Jeff-Moser<i class="fas fa-external-link-alt"></i></a></p>
<p>如有错误之处，欢迎指正！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>SSL/TLS：<a class="link"   href="https://en.wikipedia.org/wiki/Transport_Layer_Security" >https://en.wikipedia.org/wiki/Transport_Layer_Security<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>IETF：<a class="link"   href="https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force" >https://en.wikipedia.org/wiki/Internet_Engineering_Task_Force<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>HTTPS：<a class="link"   href="https://en.wikipedia.org/wiki/HTTPS" >https://en.wikipedia.org/wiki/HTTPS<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>HTTPS 连接最初的若干毫秒：<a class="link"   href="http://www.infoq.com/cn/articles/HTTPS-Connection-Jeff-Moser" >http://www.infoq.com/cn/articles/HTTPS-Connection-Jeff-Moser<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>HTTPS on Stack Overflow: The End of a Long Road：<a class="link"   href="https://nickcraver.com/blog/2017/05/22/https-on-stack-overflow/" >https://nickcraver.com/blog/2017/05/22/https-on-stack-overflow/<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>SSL/TLS部署最佳实践：<a class="link"   href="https://github.com/ssllabs/research/wiki/SSL-and-TLS-Deployment-Best-Practices" >https://github.com/ssllabs/research/wiki/SSL-and-TLS-Deployment-Best-Practices<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>HTTP Over TLS：<a class="link"   href="https://tools.ietf.org/html/rfc2818" >https://tools.ietf.org/html/rfc2818<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>SSLKEYLOGFILE：<a class="link"   href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format" >https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>53.最大子序和</title>
    <url>/2019/07/04/leetcode/53/</url>
    <content><![CDATA[<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p>进阶:</p>
<p>如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	max := nums[<span class="number">0</span>]</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="comment">// sum&gt;0 即 sum+n&gt;n，所以当前取 sum+n</span></span><br><span class="line">		<span class="comment">// sum&lt;=0 则 sum+n&lt;=n, 所以取 n</span></span><br><span class="line">		<span class="keyword">if</span> sum &gt; <span class="number">0</span> &#123;</span><br><span class="line">			sum += n</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sum = n</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// compare current value with former max</span></span><br><span class="line">		<span class="keyword">if</span> sum &gt; max &#123;</span><br><span class="line">			max = sum</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>58.最后一个单词的长度</title>
    <url>/2019/07/04/leetcode/58/</url>
    <content><![CDATA[<p>给定一个仅包含大小写字母和空格 ‘ ‘ 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<a id="more"></a>

<p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;Hello World&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLastWord</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s==<span class="string">&quot;&quot;</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	s=strings.TrimSpace(s)</span><br><span class="line">	strList := strings.Split(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	num := <span class="built_in">len</span>(strList)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>([]<span class="keyword">rune</span>(strList[num<span class="number">-1</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>66.加一</title>
    <url>/2019/07/04/leetcode/66/</url>
    <content><![CDATA[<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	length:=<span class="built_in">len</span>(digits)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> length&gt;=<span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> digits[length] !=<span class="number">9</span>&#123;</span><br><span class="line">			digits[length]+=<span class="number">1</span></span><br><span class="line">			<span class="keyword">return</span> digits</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			digits[length] = <span class="number">0</span></span><br><span class="line">			<span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">				digits = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;,digits...)</span><br><span class="line">			&#125;</span><br><span class="line">			length--</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> digits</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>7.整数反转</title>
    <url>/2019/07/04/leetcode/7/</url>
    <content><![CDATA[<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong><br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nums,newnums <span class="keyword">int</span></span><br><span class="line">    MaxInt32 := <span class="number">1</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">	MinInt32 := <span class="number">-1</span> &lt;&lt; <span class="number">31</span></span><br><span class="line">	<span class="keyword">for</span>  x != <span class="number">0</span>&#123;</span><br><span class="line">		a:=x%<span class="number">10</span></span><br><span class="line">		newnums=nums*<span class="number">10</span>+a</span><br><span class="line">		nums=newnums</span><br><span class="line">		x=x/<span class="number">10</span>		</span><br><span class="line">		<span class="keyword">if</span> nums &gt; MaxInt32 || nums &lt; MinInt32 &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>70.爬楼梯</title>
    <url>/2019/07/04/leetcode/70/</url>
    <content><![CDATA[<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<a id="more"></a>

<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>83. 删除排序链表中的重复元素</title>
    <url>/2019/07/04/leetcode/83/</url>
    <content><![CDATA[<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteDuplicates</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">nil</span> == head || <span class="literal">nil</span> == head.Next &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line">	curr := head</span><br><span class="line">	<span class="keyword">for</span> <span class="literal">nil</span> != curr &amp;&amp; <span class="literal">nil</span> != curr.Next &#123;</span><br><span class="line">		<span class="keyword">if</span> curr.Val == curr.Next.Val &#123;</span><br><span class="line">			curr.Next = curr.Next.Next</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			curr = curr.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>88. 合并两个有序数组</title>
    <url>/2019/07/04/leetcode/88/</url>
    <content><![CDATA[<p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p>
<a id="more"></a>

<p>说明:</p>
<blockquote>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</p>
<p>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
</blockquote>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	temp := <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line">	<span class="built_in">copy</span>(temp, nums1)</span><br><span class="line"></span><br><span class="line">	t, j := <span class="number">0</span>, <span class="number">0</span> <span class="comment">//t为temp的索引，j为nums2的索引</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums1); i++ &#123;</span><br><span class="line">		<span class="comment">//当t大于temp的长度，那就是说temp全部放进去了nums1中，那剩下的就是放nums2剩余的值了</span></span><br><span class="line">		<span class="keyword">if</span> t &gt;= <span class="built_in">len</span>(temp) &#123;</span><br><span class="line">			nums1[i] = nums2[j]</span><br><span class="line">			j++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当j大于nums2的长度的时候，那就是说明nums2全部都放进去了nums1中，那剩下的就是放temp剩余的值了</span></span><br><span class="line">		<span class="keyword">if</span> j &gt;= n &#123;</span><br><span class="line">			nums1[i] = temp[t]</span><br><span class="line">			t++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//比较nums2与temp对应值的大小，小的那个就放进nums1中</span></span><br><span class="line">		<span class="keyword">if</span> nums2[j] &lt;= temp[t] &#123;</span><br><span class="line">			nums1[i] = nums2[j]</span><br><span class="line">			j++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nums1[i] = temp[t]</span><br><span class="line">			t++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>9.回文数</title>
    <url>/2019/07/04/leetcode/9/</url>
    <content><![CDATA[<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong><br>你能不将整数转为字符串来解决这个问题吗？</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    y := x</span><br><span class="line">    <span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> y != <span class="number">0</span> &#123;</span><br><span class="line">        num = num * <span class="number">10</span> + y % <span class="number">10</span></span><br><span class="line">        y = y / <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> || num != x &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>136. 只出现一次的数字</title>
    <url>/2019/07/04/leetcode/136/</url>
    <content><![CDATA[<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<a id="more"></a>

<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	a:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _,n := <span class="keyword">range</span> nums&#123;</span><br><span class="line">	a^=n</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>15.三数之和</title>
    <url>/2019/07/04/leetcode/15/</url>
    <content><![CDATA[<p>给定一个包含 n 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p>
<a id="more"></a>

<p>注意：答案中不可以包含重复的三元组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如, 给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">//定义结果集</span></span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断长度是否大于3</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> result</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//升序排列---关键</span></span><br><span class="line">	sort.Ints(nums)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始遍历i,j,k 三个同时</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(nums)<span class="number">-3</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//第二个</span></span><br><span class="line">		j := i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//第三个</span></span><br><span class="line">		k := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">		<span class="comment">//[j:k] 构成的区间来找 num[j]+num[k] = -num[i]</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//判断后一个和之前遍历过如果相等跳过</span></span><br><span class="line">		<span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//[j:k] 区间未结束</span></span><br><span class="line">		<span class="keyword">for</span> j &lt; k &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i]+nums[j]+nums[k] == <span class="number">0</span> &#123; <span class="comment">//相等存放</span></span><br><span class="line">				result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;nums[i], nums[j], nums[k]&#125;)</span><br><span class="line">				j++</span><br><span class="line">				<span class="comment">//判断后面的j 和前面的是否相等相等则跳过</span></span><br><span class="line">				<span class="keyword">for</span> j &lt; k &amp;&amp; nums[j] == nums[j<span class="number">-1</span>] &#123;</span><br><span class="line">					j++</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i]+nums[j]+nums[k] &gt; <span class="number">0</span> &#123; <span class="comment">//超过值则k-- 最右边的值大往左值小</span></span><br><span class="line">				k--</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;<span class="comment">//反之则右移</span></span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>155. 最小栈</title>
    <url>/2019/07/04/leetcode/155/</url>
    <content><![CDATA[<p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<ul>
<li>push(x) – 将元素 x 推入栈中。</li>
<li>pop() – 删除栈顶的元素。</li>
<li>top() – 获取栈顶元素。</li>
<li>getMin() – 检索栈中的最小元素。<a id="more"></a>

</li>
</ul>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	tmp []<span class="keyword">int</span></span><br><span class="line">	min <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">MinStack</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> MinStack&#123;tmp: []<span class="keyword">int</span>&#123;&#125;, min: <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MinStack)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	m.tmp = <span class="built_in">append</span>(m.tmp, x)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(m.tmp) == <span class="number">1</span> &#123;</span><br><span class="line">		m.min = x</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> x &lt; m.min &#123;</span><br><span class="line">		m.min = x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MinStack)</span> <span class="title">Pop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	remove := m.tmp[<span class="built_in">len</span>(m.tmp)<span class="number">-1</span>]</span><br><span class="line">	m.tmp = m.tmp[:<span class="built_in">len</span>(m.tmp)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">if</span> remove &lt;= m.min &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(m.tmp) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			m.min = m.tmp[<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		m.GetMinInfo()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MinStack)</span> <span class="title">Top</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.tmp[<span class="built_in">len</span>(m.tmp)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MinStack)</span> <span class="title">GetMin</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> m.min</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MinStack)</span> <span class="title">GetMinInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> m.tmp &#123;</span><br><span class="line">		<span class="keyword">if</span> i &lt; m.min &#123;</span><br><span class="line">			m.min = i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.GetMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>168. Excel表列名称</title>
    <url>/2019/07/04/leetcode/168/</url>
    <content><![CDATA[<p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p>
<a id="more"></a>

<p>例如，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;A&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 28</span><br><span class="line">输出: &quot;AB&quot;</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 701</span><br><span class="line">输出: &quot;ZY&quot;</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertToTitle</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		n -= <span class="number">1</span></span><br><span class="line">		byteInfo := []<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(n%<span class="number">26</span> + <span class="number">65</span>)&#125;</span><br><span class="line">		s=<span class="built_in">append</span>(byteInfo,s...)</span><br><span class="line">		n=n/<span class="number">26</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">string</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>13.罗马数字转整数</title>
    <url>/2019/07/04/leetcode/13/</url>
    <content><![CDATA[<a id="more"></a>

<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> +<code>II</code>。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> +<code>V</code>+ <code>II</code>。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做<code>IIII</code>，而是<code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。<br><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 <br><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure>
<p>示例 5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure>



<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    specialRomanStringMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;IV&quot;</span>: <span class="number">4</span>, <span class="string">&quot;IX&quot;</span>: <span class="number">9</span>, <span class="string">&quot;XL&quot;</span>: <span class="number">40</span>, <span class="string">&quot;XC&quot;</span>: <span class="number">90</span>, <span class="string">&quot;CD&quot;</span>: <span class="number">400</span>, <span class="string">&quot;CM&quot;</span>: <span class="number">900</span>&#125; <span class="comment">//特殊罗马数字</span></span><br><span class="line">    romanStringMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;I&quot;</span>: <span class="number">1</span>, <span class="string">&quot;V&quot;</span>: <span class="number">5</span>, <span class="string">&quot;X&quot;</span>: <span class="number">10</span>, <span class="string">&quot;L&quot;</span>: <span class="number">50</span>, <span class="string">&quot;C&quot;</span>: <span class="number">100</span>, <span class="string">&quot;D&quot;</span>: <span class="number">500</span>, <span class="string">&quot;M&quot;</span>: <span class="number">1000</span>&#125;   <span class="comment">//正常罗马数字</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">len</span>(s) != <span class="number">0</span> &#123; <span class="comment">//对字符串循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span> &#123; <span class="comment">//当长度大于1的时候，才有必要去特殊罗马数字map中查找</span></span><br><span class="line">            chars := s[<span class="number">0</span>:<span class="number">2</span>] <span class="comment">//首先我们得拿出两个字符去特殊的map中查找</span></span><br><span class="line">            <span class="keyword">if</span> v, ok := specialRomanStringMap[chars]; ok &#123; <span class="comment">//当存在的时候记录值</span></span><br><span class="line">                result += v</span><br><span class="line">                s = s[<span class="number">2</span>:]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//不存在的时候去正常map中查找，并记录</span></span><br><span class="line">                result += romanStringMap[<span class="keyword">string</span>(s[<span class="number">0</span>])]</span><br><span class="line">                s = s[<span class="number">1</span>:]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//当字符串的长度小于等于1的就只能去正常的罗马数字map中查找</span></span><br><span class="line">            result += romanStringMap[<span class="keyword">string</span>(s[<span class="number">0</span>])]</span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>rsync同步工具的使用</title>
    <url>/2019/07/04/linux/rsync/</url>
    <content><![CDATA[<h1 id="Linux-命令行中rsync-介绍"><a href="#Linux-命令行中rsync-介绍" class="headerlink" title="Linux 命令行中rsync 介绍"></a>Linux 命令行中rsync 介绍</h1><p>rsync 因其切割算法，及增量对比的优势，在文件同步中应用极为广泛</p>
<a id="more"></a>

<h2 id="增量算法"><a href="#增量算法" class="headerlink" title="增量算法"></a>增量算法</h2><p>rsync 可以在 同步的过程中，将一个大文件，分割成n个块，通过对块的同步，及校验，完成传输。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在遇到jar包、apk包等情况中，可以将其复制，在进行rsync增量同步，可以大大缩短时间</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><blockquote>
<p>-v, –verbose                  详细模式输出<br>-q, –quiet                       精简输出模式<br>-c, –checksum               打开校验开关，强制对文件传输进行校验<br>-a, –archive                   归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD<br>-r, –recursive                 对子目录以递归模式处理<br>-R, –relative                  使用相对路径信息<br>-b, –backup                  创建备份，也就是对于目的已经存在有同样的文件名时，将老的文件重新命名为<del>filename。可以使用–suffix选项来指定不同的备份文件前缀。<br>–backup-dir                  将备份文件(如</del>filename)存放在在目录下。<br>-suffix=SUFFIX             定义备份文件前缀<br>-u, –update                   仅仅进行更新，也就是跳过所有已经存在于DST，并且文件时间晚于要备份的文件。(不覆盖更新的文件)<br>-l, –links                         保留软链结<br>-L, –copy-links              想对待常规文件一样处理软链结<br>–copy-unsafe-links        仅仅拷贝指向SRC路径目录树以外的链结<br>–safe-links                     忽略指向SRC路径目录树以外的链结<br>-H, –hard-links              保留硬链结<br>-p, –perms                    保持文件权限<br>-o, –owner                    保持文件属主信息<br>-g, –group                     保持文件属组信息<br>-D, –devices                 保持设备文件信息<br>-t, –times                      保持文件时间信息<br>-S, –sparse                   对稀疏文件进行特殊处理以节省DST的空间<br>-n, –dry-run                  现实哪些文件将被传输<br>-W, –whole-file             拷贝文件，不进行增量检测<br>-x, –one-file-system      不要跨越文件系统边界<br>-B, –block-size=SIZE   检验算法使用的块尺寸，默认是700字节<br>-e, –rsh=COMMAND 指定使用rsh、ssh方式进行数据同步<br>–rsync-path=PATH      指定远程服务器上的rsync命令所在路径信息<br>-C, –cvs-exclude          使用和CVS一样的方法自动忽略文件，用来排除那些不希望传输的文件<br>–existing                      仅仅更新那些已经存在于DST的文件，而不备份那些新创建的文件<br>–delete                         删除那些DST中SRC没有的文件<br>–delete-excluded          同样删除接收端那些被该选项指定排除的文件<br>–delete-after                传输结束以后再删除<br>–ignore-errors             及时出现IO错误也进行删除<br>–max-delete=NUM     最多删除NUM个文件<br>–partial                        保留那些因故没有完全传输的文件，以是加快随后的再次传输<br>–force                          强制删除目录，即使不为空<br>–numeric-ids                不将数字的用户和组ID匹配为用户名和组名<br>–timeout=TIME IP       超时时间，单位为秒<br>-I, –ignore-times          不跳过那些有同样的时间和长度的文件<br>–size-only                    当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间<br>–modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0<br>-T –temp-dir=DIR      在DIR中创建临时文件<br>–compare-dest=DIR   同样比较DIR中的文件来决定是否需要备份<br>-P 等同于 –partial<br>–progress                    显示备份过程<br>-z, –compress             对备份的文件在传输时进行压缩处理<br>–exclude=PATTERN  指定排除不需要传输的文件模式<br>–include=PATTERN   指定不排除而需要传输的文件模式<br>–exclude-from=FILE   排除FILE中指定模式的文件<br>–include-from=FILE   不排除FILE指定模式匹配的文件<br>–version                      打印版本信息<br>–address                     绑定到特定的地址<br>–config=FILE             指定其他的配置文件，不使用默认的rsyncd.conf文件<br>–port=PORT              指定其他的rsync服务端口<br>–blocking-io               对远程shell使用阻塞IO<br>-stats                           给出某些文件的传输状态<br>–progress                   在传输时现实传输过程<br>–log-format=formAT  指定日志文件格式<br>–password-file=FILE 从FILE中得到密码<br>–bwlimit=KBPS         限制I/O带宽，KBytes per second<br>-h, –help                    显示帮助信息</p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>172. 阶乘后的零</title>
    <url>/2019/07/04/leetcode/172/</url>
    <content><![CDATA[<p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 0</span><br><span class="line">解释: 3! &#x3D; 6, 尾数中没有零。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 1</span><br><span class="line">解释: 5! &#x3D; 120, 尾数中有 1 个零.</span><br></pre></td></tr></table></figure>
<p>说明: 你算法的时间复杂度应为 O(log n) 。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trailingZeroes</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	result := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		result *= i</span><br><span class="line">	&#125;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> result%<span class="number">10</span> == <span class="number">0</span> &#123;</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			result = result / <span class="number">10</span></span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 使用 shadowsocket 翻墙</title>
    <url>/2019/07/04/linux/sslocal/</url>
    <content><![CDATA[<h1 id="linux-使用-shadowsocket-翻墙"><a href="#linux-使用-shadowsocket-翻墙" class="headerlink" title="linux 使用 shadowsocket 翻墙"></a>linux 使用 shadowsocket 翻墙</h1><p>ss-local 是 shadowsocks 的本地 socks5 服务器，如果需要使用 ss-local 提供的 socks5 代理，必须让应用程序使用 socks5 协议与之通信。但是很可惜，除了部分浏览器、软件直接支持 socks5 协议外，其它的都只支持 http 代理。因此，我们需要借助 privoxy 来将 http 代理协议转换为 socks5 代理协议，与后端的 ss-local 进行通信，与此同时我们还可以进行 gfwlist 分流操作。</p>
<a id="more"></a>

<h3 id="安装-ss-local"><a href="#安装-ss-local" class="headerlink" title="安装 ss-local"></a>安装 <code>ss-local</code></h3><p><code>pip install shadowsocks</code></p>
<blockquote>
<p>配置ss-local</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;1.2.3.4&quot;,          # 服务器IP</span><br><span class="line">    &quot;server_port&quot;: 8989,          # 服务器Port</span><br><span class="line">    &quot;method&quot;: &quot;aes-128-cfb&quot;,      # 加密方式</span><br><span class="line">    &quot;password&quot;: &quot;123456&quot;,         # 端口密码</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;, # 本地监听IP</span><br><span class="line">    &quot;local_port&quot;: 1080,           # 本地监听Port</span><br><span class="line">    &quot;fast_open&quot;: true,            # TCP Fast Open</span><br><span class="line">    &quot;workers&quot;: 1                  # worker进程数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动ss-local<br><code>sslocal -c /etc/ss-local.json</code></p>
</blockquote>
<h3 id="安装-privoxy"><a href="#安装-privoxy" class="headerlink" title="安装 privoxy"></a>安装 <code>privoxy</code></h3><p><code>yum -y install privoxy</code></p>
<blockquote>
<p>配置 privoxy的config文件，配置监听端口</p>
</blockquote>
<blockquote>
<p>启动privoxy</p>
</blockquote>
<p><code>privoxy config</code></p>
<h3 id="在命令行配置-proxy"><a href="#在命令行配置-proxy" class="headerlink" title="在命令行配置 proxy"></a>在命令行配置 proxy</h3><blockquote>
<p><code>export http_proxy=http://127.0.0.1:$&#123;privoxy监听端口&#125;</code><br><code>export https_proxy=http://127.0.0.1:$&#123;privoxy监听端口&#125;</code></p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>190. 颠倒二进制位</title>
    <url>/2019/07/04/leetcode/190/</url>
    <content><![CDATA[<p>颠倒给定的 32 位无符号整数的二进制位。</p>
<a id="more"></a>

<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br><span class="line">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class="line">      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：10111111111111111111111111111111</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，</span><br><span class="line">      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBits</span><span class="params">(n <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ans <span class="keyword">uint32</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">32</span></span><br><span class="line">	<span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">		i--</span><br><span class="line">		ans &lt;&lt;= <span class="number">1</span></span><br><span class="line">		ans += n &amp; <span class="number">1</span></span><br><span class="line">		n &gt;&gt;= <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>125. 验证回文串</title>
    <url>/2019/07/04/leetcode/125/</url>
    <content><![CDATA[<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>说明：本题中，我们将空字符串定义为有效的回文串。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s_filter = <span class="string">&#x27;&#x27;</span>.join(filter(str.isalnum, s)).lower()</span><br><span class="line">        <span class="keyword">return</span> s_filter[::<span class="number">-1</span>] == s_filter</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <url>/2019/07/04/leetcode/122/</url>
    <content><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<a id="more"></a>

<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> yesterday = prices[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> idx := <span class="number">1</span>; idx &lt; <span class="built_in">len</span>(prices); idx++ &#123;</span><br><span class="line">		today := prices[idx]</span><br><span class="line">		<span class="keyword">if</span> today &gt; yesterday &#123;</span><br><span class="line">			count += today - yesterday</span><br><span class="line">		&#125;</span><br><span class="line">        yesterday = today</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2.两数相加</title>
    <url>/2019/07/04/leetcode/2/</url>
    <content><![CDATA[<p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<a id="more"></a>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1, l2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p = l1</span><br><span class="line">        a,b = <span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            a = a + str(p.val)</span><br><span class="line">            p = p.next</span><br><span class="line">        p = l2</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            b += str(p.val)</span><br><span class="line">            p = p.next</span><br><span class="line">        c = int(a[::<span class="number">-1</span>])+int(b[::<span class="number">-1</span>])</span><br><span class="line">        result = ListNode(<span class="number">0</span>)</span><br><span class="line">        r = result</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> str(c)[::<span class="number">-1</span>]:</span><br><span class="line">            r.next = ListNode(int(i))</span><br><span class="line">            r = r.next</span><br><span class="line">        <span class="keyword">return</span> result.next</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>20.有效的括号</title>
    <url>/2019/07/04/leetcode/20/</url>
    <content><![CDATA[<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p>
<a id="more"></a>

<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 5:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	flag := <span class="literal">false</span></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">byte</span>)</span><br><span class="line">	m[<span class="string">&#x27;(&#x27;</span>] = <span class="string">&#x27;)&#x27;</span></span><br><span class="line">	m[<span class="string">&#x27;[&#x27;</span>] = <span class="string">&#x27;]&#x27;</span></span><br><span class="line">	m[<span class="string">&#x27;&#123;&#x27;</span>] = <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">	sli := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s)%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i, b := <span class="keyword">range</span> s &#123;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &amp;&amp; (s[i] == <span class="string">&#x27;)&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> || s[i] == <span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> b == <span class="string">&#x27;(&#x27;</span> || b == <span class="string">&#x27;[&#x27;</span> || b == <span class="string">&#x27;&#123;&#x27;</span> &#123;</span><br><span class="line">			sli = <span class="built_in">append</span>(sli, <span class="keyword">byte</span>(b))</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> b == <span class="string">&#x27;)&#x27;</span> || b == <span class="string">&#x27;]&#x27;</span> || b == <span class="string">&#x27;&#125;&#x27;</span> &#123;</span><br><span class="line">			left := sli[<span class="built_in">len</span>(sli)<span class="number">-1</span>]</span><br><span class="line">			sli = sli[:<span class="built_in">len</span>(sli)<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">if</span> m[left] == <span class="keyword">byte</span>(b) &#123;</span><br><span class="line">				flag = <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="built_in">len</span>(s)<span class="number">-1</span> &amp;&amp; <span class="built_in">len</span>(sli) != <span class="number">0</span> &#123;</span><br><span class="line">			flag = <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <url>/2019/07/04/leetcode/121/</url>
    <content><![CDATA[<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<a id="more"></a>

<p>注意你不能在买入股票前卖出股票。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> mini = prices[<span class="number">0</span>] <span class="comment">//1</span></span><br><span class="line">	<span class="keyword">var</span> maxP = <span class="number">0</span> </span><br><span class="line">	<span class="keyword">for</span> idx := <span class="number">1</span>; idx &lt; <span class="built_in">len</span>(prices); idx++ &#123;</span><br><span class="line">		<span class="comment">//1 , 1&lt;7,1+</span></span><br><span class="line">		cur := prices[idx] <span class="comment">//2</span></span><br><span class="line">		<span class="keyword">if</span> cur &gt; mini &#123; </span><br><span class="line">			curP := cur - mini </span><br><span class="line">			<span class="keyword">if</span> curP &gt; maxP &#123;</span><br><span class="line">				maxP = curP</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> cur &lt; mini &#123;</span><br><span class="line">			mini = cur</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>119. 杨辉三角 II</title>
    <url>/2019/07/04/leetcode/119/</url>
    <content><![CDATA[<p>给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。</p>
<p><img src="/images/leetcode/119.gif" alt="119"></p>
<a id="more"></a>

<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure>
<p>进阶：</p>
<p>你可以优化你的算法到 O(k) 空间复杂度吗？</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRow</span><span class="params">(rowIndex <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> tmp []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> number <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= rowIndex; j++ &#123;</span><br><span class="line">		tmp = <span class="built_in">append</span>(tmp, number)</span><br><span class="line">		number = number * (rowIndex - j) / (j + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1189. “气球” 的最大数量</title>
    <url>/2019/07/04/leetcode/1189/</url>
    <content><![CDATA[<p>给你一个字符串 <code>text</code>，你需要使用 text 中的字母来拼凑尽可能多的单词 <code>&quot;balloon&quot;（气球）</code>。</p>
<p>字符串 <code>text</code> 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 “balloon”。</p>
<a id="more"></a>



<p>示例：</p>
<p>输入：<code>text = &quot;nlaebolko&quot;</code><br>输出：<code>1</code></p>
<p>输入：<code>text = &quot;loonbalxballpoon&quot;</code><br>输出：<code>2</code></p>
<p>输入：<code>text = &quot;leetcode&quot;</code><br>输出：<code>0</code></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接计算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxNumberOfBalloons</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := strings.Split(text, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	b := <span class="number">0</span></span><br><span class="line">	a := <span class="number">0</span></span><br><span class="line">	l := <span class="number">0</span></span><br><span class="line">	o := <span class="number">0</span></span><br><span class="line">	n := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _,x := <span class="keyword">range</span> res&#123;</span><br><span class="line">		<span class="keyword">switch</span> x &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;b&quot;</span>:</span><br><span class="line">			b+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;a&quot;</span>:</span><br><span class="line">			a+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;l&quot;</span>:</span><br><span class="line">			l+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;o&quot;</span>:</span><br><span class="line">			o+=<span class="number">1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;n&quot;</span>:</span><br><span class="line">			n+=<span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	l=l/<span class="number">2</span></span><br><span class="line">	o=o/<span class="number">2</span></span><br><span class="line">	tmp:=b</span><br><span class="line">	<span class="keyword">if</span> a&lt;tmp&#123;</span><br><span class="line">		tmp=a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l&lt;tmp&#123;</span><br><span class="line">		tmp=l</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> o&lt;tmp&#123;</span><br><span class="line">		tmp=o</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n&lt;tmp&#123;</span><br><span class="line">		tmp=n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>21.合并两个有序链表</title>
    <url>/2019/07/04/leetcode/21/</url>
    <content><![CDATA[<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<a id="more"></a>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">nil</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res *ListNode</span><br><span class="line">    <span class="keyword">if</span> l1.Val &gt;= l2.Val&#123;</span><br><span class="line">        res = l2</span><br><span class="line">        res.Next = mergeTwoLists(l1,l2.Next)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res = l1</span><br><span class="line">        res.Next = mergeTwoLists(l1.Next,l2)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>226. 翻转二叉树</title>
    <url>/2019/07/04/leetcode/226/</url>
    <content><![CDATA[<p>翻转一棵二叉树。</p>
<a id="more"></a>

<p>示例：</p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>


<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">invertTree</span><span class="params">(root *TreeNode)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		tmpNode:=root.Left</span><br><span class="line">		root.Left=root.Right</span><br><span class="line">		root.Right=tmpNode</span><br><span class="line">		root.Left=invertTree(root.Left)</span><br><span class="line">		root.Right=invertTree(root.Right)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>26.删除排序数组中的重复项</title>
    <url>/2019/07/04/leetcode/26/</url>
    <content><![CDATA[<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	length := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> length == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		i   <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">		j   <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">		cnt <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; length &amp;&amp; j &lt; length) &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (i &lt; length &amp;&amp; j &lt; length &amp;&amp; nums[i] == nums[j]) &#123;</span><br><span class="line">					j++</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (j &lt; length &amp;&amp; i+<span class="number">1</span> &lt; length) &#123;</span><br><span class="line">				nums[i+<span class="number">1</span>] = nums[j];</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>14.最长公共前缀</title>
    <url>/2019/07/04/leetcode/14/</url>
    <content><![CDATA[<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串<code>&quot;&quot;</code>。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<p>所有输入只包含小写字母 <code>a-z</code> 。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs)==<span class="number">1</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(strs)&lt;<span class="number">1</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	defaultStr1 := strs[<span class="number">0</span>]</span><br><span class="line">	defaultStr2 := strs[<span class="number">1</span>]</span><br><span class="line">	strs = strs[<span class="number">2</span>:]</span><br><span class="line">	defaultStr:=getString(defaultStr1,defaultStr2)</span><br><span class="line">	<span class="keyword">for</span> _,value := <span class="keyword">range</span> strs&#123;</span><br><span class="line">		defaultStr=getString(defaultStr,<span class="keyword">string</span>(value))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> defaultStr</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getString</span><span class="params">(str1, str2 <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	result := <span class="string">&quot;&quot;</span></span><br><span class="line">	rune1:=[]<span class="keyword">rune</span>(str1)</span><br><span class="line">	rune2:=[]<span class="keyword">rune</span>(str2)</span><br><span class="line">	length1 := <span class="built_in">len</span>(rune1)</span><br><span class="line">	length2 := <span class="built_in">len</span>(rune2)</span><br><span class="line">	<span class="keyword">if</span> length1 &gt; length2 &#123;</span><br><span class="line">		<span class="keyword">for</span> count, value := <span class="keyword">range</span> str2 &#123;</span><br><span class="line">			<span class="keyword">if</span> rune1[count]==value&#123;</span><br><span class="line">				result+=<span class="keyword">string</span>(value)</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> count, value := <span class="keyword">range</span> str1 &#123;</span><br><span class="line">			<span class="keyword">if</span> rune2[count]==value&#123;</span><br><span class="line">				result+=<span class="keyword">string</span>(value)</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Django中内置的signal用法</title>
    <url>/2019/07/04/python/django_signal/</url>
    <content><![CDATA[<p>Django中提供了”信号调度”,用于在框架执行操作时解耦.</p>
<p>一些动作发生的时候,系统会根据信号定义的函数执行相应的操作</p>
<a id="more"></a>

<h1 id="Django中内置的signal"><a href="#Django中内置的signal" class="headerlink" title="Django中内置的signal"></a>Django中内置的signal</h1><h2 id="Model-signals"><a href="#Model-signals" class="headerlink" title="Model_signals"></a>Model_signals</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pre_init                        <span class="comment"># Django中的model对象执行其构造方法前,自动触发</span></span><br><span class="line">post_init                       <span class="comment"># Django中的model对象执行其构造方法后,自动触发</span></span><br><span class="line">pre_save                        <span class="comment"># Django中的model对象保存前,自动触发</span></span><br><span class="line">post_save                       <span class="comment"># Django中的model对象保存后,自动触发</span></span><br><span class="line">pre_delete                      <span class="comment"># Django中的model对象删除前,自动触发</span></span><br><span class="line">post_delete                     <span class="comment"># Django中的model对象删除后,自动触发</span></span><br><span class="line">m2m_changed                     <span class="comment"># Django中的model对象使用m2m字段操作数据库的第三张表(add,remove,clear,update),自动触发</span></span><br><span class="line">class_prepared                  <span class="comment"># 程序启动时,检测到已注册的model类,对于每一个类,自动触发</span></span><br></pre></td></tr></table></figure>

<h2 id="migrate-signals"><a href="#migrate-signals" class="headerlink" title="migrate_signals"></a>migrate_signals</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pre_migrate                     <span class="comment"># 执行migrate命令前,自动触发</span></span><br><span class="line">post_migrate                    <span class="comment"># 执行migrate命令后,自动触发 </span></span><br></pre></td></tr></table></figure>

<h2 id="Request-response-signals"><a href="#Request-response-signals" class="headerlink" title="Request/response_signals"></a>Request/response_signals</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request_started                 <span class="comment"># 请求到来前,自动触发</span></span><br><span class="line">request_finished                <span class="comment"># 请求结束后,自动触发</span></span><br><span class="line">got_request_exception           <span class="comment"># 请求异常时,自动触发</span></span><br></pre></td></tr></table></figure>

<h2 id="Test-signals"><a href="#Test-signals" class="headerlink" title="Test_signals"></a>Test_signals</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setting_changed                 <span class="comment"># 配置文件改变时,自动触发</span></span><br><span class="line">template_rendered               <span class="comment"># 模板执行渲染操作时,自动触发</span></span><br></pre></td></tr></table></figure>

<h2 id="Datebase-Wrapperd"><a href="#Datebase-Wrapperd" class="headerlink" title="Datebase_Wrapperd"></a>Datebase_Wrapperd</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">connection_created              <span class="comment"># 创建数据库连接时,自动触发</span></span><br></pre></td></tr></table></figure>

<h1 id="对于Django内置的信号-仅需注册指定信号-当程序执行相应操作时-系统会自动触发注册函数"><a href="#对于Django内置的信号-仅需注册指定信号-当程序执行相应操作时-系统会自动触发注册函数" class="headerlink" title="对于Django内置的信号,仅需注册指定信号,当程序执行相应操作时,系统会自动触发注册函数"></a>对于Django内置的信号,仅需注册指定信号,当程序执行相应操作时,系统会自动触发注册函数</h1><p>在相应的应用(app)目录下的<code>__init__.py</code>文件中进行定义,(可以另外创建一个<code>.py</code>文件, 再在<code>__init__.py</code>文件导入该文件)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导包</span></span><br><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="comment"># 导入模型</span></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> MyModel</span><br><span class="line"><span class="comment"># django.db.models.signals.pre_save 在某个Model保存之前调用</span></span><br><span class="line"><span class="comment"># django.db.models.signals.post_save 在某个Model保存之后调用</span></span><br><span class="line"><span class="comment"># django.db.models.signals.pre_delete 在某个Model删除之前调用</span></span><br><span class="line"><span class="comment"># django.db.models.signals.post_delete 在某个Model删除之后调用</span></span><br><span class="line"><span class="comment"># django.core.signals.request_started 在建立Http请求时发送</span></span><br><span class="line"><span class="comment"># django.core.signals.request_finished 在关闭Http请求时发送</span></span><br></pre></td></tr></table></figure>

<p>创建函数,监听信号, 当信号触发时,进行函数的调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将函数进行注册,声明为回调函数, 第一个参数为信号类型, 如果声明sender , 那么接收器只会接收这个sender的信号, 这里声明为只接收MyModel模型的信号</span></span><br><span class="line"><span class="comment"># post_save 在某个Model保存之后调用, 对于每个唯一的dispatch_uid,接收器都只被信号调用一次</span></span><br><span class="line"><span class="meta">@receiver(post_save, sender=MyModel, dispatch_uid=&quot;my_unique_identifier&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_handler</span>(<span class="params">sender, instance, **kwargs</span>):</span> <span class="comment">#参数:**kwargs必须.第一个参数必须为sender, 当信号类型为 Model_signals, 接收到的第二个参数为模型对象.　　print(instance.name) # 可以直接使用这个模型实例对象进行操作</span></span><br><span class="line">　　print(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="默认的signals及其参数"><a href="#默认的signals及其参数" class="headerlink" title="默认的signals及其参数"></a>默认的signals及其参数</h1><h2 id="模型的（django-db-models-signal-py）"><a href="#模型的（django-db-models-signal-py）" class="headerlink" title="模型的（django/db/models/signal.py）"></a>模型的（django/db/models/signal.py）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> Signal</span><br><span class="line"> </span><br><span class="line">class_prepared = Signal(providing_args=[<span class="string">&quot;class&quot;</span>])</span><br><span class="line"> </span><br><span class="line">pre_init = Signal(providing_args=[<span class="string">&quot;instance&quot;</span>, <span class="string">&quot;args&quot;</span>, <span class="string">&quot;kwargs&quot;</span>], use_caching=<span class="literal">True</span>)</span><br><span class="line">post_init = Signal(providing_args=[<span class="string">&quot;instance&quot;</span>], use_caching=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">pre_save = Signal(providing_args=[<span class="string">&quot;instance&quot;</span>, <span class="string">&quot;raw&quot;</span>, <span class="string">&quot;using&quot;</span>, <span class="string">&quot;update_fields&quot;</span>],</span><br><span class="line">                 use_caching=<span class="literal">True</span>)</span><br><span class="line">post_save = Signal(providing_args=[<span class="string">&quot;instance&quot;</span>, <span class="string">&quot;raw&quot;</span>, <span class="string">&quot;created&quot;</span>, <span class="string">&quot;using&quot;</span>, <span class="string">&quot;update_fields&quot;</span>], use_caching=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">pre_delete = Signal(providing_args=[<span class="string">&quot;instance&quot;</span>, <span class="string">&quot;using&quot;</span>], use_caching=<span class="literal">True</span>)</span><br><span class="line">post_delete = Signal(providing_args=[<span class="string">&quot;instance&quot;</span>, <span class="string">&quot;using&quot;</span>], use_caching=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">pre_syncdb = Signal(providing_args=[<span class="string">&quot;app&quot;</span>, <span class="string">&quot;create_models&quot;</span>, <span class="string">&quot;verbosity&quot;</span>, <span class="string">&quot;interactive&quot;</span>, <span class="string">&quot;db&quot;</span>])</span><br><span class="line">post_syncdb = Signal(providing_args=[<span class="string">&quot;class&quot;</span>, <span class="string">&quot;app&quot;</span>, <span class="string">&quot;created_models&quot;</span>, <span class="string">&quot;verbosity&quot;</span>, <span class="string">&quot;interactive&quot;</span>, <span class="string">&quot;db&quot;</span>])</span><br><span class="line"> </span><br><span class="line">m2m_changed = Signal(providing_args=[<span class="string">&quot;action&quot;</span>, <span class="string">&quot;instance&quot;</span>, <span class="string">&quot;reverse&quot;</span>, <span class="string">&quot;model&quot;</span>, <span class="string">&quot;pk_set&quot;</span>, <span class="string">&quot;using&quot;</span>], use_caching=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="用户登录的-django-contrib-auth-signals-py"><a href="#用户登录的-django-contrib-auth-signals-py" class="headerlink" title="用户登录的(django/contrib/auth/signals.py)"></a>用户登录的(django/contrib/auth/signals.py)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> Signal</span><br><span class="line"> </span><br><span class="line">user_logged_in = Signal(providing_args=[<span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;user&#x27;</span>])</span><br><span class="line">user_login_failed = Signal(providing_args=[<span class="string">&#x27;credentials&#x27;</span>])</span><br><span class="line">user_logged_out = Signal(providing_args=[<span class="string">&#x27;request&#x27;</span>, <span class="string">&#x27;user&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="关于request请求的-django-core-signals-py"><a href="#关于request请求的-django-core-signals-py" class="headerlink" title="关于request请求的(django/core/signals.py)"></a>关于request请求的(django/core/signals.py)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> Signal</span><br><span class="line"> </span><br><span class="line">request_started = Signal()</span><br><span class="line">request_finished = Signal()</span><br><span class="line">got_request_exception = Signal(providing_args=[<span class="string">&quot;request&quot;</span>])</span><br></pre></td></tr></table></figure>

<h2 id="数据库连接的-django-db-backends-signals-py"><a href="#数据库连接的-django-db-backends-signals-py" class="headerlink" title="数据库连接的(django/db/backends/signals.py)"></a>数据库连接的(django/db/backends/signals.py)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> Signal</span><br><span class="line"> </span><br><span class="line">connection_created = Signal(providing_args=[<span class="string">&quot;connection&quot;</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python的生成器和迭代器</title>
    <url>/2019/07/04/python/iter/</url>
    <content><![CDATA[<h1 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h1><h2 id="可迭代对象-iterable"><a href="#可迭代对象-iterable" class="headerlink" title="可迭代对象(iterable)"></a>可迭代对象(iterable)</h2><p>很多容器（list、tuple、dict等）都是可迭代对象，此外还有更多的对象同样也是可迭代对象，比如处于打开状态的files，sockets等等。但凡是可以返回一个迭代器的对象都可称之为可迭代对象</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y &#x3D; iter(x)</span><br><span class="line">&gt;&gt;&gt; z &#x3D; iter(x)</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(z)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &#39;list&#39;&gt;</span><br><span class="line">&gt;&gt;&gt; type(y)</span><br><span class="line">&lt;class &#39;list_iterator&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>这里x是一个可迭代对象，可迭代对象和容器一样是一种通俗的叫法，并不是指某种具体的数据类型，list是可迭代对象，dict是可迭代对象，set也是可迭代对象。y和z是两个独立的迭代器，迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。迭代器有一种具体的迭代器类型，比如list_iterator，set_iterator。可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。</p>
<p><img src="/Users/yuzichen/blog/source/images/python/iterable-vs-iterator_1.png"></p>
<h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器(iterator)"></a>迭代器(iterator)</h2><p>那么什么迭代器呢？它是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了<strong>iter__和__next</strong>()（python2中实现next()）方法的对象都是迭代器，__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常，至于它们到底是如何实现的这并不重要。</p>
<p>所以，迭代器就是实现了工厂模式的对象，它在你每次你询问要下一个值的时候给你返回。有很多关于迭代器的例子，比如itertools函数返回的都是迭代器对象。</p>
<p>生成无限序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import count</span><br><span class="line">&gt;&gt;&gt; counter &#x3D; count(start&#x3D;13)</span><br><span class="line">&gt;&gt;&gt; next(counter)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; next(counter)</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<p>从一个有限序列中生成无限序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import cycle</span><br><span class="line">&gt;&gt;&gt; colors &#x3D; cycle([&#39;red&#39;, &#39;white&#39;, &#39;blue&#39;])</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&#39;red&#39;</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&#39;white&#39;</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&#39;blue&#39;</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line">&#39;red&#39;</span><br></pre></td></tr></table></figure>
<p>从无限的序列中生成有限序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import islice</span><br><span class="line">&gt;&gt;&gt; colors &#x3D; cycle([&#39;red&#39;, &#39;white&#39;, &#39;blue&#39;])  # infinite</span><br><span class="line">&gt;&gt;&gt; limited &#x3D; islice(colors, 0, 4)            # finite</span><br><span class="line">&gt;&gt;&gt; for x in limited:                         </span><br><span class="line">...     print(x)</span><br><span class="line">red</span><br><span class="line">white</span><br><span class="line">blue</span><br><span class="line">red</span><br></pre></td></tr></table></figure>

<p>为了更直观地感受迭代器内部的执行过程，我们自定义一个迭代器，以斐波那契数列为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Fib:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.prev &#x3D; 0</span><br><span class="line">        self.curr &#x3D; 1</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        value &#x3D; self.curr</span><br><span class="line">        self.curr +&#x3D; self.prev</span><br><span class="line">        self.prev &#x3D; value</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f &#x3D; Fib()</span><br><span class="line">&gt;&gt;&gt; list(islice(f, 0, 10))</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure>

<p>Fib既是一个可迭代对象（因为它实现了__iter__方法），又是一个迭代器（因为实现了__next__方法）。实例变量prev和curr用户维护迭代器内部的状态。每次调用next()方法的时候做两件事：</p>
<p>为下一次调用next()方法修改状态<br>为当前这次调用生成返回结果<br>迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。</p>
<h2 id="生成器-generator"><a href="#生成器-generator" class="headerlink" title="生成器(generator)"></a>生成器(generator)</h2><p>生成器算得上是Python语言中最吸引人的特性之一，生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写<strong>iter</strong>()和<strong>next</strong>()方法了，只需要一个yiled关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。用生成器来实现斐波那契数列的例子是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def fib():</span><br><span class="line">    prev, curr &#x3D; 0, 1</span><br><span class="line">    while True:</span><br><span class="line">        yield curr</span><br><span class="line">        prev, curr &#x3D; curr, curr + prev</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f &#x3D; fib()</span><br><span class="line">&gt;&gt;&gt; list(islice(f, 0, 10))</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure>
<p><code>fib</code>就是一个普通的python函数，它特殊的地方在于函数体中没有return关键字，函数的返回值是一个生成器对象。当执行<code>f=fib()</code>返回的是一个生成器对象，此时函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。</p>
<p>生成器在Python中是一个非常强大的编程结构，可以用更少地中间变量写流式代码，此外，相比其它容器对象它更能节省内存和CPU，当然它可以用更少的代码来实现相似的功能。现在就可以动手重构你的代码了，但凡看到类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def something():</span><br><span class="line">    result &#x3D; []</span><br><span class="line">    for ... in ...:</span><br><span class="line">        result.append(x)</span><br><span class="line">    return result</span><br></pre></td></tr></table></figure>

<p>都可以用生成器函数来替换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def iter_something():</span><br><span class="line">    for ... in ...:</span><br><span class="line">        yield x</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>容器是一系列元素的集合，str、list、set、dict、file、sockets对象都可以看作是容器，容器都可以被迭代（用在for，while等语句中），因此他们被称为可迭代对象。</li>
<li>可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。</li>
<li>迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__next__和__iter__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。</li>
<li>生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。</li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pip安装包报错及解决方案</title>
    <url>/2019/07/04/python/pip_error/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="Python-ldap-报错"><a href="#Python-ldap-报错" class="headerlink" title="Python-ldap 报错"></a>Python-ldap 报错</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install python-devel openldap-devel</span><br></pre></td></tr></table></figure>

<h4 id="flower-查看节点失败"><a href="#flower-查看节点失败" class="headerlink" title="flower 查看节点失败"></a>flower 查看节点失败</h4><p>因为tornado的新版本与flower的兼容性较低，不能查看节点信息<br><code>pip install tornado==4.5.2</code></p>
]]></content>
      <categories>
        <category>踩坑遇雷</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pip国内源</title>
    <url>/2019/07/04/python/pip_mirror/</url>
    <content><![CDATA[<a id="more"></a>

<h3 id="pip国内源"><a href="#pip国内源" class="headerlink" title="pip国内源"></a>pip国内源</h3><blockquote>
<p>阿里云 <a class="link"   href="https://mirrors.aliyun.com/pypi/simple/" >https://mirrors.aliyun.com/pypi/simple/<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>中国科技大学 <a class="link"   href="https://pypi.mirrors.ustc.edu.cn/simple/" >https://pypi.mirrors.ustc.edu.cn/simple/<i class="fas fa-external-link-alt"></i></a> </p>
</blockquote>
<blockquote>
<p>豆瓣(douban) <a class="link"   href="https://pypi.douban.com/simple/" >https://pypi.douban.com/simple/<i class="fas fa-external-link-alt"></i></a> </p>
</blockquote>
<blockquote>
<p>清华大学 <a class="link"   href="https://pypi.tuna.tsinghua.edu.cn/simple/" >https://pypi.tuna.tsinghua.edu.cn/simple/<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>中国科学技术大学 <a class="link"   href="http://pypi.mirrors.ustc.edu.cn/simple/" >http://pypi.mirrors.ustc.edu.cn/simple/<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h3 id="如果是使用conda来安装，-执行这两条命令，可以将国内镜像源加入config文件"><a href="#如果是使用conda来安装，-执行这两条命令，可以将国内镜像源加入config文件" class="headerlink" title="如果是使用conda来安装， 执行这两条命令，可以将国内镜像源加入config文件"></a>如果是使用conda来安装， 执行这两条命令，可以将国内镜像源加入config文件</h3><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><blockquote>
<p>conda config –add channels <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" >https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<blockquote>
<p>conda config –set show_channel_urls yes</p>
</blockquote>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><blockquote>
<p>conda config –get channels </p>
</blockquote>
<blockquote>
<p>conda config –add channels <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/" >https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python的可变参数</title>
    <url>/2019/07/04/python/python_arg/</url>
    <content><![CDATA[<h1 id="python-的可变参数"><a href="#python-的可变参数" class="headerlink" title="python 的可变参数"></a>python 的可变参数</h1><p>在python中，通过<code>*</code>和<code>**</code>接收可变参数，分别表示 <code>tuple</code> 和<code>dict</code>，获取到值如果想以原参数传回 指定函数，也需要加上<code>*</code>和<code>**</code></p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">    print(args)</span><br><span class="line">    print(type(args))</span><br><span class="line">    print(kwargs)</span><br><span class="line">    print(type(kwargs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=(<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>)</span><br><span class="line">b=&#123;<span class="string">&quot;q&quot;</span>:<span class="number">1</span>&#125;</span><br><span class="line">test(a,b)</span><br><span class="line"><span class="comment">#((7, 7, 7), &#123;&#x27;q&#x27;: 1&#125;)</span></span><br><span class="line"><span class="comment">#&lt;type &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="comment">#&#123;&#125;</span></span><br><span class="line"><span class="comment">#&lt;type &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">test(*a,**b)</span><br><span class="line"><span class="comment">#(7, 7, 7)</span></span><br><span class="line"><span class="comment">#&lt;type &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="comment">#&#123;&#x27;q&#x27;: 1&#125;</span></span><br><span class="line"><span class="comment">#&lt;type &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python 的垃圾回收机制</title>
    <url>/2019/07/04/python/python_gc/</url>
    <content><![CDATA[<h1 id="python-的垃圾回收机制"><a href="#python-的垃圾回收机制" class="headerlink" title="python 的垃圾回收机制"></a>python 的垃圾回收机制</h1><a id="more"></a>

<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><h5 id="PyObject"><a href="#PyObject" class="headerlink" title="PyObject"></a>PyObject</h5><p>python里每一个东西都是对象，它们的核心就是一个结构体：PyObject</p>
<p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少</p>
<h5 id="引用计数的优缺点"><a href="#引用计数的优缺点" class="headerlink" title="引用计数的优缺点"></a>引用计数的优缺点</h5><blockquote>
<p>优点：<br>简单实时,一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。</p>
</blockquote>
<blockquote>
<p>缺点：<br>维护引用计数消耗资源,会造成循环引用导致无法回收,造成内存泄露</p>
</blockquote>
<h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1=[]</span><br><span class="line">list2=[]</span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br><span class="line"><span class="comment"># list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。</span></span><br></pre></td></tr></table></figure>

<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记-清除机制，顾名思义，首先标记对象（垃圾检测），然后清除垃圾（垃圾回收)<br><img src="/images/python/gc_1.png" alt="gc_1"></p>
<p>首先初始所有对象标记为白色，并确定根节点对象（这些对象是不会被删除），标记它们为黑色（表示对象有效）。</p>
<p>将有效对象引用的对象标记为灰色（表示对象可达，但它们所引用的对象还没检查），检查完灰色对象引用的对象后，将灰色标记为黑色。</p>
<p>重复直到不存在灰色节点为止。最后白色结点都是需要清除的对象。</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>分代技术是一种典型的以空间换时间的技术，这也正是java里的关键技术。这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。</p>
<p>这样的思想，可以减少标记-清除机制所带来的额外操作。分代就是将回收对象分成数个代，每个代就是一个链表（集合），代进行标记-清除的时间与代内对象</p>
<p>存活时间成正比例关系。</p>
<p>从上面代码可以看出python里一共有三代，每个代的threshold值表示该代最多容纳对象的个数。默认情况下，当0代超过700,或1，2代超过10，垃圾回收机制将触发。</p>
<p>0代触发将清理所有三代，1代触发会清理1,2代，2代触发后只会清理自己。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>27.移除元素</title>
    <url>/2019/07/04/leetcode/27/</url>
    <content><![CDATA[<p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [3,2,2,3], val &#x3D; 3,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span><br><span class="line">int len &#x3D; removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> num,rangeVal :=<span class="keyword">range</span> nums&#123;</span><br><span class="line">		<span class="keyword">if</span> val==rangeVal&#123;</span><br><span class="line">			res=<span class="built_in">append</span>(res,num)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	count:=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _,val :=<span class="keyword">range</span> res&#123;</span><br><span class="line">		nums = delList(nums,val-count)</span><br><span class="line">		count++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delList</span><span class="params">(nums []<span class="keyword">int</span>, index <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	length:=<span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> index&lt;length&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">append</span>(nums[:index], nums[index+<span class="number">1</span>:]...)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> nums[:index]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>28.实现 strStr()</title>
    <url>/2019/07/04/leetcode/28/</url>
    <content><![CDATA[<p>实现 <code>strStr()</code> 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: str, needle: str</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> needle <span class="keyword">not</span> <span class="keyword">in</span> haystack:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> haystack.index(needle)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>python的多线程数量控制</title>
    <url>/2019/07/04/python/python_thread_count/</url>
    <content><![CDATA[<p>python多线程如果不进行并发数量控制，在启动线程数量多到一定程度后，会造成线程无法启动的错误。</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写 python 的多线程类，使之与queue队列相结合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, queue, **kwargs</span>):</span></span><br><span class="line">        threading.Thread.__init__(self, **kwargs)</span><br><span class="line">        self.queue = queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        super(Thread, self).run()</span><br><span class="line">        self.queue.get()</span><br><span class="line">        self.queue.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(x)</span><br><span class="line">    time.sleep(x)</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    q = Queue.Queue(<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        q.put(i)</span><br><span class="line">        Thread(queue=q, target=test, args=(i,)).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>35.搜索插入位置</title>
    <url>/2019/07/04/leetcode/35/</url>
    <content><![CDATA[<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p>示例 4:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> low <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> high <span class="keyword">int</span> = <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">for</span> low&lt;high&#123;</span><br><span class="line">		<span class="keyword">var</span> mid <span class="keyword">int</span> = low + (high - low)/<span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &gt; target&#123;</span><br><span class="line">			high = mid</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target&#123;</span><br><span class="line">			low = mid +<span class="number">1</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>118. 杨辉三角</title>
    <url>/2019/07/04/leetcode/118/</url>
    <content><![CDATA[<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<a id="more"></a>

<p><img src="/images/leetcode/118.gif" alt="118"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">(numRows <span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">    	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numRows; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> tmp []<span class="keyword">int</span></span><br><span class="line">		number := <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= i; j++ &#123;</span><br><span class="line">			tmp = <span class="built_in">append</span>(tmp, number)</span><br><span class="line">			number = number * (i - j) / (j + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		result = <span class="built_in">append</span>(result, tmp)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>21.合并两个有序链表</title>
    <url>/2019/07/04/leetcode/108/</url>
    <content><![CDATA[<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<a id="more"></a>

<p>示例:</p>
<p>给定有序数组:<code> [-10,-3,0,5,9]</code>,</p>
<p>一个可能的答案是：<code>[0,-3,9,-10,null,5]</code>，它可以表示下面这个高度平衡二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     0</span><br><span class="line">    &#x2F; \</span><br><span class="line">  -3   9</span><br><span class="line">  &#x2F;   &#x2F;</span><br><span class="line">-10  5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortedArrayToBST</span><span class="params">(nums []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		mid:=<span class="built_in">len</span>(nums)/<span class="number">2</span></span><br><span class="line">		tn:=TreeNode&#123;Val:nums[mid]&#125;</span><br><span class="line">		nums1:=nums[<span class="number">0</span>:mid]</span><br><span class="line">		nums2:=nums[mid+<span class="number">1</span>:<span class="built_in">len</span>(nums)]</span><br><span class="line">		tn.Left = sortedArrayToBST(nums1)</span><br><span class="line">		tn.Right = sortedArrayToBST(nums2)</span><br><span class="line">		<span class="keyword">return</span> &amp;tn</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1078. Bigram 分词</title>
    <url>/2019/07/04/leetcode/1078/</url>
    <content><![CDATA[<p>给出第一个词 <code>first</code> 和第二个词<code>second</code>，考虑在某些文本 text 中可能以<code> &quot;first second third&quot;</code> 形式出现的情况，其中 <code>second</code> 紧随 <code>first</code> 出现，<code>third</code> 紧随 <code>second</code> 出现。</p>
<a id="more"></a>

<p>对于每种这样的情况，将第三个词 “third” 添加到答案中，并返回答案。</p>
<p>示例1：<br>输入：<code>text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;</code><br>输出：<code>[&quot;girl&quot;,&quot;student&quot;]</code></p>
<p>示例2：<br>输入：<code>text = &quot;we will we will rock you&quot;, first = &quot;we&quot;, second = &quot;will&quot;</code><br>输出：<code>[&quot;we&quot;,&quot;rock&quot;]</code></p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findOcurrences</span><span class="params">(text <span class="keyword">string</span>, first <span class="keyword">string</span>, second <span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	sli := strings.Split(text, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> ret []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(sli) - <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> sli[i] == first &amp;&amp; sli[i+<span class="number">1</span>] == second &#123;</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, sli[i+<span class="number">2</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>107. 二叉树的层次遍历 II</title>
    <url>/2019/07/04/leetcode/107/</url>
    <content><![CDATA[<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<a id="more"></a>

<p>例如：<br>给定二叉树<code> [3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回其自底向上的层次遍历为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrderBottom</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result [][]<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> treeNode = []*TreeNode&#123;root&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> treeNode == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> newTreeNode []*TreeNode</span><br><span class="line">		<span class="keyword">var</span> val []<span class="keyword">int</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(treeNode); i++ &#123;</span><br><span class="line">			tree := treeNode[i]</span><br><span class="line">			val = <span class="built_in">append</span>(val, tree.Val)</span><br><span class="line">			<span class="keyword">if</span> tree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				newTreeNode = <span class="built_in">append</span>(newTreeNode, tree.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> tree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				newTreeNode = <span class="built_in">append</span>(newTreeNode, tree.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		result = <span class="built_in">append</span>([][]<span class="keyword">int</span>&#123;val&#125;,result...)</span><br><span class="line">		treeNode = newTreeNode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1053.交换一次的先前排列</title>
    <url>/2019/07/04/leetcode/1053/</url>
    <content><![CDATA[<p>给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。</p>
<p>如果无法这么操作，就请返回原数组。</p>
<a id="more"></a>

<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,2,1]</span><br><span class="line">输出：[3,1,2]</span><br><span class="line">解释：</span><br><span class="line">交换 2 和 1</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,5]</span><br><span class="line">输出：[1,1,5]</span><br><span class="line">解释： </span><br><span class="line">这已经是最小排列</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,9,4,6,7]</span><br><span class="line">输出：[1,7,4,6,9]</span><br><span class="line">解释：</span><br><span class="line">交换 9 和 7</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[3,1,1,3]</span><br><span class="line">输出：[1,3,1,3]</span><br><span class="line">解释：</span><br><span class="line">交换 1 和 3</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; A.length &lt;&#x3D; 10000</span><br><span class="line">1 &lt;&#x3D; A[i] &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>



<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prevPermOpt1</span><span class="params">(A []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(A) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> A</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(A) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> A[i] &gt;= A[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			max := <span class="number">0</span></span><br><span class="line">			k := <span class="number">0</span></span><br><span class="line">			<span class="keyword">for</span> j := i; j &lt; <span class="built_in">len</span>(A); j++ &#123;</span><br><span class="line">				<span class="keyword">if</span> A[j] &gt; max &amp;&amp; A[j] &lt; A[i<span class="number">-1</span>] &#123;</span><br><span class="line">					max = A[j]</span><br><span class="line">					k = j</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			A[i<span class="number">-1</span>],A[k]=A[k],A[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> A</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>104. 二叉树的最大深度</title>
    <url>/2019/07/04/leetcode/104/</url>
    <content><![CDATA[<p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<a id="more"></a>

<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>+max(maxDepth(root.Left),maxDepth(root.Right))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>101. 对称二叉树</title>
    <url>/2019/07/04/leetcode/101/</url>
    <content><![CDATA[<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<a id="more"></a>

<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   2</span><br><span class="line"> &#x2F; \ &#x2F; \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> &#x2F; \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p>如果你可以运用递归和迭代两种方法解决这个问题，会很加分。</p>
<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> check(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(root1, root2 *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root1 == <span class="literal">nil</span> &amp;&amp; root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> root1 == <span class="literal">nil</span> || root2 == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root1.Val != root2.Val &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> check(root1.Left, root2.Right) &amp;&amp; check(root1.Right, root2.Left)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>100. 相同的树</title>
    <url>/2019/07/04/leetcode/100/</url>
    <content><![CDATA[<p>给定两个二叉树，编写一个函数来检验它们是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:      1          1</span><br><span class="line">          &#x2F;           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:       1         1</span><br><span class="line">          &#x2F; \       &#x2F; \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSameTree</span><span class="params">(p *TreeNode, q *TreeNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> p == <span class="literal">nil</span> &amp;&amp; q == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; q != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p.Val == q.Val &#123;</span><br><span class="line">			<span class="keyword">return</span> isSameTree(p.Left, q.Left) &amp;&amp; isSameTree(q.Right, p.Right)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1.两数之和</title>
    <url>/2019/07/04/leetcode/1/</url>
    <content><![CDATA[<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<a id="more"></a>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sumSlice []<span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">for</span> m, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			<span class="keyword">if</span> i &lt; m &#123;</span><br><span class="line">				<span class="keyword">if</span> j+n == target &#123;</span><br><span class="line"></span><br><span class="line">					sumSlice = <span class="built_in">append</span>(sumSlice, i, m)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sumSlice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Go高质量代码</title>
    <url>/2019/07/04/golang/high_performance/</url>
    <content><![CDATA[<h1 id="编写和优化Go代码"><a href="#编写和优化Go代码" class="headerlink" title="编写和优化Go代码"></a>编写和优化Go代码</h1><p>本文档概述了编写高性能Go代码的最佳实践。</p>
<p>虽然有些讨论会提高单个服务的速度（通过缓存等），但设计高性能的分布式系统已经超出了这项工作的范围。在监控和分布式系统设计方面已经有很好的文章，它包含了一套完全不同的研究和设计权衡理论。</p>
<p>所有内容将根据CC-BY-SA进行许可。</p>
<a id="more"></a>

<p>我们可以总结这三个部分:</p>
<ul>
<li>“合理的”</li>
<li>“慎重的”</li>
<li>“危险的”</li>
</ul>
<h3 id="何时何地做优化"><a href="#何时何地做优化" class="headerlink" title="何时何地做优化"></a>何时何地做优化</h3><p>我先把这个放在第一位，是因为这真的是最重要的一步。你曾经也应该这样做吗？</p>
<p>每个优化都有成本。通常，这个成本是用代码复杂度或认知负载来表示的 - 优化后的代码很少比未优化的版本简单。</p>
<p>但另一方面，我将称之为“优化经济学”。作为程序员，你的时间是宝贵的。你可以为你的项目工作的机会成本，哪些错误需要修复，以及需要添加哪些功能。优化的工作是很有趣的，但并不总是正确的选择。性能是一项功能，但代价和正确性也是如此。</p>
<p>选择最重要的工作。有时它不是一个实际的CPU优化，而是一个用户体验。就像添加进度条一样简单，或者通过在渲染页面后在后台执行计算来提高页面的响应速度。</p>
<p>有时这是显而易见的:在三小时内完成的报告在一小时完成可能不太有用。</p>
<p>仅仅因为容易优化并不意味着它是值得优化的。忽略low-hang的效果是一种有效的发展战略。</p>
<p>把这看作是优化<em>你的</em>时间。</p>
<p>选择要优化的内容以及何时优化，你可以在“软件质量”和“开发速度”之间移动滑块。</p>
<p>人们无意识地重复说名言——“过早的优化是万恶之源”，但他们错过了它的主要内容。</p>
<p>“程序员浪费了大量的时间来思考或者担心程序中非关键部分的速度，而这些效率的尝试实际上在考虑调试和维护时会产生很大的负面影响。我们应该忘记为了小的性能使用的97％的时间：过早的优化是万恶之源，但我们不应该在这个关键的3％中放弃我们的优化机会。“ - Knuth</p>
<p>附：https : //<a class="link"   href="http://www.youtube.com/watch?time_continue=429&amp;v=RT46MpK39rQ" >www.youtube.com/watch?time_continue=429&amp;v=RT46MpK39rQ<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>不要忽视简单的优化</li>
<li>更多的算法和数据结构知识使得更多的优化变得“容易”或“明显”</li>
</ul>
<p>“你应该优化吗？”是的，但是只有当问题很重要时，程序真的太慢了​​，并且能够在保证正确性，稳健性和清晰度的同时变得更快。“ - 编程实践，Kernighan and Pike</p>
<p><a class="link"   href="http://bitfunnel.org/strangeloop" >BitFunnel性能评估<i class="fas fa-external-link-alt"></i></a> 有一些数字可以使这种权衡更加明确。想象一下假设搜索引擎需要跨越多个数据中心的30,000台机器，这些机器每年的成本约为1,000美元。如果你可以将软件的速度提高一倍，这可以为公司节省每年1500万美元。即使只有一个开发人员花费整整一年时间才能将性能提高也只会付出1％的代价。</p>
<p>在绝大多数情况下，程序的大小和速度不是问题。最简单的优化不必这样做。第二个最简单的优化就是购买更快的硬件。</p>
<p>如果你决定要改变你的程序，请继续阅读。</p>
<h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><h3 id="优化工作流程"><a href="#优化工作流程" class="headerlink" title="优化工作流程"></a>优化工作流程</h3><p>在介绍具体细节之前，我们先谈谈优化的一般过程。</p>
<p>优化是一种重构形式。但是，每一步不是改进源代码的某些方面（代码重复，清晰度等），而是可以提高性能的某些方面：降低CPU，内存使用率，延迟等。这种改进通常以可读性为代价。这意味着除了一套全面的单元测试（以确保你的更改没有破坏任何内容）之外，你还需要一套很好的基准测试，以确保您的更改对性能产生预期的影响。你必须能够验证您的更改是否真的在降低CPU。有时候你认为会改善性能的变化实际上会变成零或负变化。在这些情况下，务必确保撤消修改的程序。</p>
<p><cite><a class="link"   href="https://stackoverflow.com/questions/184618/what-is-the-best-comment-in-source-code-you-have-ever-encountered" >源代码中遇到过的最好的评论是什么？- Stack Overflow<i class="fas fa-external-link-alt"></i></a></cite></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//亲爱的维护者:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//当你完成试图“优化”这个程序，</span></span><br><span class="line"><span class="comment">//并且已经意识到了什么可怕的错误时，</span></span><br><span class="line"><span class="comment">//请增加以下计数器作为给后人的警告：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//total_hours_wasted_here = 42</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>你使用的基准测试必须正确，并为代表性工作负载提供可重复的数字。如果单个的运行差异太大，则会使得小的改进更难以发现。你将需要使用<a class="link"   href="https://golang.org/x/perf/benchstat" >benchstat<i class="fas fa-external-link-alt"></i></a>或等效的统计测试，而不能只是用眼睛去看(请注意，使用统计测试无论如何都是一个好主意)。应该记录运行基准测试的步骤，并且应该向存储库提交任何自定义脚本和工具，并提供如何运行它们的说明。要注意需要很长时间才能运行的大型基准测试套件:它会使开发迭代变慢。</p>
<p>还要注意，任何可以测量的东西都可以优化。确保你正在衡量正确的事情。</p>
<p>下一步是决定你正在优化什么。如果目标是改进CPU，那么什么是可接受的速度。你想要将当前的性能提高2倍吗？10倍？你能否说它是“小于时间T的大小为N的问题”？你想减少内存使用量吗？多少钱？对于内存使用情况的变化，可以接受的速度有多慢？你愿意放弃什么来换取较低的空间需求？</p>
<p>优化服务延迟是一个棘手的问题。整本书都是关于如何对Web服务器进行性能测试的。主要问题是：对于单个函数，对于给定的问题规模，性能相当一致。对于webservices，你没有一个单一的性能数字。一个适当的Web服务基准套件将为给定的需求/秒级别提供延迟分布。这篇演讲很好地概述了Gil Tene的一些问题：<a class="link"   href="https://youtu.be/lJ8ydIuPFeU" >“如何不去测量延迟” by Gil Tene<i class="fas fa-external-link-alt"></i></a></p>
<p>TODO：请参阅后面的关于优化Web服务的部分</p>
<p>绩效目标必须具体。你会（几乎）总是能够更快地做出一些事情。优化往往是一个收益递减的游戏。你需要知道何时停止。你要付出多少努力才能完成最后一点工作。你愿意做出这样的代码是多么难以维护？</p>
<p>Dan Luu之前提到的<a class="link"   href="http://bitfunnel.org/strangeloop" >BitFunnel性能评估<i class="fas fa-external-link-alt"></i></a>的演讲显示了一个使用粗略计算来确定目标性能数据是否合理的例子。</p>
<p>TODO：编程珠玑有“Fermi Problems”。从Jeff Dean’s 幻灯片可以了解</p>
<p>对于绿地开发，你不应该把所有的基准和性能数字都留到最后。很容易说“我们稍后会修复”，但如果性能非常重要，那么从一开始就将是一个设计考虑因素。在解决性能问题时所需的任何重大体系结构更改在截止日期前将过于冒险。请注意，在开发过程中，重点应放在合理的程序设计，算​​法和数据结构上。在更低层次的堆栈优化应该等到开发周期晚些时候才能获得更完整的系统性能视图。你在系统不完整时执行的任何完整系统配置文件都会对完成系统中瓶颈的位置给出偏斜视图。</p>
<p>TODO：如何避免/发现软件写得不好的情况下的“凌迟”。</p>
<p>作为CI的一部分，基准测试是很难的，因为嘈杂的因素，甚至不同的CI盒子，那么很难获取性能指标。一个好的基础是让开发人员运行基准测试（在适当的硬件上）并将其包含在提交消息中，专门用于处理性能问题。对于那些只是提普通补丁的人来说，尽量在代码审查中捕捉性能下降。</p>
<p>TODO：如何跟踪一段时间的性能表现？</p>
<p>编写你可以测试的代码。你可以在较大的系统上执行分析。你可以通过基准测试测试孤立的部分。你需要能够提取并设置足够的环境上下文，以便基准测试足够并具有代表性。</p>
<p>你的目标是什么和目前的表现之间的差异也会让你知道从哪里开始。如果你只需要10％-20％的性能改进，那么可以通过一些实施调整和较小的修复来实现。如果你需要一个10倍或更多的因子，那么用一个左移代替一个乘法不会削减它。这可能会要求你的堆栈上下进行更改。</p>
<p>良好的性能工作需要从系统设计，网络，硬件(CPU，缓存，存储)，算法，调整和调试等多个不同层面的知识。在时间和资源有限的情况下，考虑哪个级别能够提供最大的改进:它并不总是算法或程序调优。</p>
<p>一般而言，优化应该从上到下进行。系统级别的优化将比表达级别的影响更大。确保你在适当的水平上解决问题。</p>
<p>本书主要讨论如何减少CPU使用率，减少内存使用量并减少延迟。很高兴指出你很少能做到这三点。也许CPU时间更快，但现在你的程序使用更多的内存。也许你需要减少内存空间，但现在该程序需要更长的时间。</p>
<p><a class="link"   href="https://en.wikipedia.org/wiki/Amdahl%27s_law" >阿姆达尔定律<i class="fas fa-external-link-alt"></i></a>告诉我们要关注瓶颈。如果你将运行时间仅占5％的例程速度提高一倍，那么整个挂钟的速度只有2.5％。另一方面，将80％的时间加速10％的例程将使运行时间提高近8％。配置文件将有助于确定实际花费的时间。</p>
<p>优化时，你想减少CPU必须完成的工作量。Quicksort比气泡排序更快，因为它能以更少的步骤解决相同的问题(排序)。这是一个更高效的算法。你已经减少了CPU完成相同任务所需完成的工作。</p>
<p>像编译器优化一样，程序调优通常只会在整个运行时间中造成一点小小的负担。大的胜利几乎总是来自算法改变或数据结构的改变，这是你的程序组织方式的根本转变。编译器技术有所改进，但速度很慢。Proebsting定律表明，编译器每18 年的性能翻倍，这与摩尔定律(稍微误解了解释)形成鲜明对比，该定律使处理器性能每18 个月翻一番。算法改进在更大的范围内工作。从1991年到2008年，混合器整数规划算法提高了30,000倍 有关更具体的示例，请考虑<a class="link"   href="https://medium.com/@buckhx/unwinding-uber-s-most-efficient-service-406413c5871d" >此故障<i class="fas fa-external-link-alt"></i></a>取代优步博客文章中描述的蛮力地理空间算法，使用更适合于所提交任务的更专业的算法。没有编译器开关可以提供相同的性能提升。</p>
<p>TODO：在gttse07.pdf中优化浮点FFT和MMM算法的差异</p>
<p>分析器可能会告诉你，大量的时间都花在了特定的例程上。这可能是一个昂贵的例程，或者它可能是一个便宜的例程，只是被调用许多次。你可以先看看是否可以减少调用的次数或完全不调用，而不是立即尝试优化这个例程。我们将在下一节讨论更具体的优化策略。</p>
<p>三个优化问题:</p>
<ul>
<li>我们必须这样做吗？最快的代码是永远不会运行的代码。</li>
<li>如果是的话，这是最好的算法。</li>
<li>如果是的话，这是这个算法的最佳实现。</li>
</ul>
<h2 id="具体的优化技巧"><a href="#具体的优化技巧" class="headerlink" title="具体的优化技巧"></a>具体的优化技巧</h2><p>Jon Bentley在1982年的作品“编写高效程序”将程序优化视为一个工程问题:基准。分析。提高。校验。迭代。他的一些技巧现在由编译器自动完成。程序员的工作是使用编译器无法做到的转换。</p>
<p>本书的摘要如下:</p>
<ul>
<li><a class="link"   href="http://www.crowl.org/lawrence/programming/Bentley82.html" >http://www.crowl.org/lawrence/programming/Bentley82.html<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="http://www.geoffprewett.com/BookReviews/WritingEfficientPrograms.html" >http://www.geoffprewett.com/BookReviews/WritingEfficientPrograms.html<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>和程序调整规则:<br><a class="link"   href="https://web.archive.org/web/20080513070949/http://www.cs.bell-labs.com/cm/cs/pearls/apprules.html" >https://web.archive.org/web/20080513070949/http://www.cs.bell-labs.com/cm/cs/pearls/apprules.html<i class="fas fa-external-link-alt"></i></a></p>
<p>在考虑对程序进行更改时，有两个基本选项:你可以更改数据，也可以更改代码。</p>
<h3 id="数据的更改"><a href="#数据的更改" class="headerlink" title="数据的更改"></a>数据的更改</h3><p>改变你的数据意味着增加或改变你正在处理的数据的表示。从性能角度来看，其中一些最终会改变与数据结构的不同方面相关的O()。</p>
<p>增加数据结构的想法:</p>
<ul>
<li><p>额外字段:例如，存储链接列表的大小，而不是在询问时迭代。或者将经常需要的其他节点的指针存储到多个搜索中(例如，双向链接列表中的“向后”链接以进行删除O(1))。当你需要的数据便于存储并保持最新时，这些更改很有用。</p>
</li>
<li><p>额外的搜索索引:大多数数据结构都是为单一类型的查询而设计的。如果你需要两种不同的查询类型，对数据进行额外的“查看”可能会有很大的改进。例如，[] struct，由ID引用，但有时是string - &gt; map [string] id(或* struct)</p>
</li>
<li><p>有关元素的额外信息:例如布隆过滤器。这些数据结构必须小而快，以免压倒其余的数据结构。</p>
</li>
<li><p>如果查询很昂贵，请添加一个缓存。我们都熟悉memcache，但还有进程内缓存。</p>
</li>
</ul>
<ul>
<li>通过网络，网络+序列化成本将会受到影响</li>
<li>进程内缓存，但现在你需要担心到期</li>
<li>即使是单个项目也可以帮助(日志文件时间解析示例)</li>
</ul>
<p>TODO:“缓存”可能不是键值对，只是指向你工作的地方。这可以像“搜索手指”一样简单</p>
<p>这些都是数据结构层面“做更少工作”的明确例子。他们都花费空间。大多数情况下，如果你针对CPU进行优化，程序将使用更多的内存。这是经典的<a class="link"   href="https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff" >时空交易<i class="fas fa-external-link-alt"></i></a></p>
<p>如果你的程序使用太多的内存，也可以换个方式。减少空间使用量以换取更多计算。而不是存储的东西，每次计算它们。你还可以压缩内存中的数据，并在需要时随时对其进行解压缩。</p>
<p><a class="link"   href="https://gamehacking.org/faqs/Small_Memory_Software.pdf" >小内存软件<i class="fas fa-external-link-alt"></i></a>是一本网上可获取的书籍，涵盖了减少程序使用内存空间的技术。虽然它最初是针对嵌入式开发人员编写的，但这些想法适用于处理大量数据的现代硬件的程序。</p>
<ul>
<li><p>重新排列你的数据<br>  消除结构填充。删除额外的字段。使用较小的数据类型</p>
</li>
<li><p>更改为较慢的数据结构<br>  较简单的数据结构通常具有较低的内存要求。例如，从一个指针重的树结构转向使用切片和线性搜索。</p>
</li>
<li><p>为你的数据定制压缩格式<br>  []字节（snappy，gzip，lz4），浮点数（go-tsz），整数（delta，xor + huffman）大量的压缩资源。你需要检查数据还是可以保持压缩？你需要随机访问还是只有流媒体？压缩具有额外索引的块。如果不是在进程中，而是写入磁盘，那么迁移或添加/删除字段呢？你现在正在处理raw []字节而不是很好的结构化Go类型。</p>
</li>
</ul>
<p>我们稍后会详细讨论数据布局。</p>
<p>现代计算机和存储器层次结构使空间/时间的权衡不太明确。查找表很容易在内存中“远离”(因此访问成本很高)，使得每次需要时重新计算一次值都会更快。</p>
<p>这也意味着基准测试通常会显示由于缓存争用而导致生产系统无法实现的改进(例如，查找表在基准测试期间位于处理器缓存中，但在真实系统中使用时总是会被“真实数据”冲刷。哈希表实际上直接解决了这个问题，比较了满足和无约束的处理器缓存上的性能。参见<a class="link"   href="https://arxiv.org/pdf/1406.2294.pdf" >Jump Hash paper<i class="fas fa-external-link-alt"></i></a>论文中的图4和图5。</p>
<p>TODO:如何模拟满足的缓存，显示增量成本</p>
<p>另一个要考虑的方面是数据传输时间。通常，网络和磁盘访问非常缓慢，因此能够加载压缩块的速度将比获取数据后解压缩数据所需的额外CPU时间快得多。一如既往，基准。二进制格式通常比文本格式更小且更快解析，但代价是不再是人类可读的格式。</p>
<p>对于数据传输，转移到一个不那么有趣的协议，或者增加API以允许部分查询。例如，增量查询而不是每次都被迫获取整个数据集。</p>
<h2 id="算法的更改"><a href="#算法的更改" class="headerlink" title="算法的更改"></a>算法的更改</h2><p>如果你不更改数据，另一个主要选项是更改代码。</p>
<p>最大的改进很可能来自算法变化。这与使用快速排序将气泡排序替换为从O(n ^ 2)排序到O(n log n)或使用映射查找替换通过过去是小O(n)的数组的线性扫描等效(O (1))。</p>
<p>最大的改进可能来自算法变化。这相当于用quicksort（O(nlogn)）替换O(n^2)的冒泡排序或者通过哈希查找（O(1)）替换数组（O(n)）的线性扫描。</p>
<p>这就是软件如何变慢。最初设计用于一种用途的结构被重新用于未设计的东西。这是逐渐发生的。</p>
<p>直观地掌握不同的大O级别是很重要的。为你的问题选择正确的数据结构。你不必一直刮刮胡须，但是这样做可以防止很久以后才会发现的愚蠢的性能问题。</p>
<p>基本的复杂类别是:</p>
<ul>
<li><p>O（1）：字段访问，数组或地图查找<br>建议：不要担心</p>
</li>
<li><p>O（log n）：二进制搜索<br>建议：如果处于循环状态，则只是一个问题</p>
</li>
<li><p>O（n）：简单循环<br>建议：你一直在这样做</p>
</li>
<li><p>O（n log n）：分而治之，排序<br>建议：还是相当快的</p>
</li>
<li><p>O（n * m）：嵌套循环/二次方<br>建议：小心并限制你的大小</p>
</li>
<li><p>二次和次指数之间的任何其他内容<br>建议：不要在一百万行上运行</p>
</li>
<li><p>O（b ^ n），O（n！）：指数上升<br>建议：如果你有十几个或两个数据点，祝您好运</p>
</li>
</ul>
<p>链接:<a class="link"   href="http://bigocheatsheet.com/" >http://bigocheatsheet.com<i class="fas fa-external-link-alt"></i></a></p>
<p>假设你需要搜索未分类的数据集。“我应该用二分搜索”，你知道一个二分搜索O(log n)比O(n)线性扫描快。但是，二分查找需要对数据进行排序，这意味着你需要先对它进行排序，这将花费O(n log n)时间。如果你正在进行大量搜索，那么分类的前期成本将会得到回报。另一方面，如果你主要做查询，也许有一个数组是错误的选择，你最好支付O(1)查找地图的代价。</p>
<p>选择最简单的合理数据结构并继续。这是用于编写“非慢速软件”的CS 101。这应该是您的默认开发模式。如果您知道需要随机访问，请不要选择链接列表。如果您知道需要按顺序遍历，请不要使用地图。需求变化，你不能总是猜测未来。对工作量做出合理的猜测。</p>
<p><a class="link"   href="http://daslab.seas.harvard.edu/rum-conjecture/" >http://daslab.seas.harvard.edu/rum-conjecture/<i class="fas fa-external-link-alt"></i></a></p>
<p>类似问题的数据结构在做一件工作时会有所不同。随着插入的发生，二叉树每次排序一次。未排序的数组插入速度更快但未排序:最后，“敲定”你需要一次完成排序。</p>
<p>当编写一个供其他人使用的包时，避免每个用例都要优先考虑的诱惑。这将导致代码不可读。按设计的数据结构实际上是单一用途的。你既不能读懂头脑，也不能预测未来。如果用户说“你的软件包对于这个用例太慢”，一个合理的答案可能是“然后在这里使用这个软件包”。一揽子计划应该“做得很好”。</p>
<p>有时混合数据结构将提供你需要的性能改进。例如，通过分段数据，你可以将搜索范围限制在一个存储桶中。这仍然支付O(n)的理论成本，但常数会更小。当我们进行编程调整时，我们将重新审视这些调整。</p>
<p>在讨论大O符号时，人们忘记了两件事</p>
<p>其一，涉及到一个不变的因素。具有相同算法复杂度的两种算法可以具有不同的常数因子。想象一下，循环遍历一个列表100次，而仅循环一次。即使两者都是O（n），也有一个恒定的因子是100倍。</p>
<p>这些常数因素是为什么即使合并排序，快速排序和排列所有O(n log n)，每个人都使用快速排序，因为它是最快的。它具有最小的常数因子。</p>
<p>第二件事是大O只说“随着n增长到无穷大”。它谈到了增长趋势，“随着数字变大，这是主导运行时间的增长因素。” 它没有提到实际的表现，也没有说明它如何表现小n。</p>
<p>经常有一个分界点，在这个分界点以下，木材算法更快。Go标准库sort包的一个很好的例子。大多数时候它使用快速排序，但是当分区大小降到12个元素以下时，它会进行shell排序传递，然后进行插入排序。</p>
<p>对于某些算法，常数因子可能非常大，以致此截点可能比所有合理的输入都大。也就是说，O（n ^ 2）算法对于所有可能处理的输入都比O（n）算法快。</p>
<p>这也是另一种方式：例如，即使小输入的基准变慢，选择使用更复杂的数据结构来给出O（n）缩放而不是O（n ^ 2）。这也适用于大多数无锁数据结构。它们通常在单线程情况下较慢，但在多线程使用它时更具可扩展性。</p>
<p>现代计算机中的存储器层次结构将问题混淆了一点，因为高速缓存更喜欢将片段扫描到追踪指针的有效随机访问的可预测访问。不过，最好从一个好的算法开始。我们将在硬件特定部分讨论这个问题。</p>
<p>“这场斗争可能并不总是最强，也不是最快的比赛，但这是打赌的方式。” - 吉卜林。</p>
<p>有时，针对特定问题的最佳算法不是单一的算法，而是专门针对稍微不同的输入类的算法集合。这个“polyalgorithm”可以快速检测出需要处理的输入类型，然后发送到相应的代码路径。这就是上面提到的排序包所做的：确定问题的大小并选择不同的算法。除了结合quicksort，shell排序和插入排序之外，它还会跟踪快速排序的递归深度并在必要时调用堆排序。在string与bytes包做类似的事情，检测和专门处理不同的情况。与数据压缩一样，您对输入内容的了解越多，定制解决方案就越好。即使优化并不总是适用，通过确定使用和执行不同的逻辑是安全的，使代码复杂化可能是值得的。</p>
<p>这也适用于你的算法需要解决的子问题。例如，能够使用基数排序可以对性能产生重大影响，如果只需要部分排序，则可以使用快速选择。</p>
<p>有时候，而不是专门针对您的特定任务，最好的方法是将其抽象为研究人员已经充分研究的更一般的问题空间。然后，您可以将更一般的解决方案应用于您的特定问题。将你的问题映射到已经有很好研究实现的领域可能是一个重大的胜利。</p>
<h2 id="基准输入"><a href="#基准输入" class="headerlink" title="基准输入"></a>基准输入</h2><p>了解你的每种输入尺寸可能在生产中有多大。</p>
<p>你的基准测试必须使用适当大小的输入。正如我们所看到的，不同的算法在不同的输入大小下都有意义。如果你的预期输入范围&lt;100，那么你的基准应该反映这一点。否则，选择最适合n = 10 ^ 6的算法可能不是最快的。</p>
<p>能够生成有代表性的测试数据。不同的数据分布会在你的算法中引发不同的行为:想想经典的“数据排序时快速排序为O(n ^ 2)”示例。类似地，对于均匀的随机数据，插值搜索是O(log log n)，但是O(n)最差的情况。知道你的输入是什么样子是代表性基准和选择最佳算法的关键。如果你用来测试的数据不能代表实际工作负载，那么你可以轻松完成针对某个特定数据集的优化，“过度配置”你的代码以便使用一组特定的输入进行最佳工作。</p>
<p>这也意味着你的基准数据需要代表真实世界。如果重复的请求非常少见，保留它们比重新计算它们更昂贵。如果你的基准数据仅包含相同的重复请求，则缓存将提供不准确的性能视图。</p>
<p>另请注意，一旦部署到生产环境并且在40核心服务器上达到25万次/秒，笔记本电脑上可能看不到的一些问题就可以看到。</p>
<p>编写好的基准测试可能很困难。<br>TODO：microbenchmarks显示速度减慢但宏观（现实世界）性能提高的情况。</p>
<ul>
<li><a class="link"   href="https://timharris.uk/misc/five-ways.pdf" >https://timharris.uk/misc/five-ways.pdf<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="程序调整"><a href="#程序调整" class="headerlink" title="程序调整"></a>程序调整</h2><p>程序调优曾经是一种艺术形式，但编译器变得更好。所以现在事实证明，编译器可以比复杂的代码更好地直接优化代码。Go编译器在匹配gcc和clang方面还有很长的路要走，但这确实意味着在调整时需要小心，特别是在升级Go版本时不要变得更糟。一旦编译器得到改进，肯定会出现一些针对缺少特定编译器优化工作的调整。</p>
<p>TODO：https : //github.com/golang/go/commit/9eb219480e8de08d380ee052b7bff293856955f8）</p>
<p>如果你正在解决特定的运行时或编译器代码生成问题，请始终使用指向上游问题的链接记录你的更改。这可以让你在bug修复后快速重新访问你的优化。</p>
<p>打击基于民间传说的崇拜“性能提示”的诱惑，甚至是从你自己的经验中过度概括。每个性能缺陷都需要根据自身的优点加以处理。即使之前已经有效，确保配置文件确保修复仍然适用。你以前的工作可以指导你，但不要盲目应用以前的优化。</p>
<p>程序调优是一个迭代过程。继续重新访问你的代码并查看可以进行哪些更改。确保你在每一步都取得进展。经常有一项改进可以使其他人获得成功。(现在我没有做A，我可以通过做C来简化B)。这意味着你需要继续观察整个图片，而不是沉迷于一小组线。</p>
<p>一旦你确定了正确的算法，程序调优就是改进算法实现的过程。在Big-O表示法中，这是减少与程序相关的常量的过程。</p>
<p>所有的节目调整都要么让速度变慢，要么减慢速度。算法变化也属于这些类别，但我们将看到较小的变化。你的具体做法随技术变化而变化。</p>
<p>做一个缓慢的事情可能会用更快的散列函数替换SHA1或者hash/fnv1。少做一次缓慢的事情可能会节省一个大文件的哈希计算结果，因此你不必多次执行该操作。</p>
<p>保留意见。如果不需要做什么，请解释原因。通常，在优化算法时，你会发现在某些情况下不需要执行的步骤。记录它们。其他人可能会认为这是一个错误，需要放回去。</p>
<p>空程序立刻给出了错误的答案。<br>如果你不必是正确的，那么很快就会很快。</p>
<p>“正确性”可以取决于问题。启发式算法大多数情况下是正确的，大部分时间都可以很快，而且猜测和改进的算法可以让您在达到可接受的限制时停下来。</p>
<p>缓存常见情况：</p>
<ul>
<li>你的缓存甚至不需要很大。</li>
<li>参见下面的 time.Parse（）例子; 只有一个价值观产生了影响</li>
<li>但要注意缓存失效，线程问题等。</li>
<li>随机缓存驱逐是快速且足够有效的。</li>
<li>随机缓存插入可以用最少的逻辑将缓存限制为流行的项目。</li>
<li>将缓存逻辑的成本与重新获取数据的成本进行比较。</li>
<li>大容量缓存可能会增加GC压力并不断吹动处理器缓存。</li>
<li>在极端情况下（很少或没有驱逐，将所有请求缓存到一个昂贵的函数），这可以变成记忆</li>
</ul>
<p>我已经完成了一个网络跟踪实验，表明即使是最佳的缓存也不值得。你的预期命中率很重要。你需要将比率导出到你的监控堆栈。不断变化的比例将显示流量的变化。然后是重新访问缓存大小或过期策略的时候了。</p>
<p>程序调优：</p>
<p>程序调优是以小步骤迭代改进程序的艺术。Egon Elbre列出了他的程序：</p>
<ul>
<li>提出一个假设，为什么你的程序很慢。</li>
<li>拿出N个解决方案来解决它</li>
<li>尝试一切，并保持最快。</li>
<li>以防万一。</li>
<li>重复。</li>
</ul>
<p>调整可以采取多种形式。</p>
<ul>
<li>如果可能，请保留旧的实现以进行测试。</li>
<li>如果不可能，则生成足够的黄金测试用例来比较输出。<br>“足够”意味着包括边缘案例，因为这些可能会受到调优的影响，因为您旨在提高一般情况下的性能。</li>
<li>利用数学身份：<br><a class="link"   href="https://github.com/golang/go/commit/ed6c6c9c11496ed8e458f6e0731103126ce60223" >https://github.com/golang/go/commit/ed6c6c9c11496ed8e458f6e0731103126ce60223<i class="fas fa-external-link-alt"></i></a><br><a class="link"   href="https://gist.github.com/dgryski/67e6a7ff94c3a1add30eb26ec0ad8b0f" >https://gist.github.com/dgryski/67e6a7ff94c3a1add30eb26ec0ad8b0f<i class="fas fa-external-link-alt"></i></a><ul>
<li>与加法相乘</li>
<li>使用WolframAlpha，Maxima，sympy和类似工具来专门化，优化或创建查找表<br>（另外，<a class="link"   href="https://users.ece.cmu.edu/~franzf/papers/gttse07.pdf%EF%BC%89" >https://users.ece.cmu.edu/~franzf/papers/gttse07.pdf）<i class="fas fa-external-link-alt"></i></a></li>
<li>“只为你使用的东西付费，而不是你可以使用的东西”</li>
<li>零只是数组的一部分，而不是整个事物</li>
<li>最好以微小的步骤完成，一次只做几个陈述</li>
<li>从浮点数学到整数数学</li>
<li>或者mandelbrot删除sqrt，或者lttb删除abs， a &lt; b/c=&gt;a * c &lt; b</li>
<li>在更昂贵的支票前进行廉价支票</li>
<li>例如，在正则表达式之前的strcmp，（qv，在查询之前的布隆过滤器）“少花费更多时间”</li>
<li>在罕见情况之前的常见情况，即避免总是失败的额外测试</li>
<li>展开仍然有效：https：//play.golang.org/p/6tnySwNxG6O</li>
<li>代码大小。vs分支测试开销</li>
<li>使用偏移而不是切片分配可以帮助进行边界检查，数据依赖性和代码生成（少于在内部循环中复制）。</li>
<li>这就是Hacker’s Delight的一部分</li>
<li>考虑不同的数字表示法：定点，浮点，（小）整数，</li>
<li>爱好者：带误差累加器的整数（如Bresenham的线和圆），多基数/冗余数字系统</li>
</ul>
</li>
</ul>
<p>许多针对调优的民间传说性能提示依赖于对编译器的优化不足，并鼓励程序员手动完成这些转换。编译器一直在使用更新，而不是用15年的时间乘以或除以2的幂 - 现在没有人应该亲自去做。类似地，提升循环中的不变计算，基本循环展开，常见子表达式消除等等都是由gcc和clang等自动完成的。Go的编译器完成了其中的许多工作，并继续改进。一如往常，在提交新版本之前进行基准测试。</p>
<p>编译器无法做到的转换依赖于你了解有关算法，输入数据，系统中的不变量以及可以做出的其他假设等事情，并将该隐式知识分解为删除或更改数据结构中的步骤。</p>
<p>每个优化都会对你的数据进行假设。这些必须记录下来，甚至更好地进行测试。这些假设将会在你的程序崩溃，放慢速度，或随着系统发展而开始返回错误数据的地方。</p>
<p>程序调整改进是累积的。5倍3％的改善是15％的改善。进行优化时，值得考虑预期的性能改进。用更快的替换哈希函数是一个不断改进的因素。</p>
<p>了解你的要求和可以改变的地方可以提高性能。在#performance Gophers Slack频道中呈现的一个问题是用于为字符串键/值对映射创建唯一标识的花的数量。最初的解决方案是提取键，对它们进行排序，并将结果字符串传递给散列函数。我们提出的改进解决方案是在键/值添加到地图时对其进行单独散列处理，然后将所有这些散列在一起以创建标识符。</p>
<p>这是一个专业化的例子。</p>
<p>假设我们正在处理一天中的大量日志文件，并且每行都以时间戳开始。</p>
<p>Sun  4 Mar 2018 14:35:09 PST &lt;………………………&gt;<br>对于每行，我们调用time.Parse()把它变成一个格式。如果性能分析显示我们time.Parse()是瓶颈，那么我们有几种方法可以加快速度。</p>
<p>最简单的方法是保留先前看到的时间戳和相关历元的单项缓存。只要我们的日志文件在一秒钟内有多行，这将是一场胜利。对于1000万行日志文件的情况，这种策略将昂贵的呼叫数量time.Parse()从10,000,000减少到86400 - 每个独立的秒钟一个。</p>
<p>TODO：单项缓存的代码示例</p>
<p>我们可以做更多吗？因为我们确切知道时间戳的格式， 并且它们都在一天内完成，所以我们可以编写自定义时间解析逻辑，将其考虑在内。我们可以计算午夜的时代，然后从时间戳字符串中提取小时，分钟和秒 - 它们都将在字符串中处于固定偏移量 - 并执行一些整数运算。</p>
<p>TODO：字符串偏移版本的代码示例</p>
<p>在我的基准测试中，这将解析时间从275ns / op减少到5ns / op。（当然，即使在275 ns / op下，你也更有可能在I / O上被阻塞，而不是在时间解析上被CPU阻塞。）</p>
<p>一般算法很慢，因为它必须处理更多的案例。你的算法可以更快，因为你更了解你的问题。但是代码与您需要的密切关系更紧密。如果时间格式发生变化，更新更加困难。</p>
<p>优化是专业化的，专用代码比通用代码更易于改变。</p>
<p>对于大多数情况，标准库实现需要“足够快”。如果你有更高的性能需求，你可能需要专门的实现。</p>
<p>定期进行配置文件以确保跟踪系统的性能特征，并准备随着流量变化重新优化。了解你的系统的极限，并有好的指标，让你预测什么时候你会达到这些限制。</p>
<p>当你的应用程序的使用发生更改时，不同的部分可能会成为热点。重温先前的优化并决定它们是否仍然值得，并在可能的情况下恢复为更易读的代码。我有一个系统，我使用一组复杂的mmap优化了启动时间，反映了不安全性。一旦我们改变了系统的部署方式，这个代码就不再需要了，我用更可读的常规文件操作取代了它。</p>
<p>优化工作流程摘要<br>所有优化都应遵循以下步骤：</p>
<ol>
<li>确定你的表现目标，并确认你没有达到他们的目标</li>
<li>配置文件来识别要改进的区域。</li>
<li>这可以是CPU，堆分配或goroutine阻塞。</li>
<li>基准来确定您的解决方案使用内置基准测试框架提供的加速<a class="link"   href="http://golang.org/pkg/testing/" >http://golang.org/pkg/testing/<i class="fas fa-external-link-alt"></i></a></li>
<li>确保您在目标操作系统和体系结构上进行正确的基准测试。</li>
<li>之后再次进行配置以验证问题已消失</li>
<li>使用<a class="link"   href="https://godoc.org/golang.org/x/perf/benchstat" >https://godoc.org/golang.org/x/perf/benchstat<i class="fas fa-external-link-alt"></i></a>或<a class="link"   href="https://github.com/codahale/tinystat" >https://github.com/codahale/tinystat<i class="fas fa-external-link-alt"></i></a>来验证一组时间“充分”不同，以便优化值得添加代码复杂性。</li>
<li>使用<a class="link"   href="https://github.com/tsenart/vegeta" >https://github.com/tsenart/vegeta<i class="fas fa-external-link-alt"></i></a>负载测试http服务（+其他花哨的：k6，fortio，…）</li>
<li>确保你的延迟数字是有意义的</li>
<li>第一步很重要。它会告诉您何时何地开始优化。更重要的是，它还会告诉你何时停止。几乎所有优化都会增加代码的复杂性以换取速度。而且你总是可以更快地编写代码。这是一个平衡的行为。</li>
</ol>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="介绍性分析"><a href="#介绍性分析" class="headerlink" title="介绍性分析"></a>介绍性分析</h3><p>一般适用于源代码的技术</p>
<ol>
<li>介绍pprof<ul>
<li>Go工具pprof(<a class="link"   href="https://github.com/google/pprof" >https://github.com/google/pprof<i class="fas fa-external-link-alt"></i></a>)</li>
</ul>
</li>
<li>编写和运行(微)基准<ul>
<li>简介，将hot code提取到基准，优化基准，配置文件。</li>
<li>-cpuprofile/-memprofile/-benchmem</li>
<li>0.5 ns/op意味着它被优化了 -&gt;如何避免</li>
<li>编写好的基准测试的技巧(删除不必要的工作，但增加基准)</li>
</ul>
</li>
<li>如何读取它的pprof输出</li>
<li>显示的运行系统有哪些不同的部分</li>
<li>宏观基准(生产剖析)<ul>
<li>net/HTTP/pprof</li>
</ul>
</li>
<li>使用-base查看差异</li>
<li>内存选项：-inuse_space，-inuse_objects，-alloc_space，-alloc_objects</li>
<li>生产分析; localhost + ssh隧道，auth头文件，使用curl。</li>
</ol>
<h2 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h2><ul>
<li>一些更有趣的/先进的工具</li>
<li>/x/perf中的其他工具</li>
<li>perf（perf2pprof）</li>
<li>英特尔vtune/amd codexl/instruments<br><a class="link"   href="https://godoc.org/github.com/aclements/go-perf" >https://godoc.org/github.com/aclements/go-perf<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>你不止一次支付内存分配。第一个显然是你分配它的时候。但是，每次垃圾收集运行时，你也要付出代价。</p>
<p>减少回收再利用。 - @bboreham</p>
<ul>
<li>堆栈与堆分配</li>
<li>什么导致堆分配？</li>
<li>了解逃逸分析(和当前的限制)</li>
<li>/debug/pprof/heap和-base</li>
<li>API设计限制分配:允许传入缓冲区，因此调用者可以重用而不是强制分配</li>
<li>你甚至可以在扫描时仔细修改切片</li>
<li>减少指针以减少gc扫描时间</li>
<li>无指针的map键</li>
<li>GOGC</li>
<li>缓冲区重用(sync.Pool vs或通过go-slab等自定义)</li>
<li>切片与偏移量：当GC运行时指针写入需要writebarrier：https : //github.com/golang/go/commit/b85433975aedc2be2971093b6bbb0a7dc264c8fd</li>
<li>使用错误变量而不是errors.New（）/ fmt.Errorf（）在呼叫站点（性能或风格？接口需要指针，所以它转义为堆）</li>
<li>使用结构化的错误来减少分配（传递结构值），在错误打印时创建字符串</li>
<li>大小端</li>
</ul>
<h2 id="运行时和编译器"><a href="#运行时和编译器" class="headerlink" title="运行时和编译器"></a>运行时和编译器</h2><ul>
<li>通过接口调用的成本(在CPU级别上的间接调用)</li>
<li>runtime.convT2E/runtime.convT2I</li>
<li>类型断言与类型切换</li>
<li>延缓</li>
<li>用于整数，字符串的特殊映射实现<ul>
<li>byte/uint16的映射未优化; 改用切片。</li>
<li>你可以使用math.Float{32,64}{from,}bits优化float64-optimized ，但要注意浮动平等问题</li>
<li><a class="link"   href="https://github.com/dgryski/go-gk/blob/master/exact.go" >https://github.com/dgryski/go-gk/blob/master/exact.go<i class="fas fa-external-link-alt"></i></a> 据说快100倍; 需要基准测试</li>
</ul>
</li>
<li>边界检查消除</li>
<li>[]字节&lt;-&gt;字符串副本，Map优化</li>
<li>双值的range将复制一个数组，使用sclice替代：<ul>
<li><a class="link"   href="https://play.golang.org/p/4b181zkB1O" >https://play.golang.org/p/4b181zkB1O<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://github.com/mdempsky/rangerdanger" >https://github.com/mdempsky/rangerdanger<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
<li>尽可能使用字符串连接而不是fmt.Sprintf; 运行时为它已经优化了例程</li>
</ul>
<h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><ul>
<li>它所有的危险项</li>
<li>unsafe的常见用途</li>
<li>mmap数据文件<ul>
<li>结构填充</li>
<li>但并不总是足够快以证明复杂性/安全成本</li>
<li>但是“off-heap”，所以被gc忽略（但是没有指针的slice）</li>
</ul>
</li>
<li>快速反序列化</li>
<li>string &lt;-&gt; slice 转换，[]byte &lt;-&gt; []uint32，…</li>
<li>int到bool是不安全的hack (但 != 0是可以的)</li>
<li>填充：<ul>
<li><a class="link"   href="https://dave.cheney.net/2015/10/09/padding-is-hard" >https://dave.cheney.net/2015/10/09/padding-is-hard<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="http://www.catb.org/esr/structure-packing/#_go_and_rust" >http://www.catb.org/esr/structure-packing/#_go_and_rust<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://golang.org/ref/spec#Size_and_alignment_guarantees" >https://golang.org/ref/spec#Size_and_alignment_guarantees<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="https://github.com/dominikh/go-tools" >https://github.com/dominikh/go-tools<i class="fas fa-external-link-alt"></i></a> 结构布局，结构布局优化</li>
<li>通过Offsetof对结构布局进行编码以发现unsafe和asm破损</li>
</ul>
</li>
</ul>
<h2 id="与标准库共同陷阱"><a href="#与标准库共同陷阱" class="headerlink" title="与标准库共同陷阱"></a>与标准库共同陷阱</h2><ul>
<li>time.After()泄漏，直到它被触发</li>
<li>重用HTTP连接…</li>
<li>rand.Int()和朋友是1)互斥体保护和2)创建昂贵</li>
<li>考虑交替随机数生成(go-pcgr，xorshift)</li>
<li>binary.Read和binary.Write使用反射并且很慢; 手动做</li>
<li>如果可能，请使用strconv而不是fmt</li>
<li>….</li>
</ul>
<h2 id="替代实现"><a href="#替代实现" class="headerlink" title="替代实现"></a>替代实现</h2><ul>
<li>标准库软件包的普遍替代品:<ul>
<li>encoding/json -&gt; ffjson</li>
<li>net/http -&gt; fasthttp(但不兼容的API)</li>
<li>regexp -&gt; ragel(或其他正则表达式包)</li>
</ul>
</li>
<li>序列化<ul>
<li>encoding/gob - &gt; <a class="link"   href="https://github.com/alecthomas/go_serialization_benchmarks" >https://github.com/alecthomas/go_serialization_benchmarks<i class="fas fa-external-link-alt"></i></a></li>
<li>protobuf - &gt; <a class="link"   href="https://github.com/gogo/protobuf" >https://github.com/gogo/protobuf<i class="fas fa-external-link-alt"></i></a></li>
<li>所有格式都有权衡:选择一种符合你需要的编码空间，解码速度，语言/工具兼容性……</li>
</ul>
</li>
<li>database/sql - &gt; jackx/pgx，…</li>
<li>gccgo</li>
<li>container/list：使用切片（几乎总是）</li>
</ul>
<h2 id="CGO"><a href="#CGO" class="headerlink" title="CGO"></a>CGO</h2><ul>
<li>cgo调用的性能特征</li>
<li>降低成本的技巧:配料</li>
<li>Go和C之间传递指针的规则</li>
<li>syso文件</li>
</ul>
<h2 id="高级技术"><a href="#高级技术" class="headerlink" title="高级技术"></a>高级技术</h2><p>特定于运行代码的体系结构的技术</p>
<ul>
<li><p>CPU缓存介绍</p>
<ul>
<li>性能的悬崖</li>
<li>围绕缓存行构建直觉:大小，填充，对齐</li>
<li>共享假</li>
<li>真正的共享 -&gt;分片</li>
<li>OS工具来查看缓存未命中</li>
<li>Mao与切片</li>
<li>SOA vs AOS布局</li>
<li>减少指针追逐</li>
</ul>
</li>
<li><p>分支预测<br>从内部循环中删除分支：<br>  if a { for { } } else { for { } }<br>  代替<br>  for { if a { } else { } }</p>
<p>  避免</p>
<p>  if i % 2 == 0 {</p>
<pre><code>  evens++</code></pre>
<p>  } else {</p>
<pre><code>  odds++</code></pre>
<p>  }</p>
<p>  counts[i &amp; 1] ++并不总是更快，但通常更难以阅读<br>  TODO：ASCII类计数示例和基准</p>
</li>
<li><p>排序数据可以通过缓存局部性和分支预测来帮助提高性能，即使考虑到排序所花费的时间</p>
</li>
<li><p>函数调用开销</p>
</li>
<li><p>关于Jeff Dean的2002年数字(加上更新)的评论</p>
<ul>
<li>cpus变得更快了，但是内存没有跟上</li>
</ul>
</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li>找出哪些部分可以并行完成，哪部分必须是顺序的</li>
<li>goroutines很便宜，但不免费。</li>
<li>优化多线程代码<ul>
<li>共享false -&gt; 填充缓存行大小</li>
<li>共享true -&gt; 分片</li>
</ul>
</li>
<li>与上一节关于缓存和虚假/真实共享重叠</li>
<li>延迟同步; 它很贵，所以复制工作可能会更便宜</li>
<li>你可以控制的东西：worker的数量，批量大小</li>
</ul>
<p>你需要一个互斥体来保护共享的可变状态。如果你有很多的互斥量争用，你需要减少共享，或者减少mutable。减少共享的两种方法是1）分割锁或2）独立处理，然后合并。为了减少mutable：好吧，让你的数据结构是只读的。你还可以通过减少关键部分来缩短数据共享的时间 - 尽可能少地锁定锁定。有时候RWMutex就足够了，但是请注意，它们比较慢，但是它们允许多个读者进入。</p>
<p>如果你正在分解锁，请注意共享缓存行。您需要填充以避免缓存行拥有权在处理器之间弹跳。</p>
<p>var stripe [8]struct{ sync.Mutex; _ [7]uint64 } //互斥量为64位; 填充填充缓存行的其余部分</p>
<h2 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h2><ul>
<li>关于为Go编写汇编代码</li>
<li>编译器改进; bar很高</li>
<li>尽可能少地替换以产生影响</li>
<li>很好的理由：SIMD指令或者Go和编译器可以提供的其他东西</li>
<li>非常重要的基准:改进可能是巨大的(高速公路的10倍)零(小点)，或甚至更慢(不内联)</li>
<li>用新版本重新标记以查看是否可以删除代码</li>
<li>TODO：链接到1.11补丁删除汇编代码</li>
<li>总是有纯粹的Go版本(noasm build tag):测试，arm，gccgo</li>
<li>简要介绍语法</li>
<li>调用的约定</li>
<li>使用不受asm支持的操作码</li>
<li>关于为什么内联很难</li>
<li>使这更容易工具:asmfmt，peachpy，c2goasm，…</li>
</ul>
<h2 id="优化整个服务"><a href="#优化整个服务" class="headerlink" title="优化整个服务"></a>优化整个服务</h2><p>大多数情况下，你不会看到一个CPU限制的例程。这是一个简单的例子。如果你有优化服务，则需要查看整个系统。监测。指标。随着时间的推移记录很多事情，这样你可以看到它们变得更糟，所以你可以看到你的更改对生产的影响。</p>
<p>tip.golang.org/doc/diagnostics.html</p>
<ul>
<li>系统设计参考:SRE Book，实用的分布式系统设计</li>
<li>额外的工具:更多日志记录+分析</li>
<li>两条基本规则:加速缓慢的事情或减少频率。</li>
<li>分布式跟踪以追踪更高级别的瓶颈</li>
<li>用于查询单个服务器而不是批量查询模式</li>
<li>你的性能问题可能不是你的代码，但是你仍然需要解决它们</li>
</ul>
<h2 id="附录-实施研究论文"><a href="#附录-实施研究论文" class="headerlink" title="附录:实施研究论文"></a>附录:实施研究论文</h2><p>实施论文的提示:( algorithm另请参阅data structure）</p>
<ul>
<li>别。从明显的解决方案和合理的数据结构开始。<br>“现代”算法往往具有较低的理论复杂性，但具有较高的常数因子和很多实施复杂性。其中一个经典例子是斐波那契堆。他们很难得到正确的，并有一个巨大的不变因素。已经发表了多篇论文，比较了不同工作负载下堆的实现方式，总体而言，4或8元的隐含堆总是排在前列。即使在Fibonacci堆应该更快（由于O（1）“减少键”）的情况下，使用Dijkstra的深度优先搜索算法的实验表明，当他们使用直接堆去除和加法时，它的速度更快。</li>
</ul>
<p>类似地，对比更复杂的红黑或AVL树也可以找到对照或者跳过列表。在现代硬件上，“较慢”的算法可能足够快，甚至更快。</p>
<blockquote>
<p>最快的算法经常可以被几乎一样快速且容易理解的算法取代。</p>
<p>道格拉斯W.琼斯，爱荷华大学</p>
</blockquote>
<p>增加的复杂性必须足以使得回报实际上值得。另一个例子是缓存驱逐算法。不同的算法可以具有高得多的复杂度，仅命中率的小改进。当然，您可能无法在测试之前进行测试，直到您有一个可行的实施并将其整合到您的程序中。</p>
<p>有时候这篇论文会有图表，但很像只发布正面结果的趋势，但这些倾向往往会偏向于表示新算法的优点。</p>
<ul>
<li>选择正确的纸张。</li>
<li>寻找他们的算法声称击败和实施的论文。</li>
</ul>
<p>通常，早期的论文会更容易理解，并且必须具有更简单的算法。</p>
<p>并非所有的文件都很好。</p>
<p>查看论文写入的上下文。确定有关硬件的假设：磁盘空间，内存使用情况等。一些较旧的论文在70年代或80年代进行了合理的不同折衷，但不一定适用于您的使用案例。例如，他们认为什么是“合理的”内存与磁盘使用的权衡。内存大小现在增加了数量级，并且SSD改变了使用磁盘的延迟惩罚。同样，一些流媒体算法是为路由器硬件而设计的，这可能会使转换成软件变得非常痛苦。</p>
<p>确保算法对数据保持的假设。</p>
<p>这将需要一些挖掘。你可能不想实现你找到的第一篇论文。</p>
<ul>
<li><p>确保你了解算法。这听起来很明显，但是否则无法进行调试。</p>
<p><a class="link"   href="https://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf" >https://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<p>一个良好的理解可能会让你从论文中提取关键的想法，并且可能将这个想法应用于你的问题，这可能比重新实现整个事情更简单。</p>
<ul>
<li><p>数据结构或算法的原始文件并不总是最好的。后来的论文可能会有更好的解释。</p>
</li>
<li><p>一些论文发布了可以与之比较的参考源代码，但是</p>
<ol>
<li>学术代码几乎普遍可怕</li>
<li>谨防许可限制（仅限“研究目的”）</li>
<li>提防错误; 边缘情况，错误检查，性能等。</li>
</ol>
</li>
</ul>
<p>还要注意GitHub上的其他实现：它们可能与您的bug相同（或不同）。</p>
<p>有关此主题的其他资源：</p>
<ul>
<li><a class="link"   href="https://www.youtube.com/watch?v=8eRx5Wo3xYA" >https://www.youtube.com/watch?v=8eRx5Wo3xYA<i class="fas fa-external-link-alt"></i></a></li>
<li><a class="link"   href="http://codecapsule.com/2012/01/18/how-to-implement-a-paper/" >http://codecapsule.com/2012/01/18/how-to-implement-a-paper/<i class="fas fa-external-link-alt"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>http 的header</title>
    <url>/2019/07/04/http/header/</url>
    <content><![CDATA[<h1 id="http中的header"><a href="#http中的header" class="headerlink" title="http中的header"></a>http中的header</h1><p>HTTP（HyperTextTransferProtocol） 即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模 型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而言，包括message-header和message-body两部分。首先传 递message-header，即http header消息 。http header 消息通常被分为4个部分：general  header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分。</p>
<a id="more"></a>

<h2 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h2><table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Data</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Tailaer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>报文传输的编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<h2 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h2><table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>控制缓存行为</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言</td>
</tr>
<tr>
<td>Authentication</td>
<td>web认证信息</td>
</tr>
<tr>
<td>Except</td>
<td>期待服务器特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在的服务器</td>
</tr>
<tr>
<td>if-Match</td>
<td>比较实体标记（Etag)</td>
</tr>
<tr>
<td>if-None-Match</td>
<td>比较实体标记，与if-Match相反</td>
</tr>
<tr>
<td>if-Modified-Since</td>
<td>比较资源更新时间</td>
</tr>
<tr>
<td>if-Range</td>
<td>资源未更新时发送实体Byte范围</td>
</tr>
<tr>
<td>if-UNmodified-Since</td>
<td>比较资源更新时间，与if-Modified-Since相反</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authentication</td>
<td>代理服务器认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体字节范围</td>
</tr>
<tr>
<td>Referer</td>
<td>URL原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>http客户端程序的信息</td>
</tr>
</tbody></table>
<h2 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h2><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>资源创建经过时间</td>
</tr>
<tr>
<td>Etag</td>
<td>资源匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>客户端重定向至指定url</td>
</tr>
<tr>
<td>Proxy-Authentication</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机的要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authentication</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<h2 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h2><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源支持的http方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体使用的编码</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主题的语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体大小（字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代资源URL</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体的过期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源最后修改时间</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Mediator_Pattern/</url>
    <content><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="中介者模式-1"><a href="#中介者模式-1" class="headerlink" title="中介者模式"></a>中介者模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;消费者类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, product, price</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;消费者&quot;</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.price = price</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shopping</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;买东西&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&quot;向&#123;&#125; 购买 &#123;&#125;价格内的 &#123;&#125;产品&quot;</span>.format(name, self.price, self.product))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;生产者类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, product, price</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;生产者&quot;</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.price = price</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sale</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;卖东西&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&quot;向&#123;&#125; 销售 &#123;&#125;价格的 &#123;&#125;产品&quot;</span>.format(name, self.price, self.product))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mediator</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;中介者类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;中介者&quot;</span></span><br><span class="line">        self.consumer = <span class="literal">None</span></span><br><span class="line">        self.producer = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sale</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;进货&quot;&quot;&quot;</span></span><br><span class="line">        self.consumer.shopping(self.producer.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shopping</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;出货&quot;&quot;&quot;</span></span><br><span class="line">        self.producer.sale(self.consumer.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profit</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;利润&quot;&quot;&quot;</span></span><br><span class="line">        print(<span class="string">&#x27;中介净赚：&#123;&#125;&#x27;</span>.format((self.consumer.price - self.producer.price )))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">complete</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.sale()</span><br><span class="line">        self.shopping()</span><br><span class="line">        self.profit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    consumer = Consumer(<span class="string">&#x27;手机&#x27;</span>, <span class="number">3000</span>)</span><br><span class="line">    producer = Producer(<span class="string">&quot;手机&quot;</span>, <span class="number">2500</span>)</span><br><span class="line">    mediator = Mediator()</span><br><span class="line">    mediator.consumer = consumer</span><br><span class="line">    mediator.producer = producer</span><br><span class="line">    mediator.complete()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向生产者 购买 3000价格内的 手机产品</span></span><br><span class="line"><span class="comment"># 向消费者 销售 2500价格的 手机产品</span></span><br><span class="line"><span class="comment"># 中介净赚：500</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Iterator_Pattern/</url>
    <content><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>外提供一个接口，实现顺序访问聚合数据，但是不显示该数据的内部机制。这就是Python中大名鼎鼎的迭代器。</p>
<a id="more"></a>

<p>实现迭代模式对于Python来说没有多余的代码，寥寥几行代码足可以实现迭代模式。</p>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="迭代器模式-1"><a href="#迭代器模式-1" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">FibonacciSequence</span>(<span class="params">n</span>):</span></span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">1</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> y</span><br><span class="line">        <span class="keyword">if</span> i == n:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        x, y = y, x+y</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = FibonacciSequence(<span class="number">7</span>)</span><br><span class="line">    next(test)</span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    next(test)</span><br><span class="line">    <span class="comment"># 1</span></span><br><span class="line">    next(test)</span><br><span class="line">    <span class="comment"># 2</span></span><br><span class="line">    next(test)</span><br><span class="line">    <span class="comment"># 3</span></span><br><span class="line">    next(test)</span><br><span class="line">    <span class="comment"># 5</span></span><br><span class="line">    next(test)</span><br><span class="line">    <span class="comment"># 8</span></span><br><span class="line">    next(test)</span><br><span class="line">    <span class="comment"># 13</span></span><br><span class="line">    next(test)</span><br></pre></td></tr></table></figure>

<p>以上是使用迭代模式输出斐波那契数列的前n列，较传统的实现方法而言更加的简洁。</p>
<p>迭代器模式常应用场景是在只提供接口而不暴露内部机制的场景中，yield关键词在python协程中也有应用。</p>
<p>迭代器、生成器、可迭代对象概念</p>
<p>生成器：对于一个数据集合，生成器并不记住每个元素值，但在循环中记录元素位置并根据元素生成规则推算出数值，这种边循环边计算的形式是生成器。</p>
<p>迭代器：是一种访问集合的方式，记住遍历位置，从第一个元素开始访问，直到最后一个元素，并且只能前进不能后退。</p>
<p>可迭代对象：像list、set、str这种可以通过for遍历的类型是可迭代对象，这种遍历顺序可以从尾到头。</p>
<p>凡是通过next（）访问的对象都是迭代器类型，也就是说生成器就是迭代器的一种；凡是可以通过for遍历的都是可迭代对象，可迭代对象可以通过iter（）转化为迭代器。</p>
<p>生成器中有几个关键词：yield、yield form、send、next()、<strong>next</strong>()具体作用见示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        b = <span class="keyword">yield</span> a</span><br><span class="line">        a += b</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> test()   <span class="comment"># yield form 是创建一个嵌套的生成器，form后面跟一个生成器，每次执行到yield form后会先把内层的生成器执行完。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fn = test()</span><br><span class="line">    next(fn)    <span class="comment"># 通过next访问内部元素</span></span><br><span class="line">    fn.__next__()   <span class="comment"># 通过__next__()方法访问内部元素，作用同上</span></span><br><span class="line">    fn.send(<span class="number">4</span>)  <span class="comment"># send有next的作用，同时向生成器内部的yield左边等式赋值</span></span><br><span class="line"></span><br><span class="line">    fn1 = test1()</span><br><span class="line">    fn.__next__()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>迭代器和可迭代对象有几个关键词：next（）、itre（）、for</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 迭代器及可迭代对象</span></span><br><span class="line"></span><br><span class="line">a = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>))</span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    next(a)</span><br><span class="line">    c = iter(b)</span><br><span class="line">    next(c)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Memento_Pattern/</url>
    <content><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。简单来说在运行过程中我们可以记录某个状态，当遇到错误时恢复当前状态，这在业务流程中是用设计来处理异常情况。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。</li>
<li>需要保存/恢复数据的相关状态场景。</li>
<li>提供一个可回滚的操作。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="备忘录模式-1"><a href="#备忘录模式-1" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddNumber</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.start = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        self.start += number</span><br><span class="line">        print(self.start)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;备忘录&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backups</span>(<span class="params">self, obj=None</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        设置备份方法</span></span><br><span class="line"><span class="string">        :param obj: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.obj_dict = copy.deepcopy(obj.__dict__)</span><br><span class="line">        print(<span class="string">&quot;备份数据:&#123;&#125;&quot;</span>.format(self.obj_dict))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recovery</span>(<span class="params">self, obj</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        恢复备份方法</span></span><br><span class="line"><span class="string">        :param obj: </span></span><br><span class="line"><span class="string">        :return: </span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        obj.__dict__.clear()</span><br><span class="line">        obj.__dict__.update(self.obj_dict)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = AddNumber()</span><br><span class="line">    memento = Memento()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;n&#x27;</span>, <span class="number">4</span>]:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">            memento.backups(test)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            test.add(i)</span><br><span class="line">        <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            print(test.start)</span><br><span class="line">    memento.recovery(test)</span><br><span class="line">    print(test.start)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">--------------------</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">备份数据:&#123;&#x27;start&#x27;: 2&#125;</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">unsupported operand type(s) for +=: &#x27;int&#x27; and &#x27;str&#x27;</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">11</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Observer_Pattern/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>定义对象间的一种一对多的依赖关系 ,当一个对象的状态发生改变时 , 所有依赖于它的对象都得到通知并被自动更新。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>当一个抽象模型有两个方面 , 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li>
<li>当对一个对象的改变需要同时改变其它对象 , 而不知道具体有多少对象有待改变。</li>
<li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之 , 你不希望这些对象是紧密耦合的。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="观察者模式-1"><a href="#观察者模式-1" class="headerlink" title="观察者模式"></a>观察者模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractObservable</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(</span><br><span class="line">            <span class="string">&#x27;register is a abstract method which must be implemente&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(</span><br><span class="line">            <span class="string">&#x27;remove is a abstract method which must be implemente&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractDisplay</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(</span><br><span class="line">            <span class="string">&#x27;update is a abstract method which must be implemente&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(</span><br><span class="line">            <span class="string">&#x27;display is a abstract method which must be implemente&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, subject</span>):</span></span><br><span class="line">        self.subject = subject</span><br><span class="line">        self._observers = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self, ob</span>):</span></span><br><span class="line">        self._observers.append(ob)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, ob</span>):</span></span><br><span class="line">        self._observers.remove(ob)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self, data=None</span>):</span></span><br><span class="line">        <span class="keyword">for</span> ob <span class="keyword">in</span> self._observers:</span><br><span class="line">            ob.update(data)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span>(<span class="params">AbstractObservable</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *namespaces</span>):</span></span><br><span class="line">        self._nss = &#123;&#125;</span><br><span class="line">        self._clock = <span class="literal">None</span></span><br><span class="line">        self._temperature = <span class="literal">None</span></span><br><span class="line">        self._humidity = <span class="literal">None</span></span><br><span class="line">        self._oxygen = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ns <span class="keyword">in</span> namespaces:</span><br><span class="line">            self._nss[ns] = Subject(ns)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self, ns, ob</span>):</span></span><br><span class="line">        <span class="keyword">if</span> ns <span class="keyword">not</span> <span class="keyword">in</span> self._nss:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;this &#123;&#125; is invalid namespace&#x27;</span>.format(ns))</span><br><span class="line">        self._nss[ns].register(ob)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span>(<span class="params">self, ns, ob</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._nss[ns].remove(ob)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_measurement</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># 此处实现可以更加紧凑，但是为了表达更简单，采用如下方式</span></span><br><span class="line">        self._clock = data[<span class="string">&#x27;clock&#x27;</span>]</span><br><span class="line">        self._temperature = data[<span class="string">&#x27;temperature&#x27;</span>]</span><br><span class="line">        self._humidity = data[<span class="string">&#x27;humidity&#x27;</span>]</span><br><span class="line">        self._oxygen = data[<span class="string">&#x27;oxygen&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> self._nss.keys():</span><br><span class="line">            <span class="keyword">if</span> k != <span class="string">&#x27;all&#x27;</span>:</span><br><span class="line">                data = self</span><br><span class="line"></span><br><span class="line">            self._nss[k].notify(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下 property 为了实现 pull 模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clock</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._clock</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">temperature</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._temperature</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">humidity</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._humidity</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oxygen</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._oxygen</span><br></pre></td></tr></table></figure>

<p>观察者模式的可观察对象实现可以分成两种实现方案：</p>
<ul>
<li>push 模式</li>
<li>pull 模式</li>
</ul>
<p>push 模式能保证所有的观察者可以接收到全部的数据，无论需要不需要，频繁更新会影响性能。</p>
<p>pull 模式需要观察者自己拉去数据，实现起来比较容易出错，但是能按需获取信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverviewDisplay</span>(<span class="params">AbstractDisplay</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._data = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        self._data = data</span><br><span class="line">        self.display()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">u&#x27;总览显示面板：&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> self._data.items():</span><br><span class="line">            print(k + <span class="string">&#x27;: &#x27;</span> + str(v))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TemperatureDisplay</span>(<span class="params">AbstractDisplay</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._storage = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        dt = data.clock</span><br><span class="line">        temperature = data.temperature</span><br><span class="line">        self._storage.append((dt, temperature))</span><br><span class="line">        self.display()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">u&#x27;温度显示面板：&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> storey <span class="keyword">in</span> self._storage:</span><br><span class="line">            print(storey[<span class="number">0</span>] + <span class="string">&#x27;: &#x27;</span> + str(storey[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成一个可观察对象，支持(&#x27;all&#x27;, &#x27;temperature&#x27;, &#x27;humidity&#x27;, &#x27;oxygen&#x27;)的数据通知</span></span><br><span class="line">    wd = WeatherData(<span class="string">&#x27;all&#x27;</span>, <span class="string">&#x27;temperature&#x27;</span>, <span class="string">&#x27;humidity&#x27;</span>, <span class="string">&#x27;oxygen&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 两个观察者对象</span></span><br><span class="line">    od = OverviewDisplay()</span><br><span class="line">    td = TemperatureDisplay()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注册到可观察对象中，能获取数据更新</span></span><br><span class="line">    wd.register(<span class="string">&#x27;all&#x27;</span>, od)</span><br><span class="line">    wd.register(<span class="string">&#x27;temperature&#x27;</span>, td)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新数据，可观察对象将会自动更新数据</span></span><br><span class="line">    wd.set_measurement(&#123;</span><br><span class="line">        <span class="string">&#x27;clock&#x27;</span>: time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>, time.localtime()),</span><br><span class="line">        <span class="string">&#x27;temperature&#x27;</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="string">&#x27;humidity&#x27;</span>: <span class="number">60</span>,</span><br><span class="line">        <span class="string">&#x27;oxygen&#x27;</span>: <span class="number">10</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一秒后再次更新数据</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    wd.set_measurement(&#123;</span><br><span class="line">        <span class="string">&#x27;clock&#x27;</span>: time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>, time.localtime()),</span><br><span class="line">        <span class="string">&#x27;temperature&#x27;</span>: <span class="number">21</span>,</span><br><span class="line">        <span class="string">&#x27;humidity&#x27;</span>: <span class="number">58</span>,</span><br><span class="line">        <span class="string">&#x27;oxygen&#x27;</span>: <span class="number">7</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">总览显示面板：</span></span><br><span class="line"><span class="string">humidity: 60</span></span><br><span class="line"><span class="string">temperature: 20</span></span><br><span class="line"><span class="string">oxygen: 10</span></span><br><span class="line"><span class="string">clock: 2017-03-26 18:08:41</span></span><br><span class="line"><span class="string">温度显示面板：</span></span><br><span class="line"><span class="string">2017-03-26 18:08:41: 20</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">总览显示面板：</span></span><br><span class="line"><span class="string">humidity: 58</span></span><br><span class="line"><span class="string">temperature: 21</span></span><br><span class="line"><span class="string">oxygen: 7</span></span><br><span class="line"><span class="string">clock: 2017-03-26 18:08:42</span></span><br><span class="line"><span class="string">温度显示面板：</span></span><br><span class="line"><span class="string">2017-03-26 18:08:41: 20</span></span><br><span class="line"><span class="string">2017-03-26 18:08:42: 21</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Prototype_Pattern/</url>
    <content><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
<ul>
<li>在抽象工厂模式中，抽象出了创建方法，使用者只能按照预定好的步骤新创建一个对象。</li>
<li>在建造者模式中，使用者可以按照自己的想法，在合理的范围内定制自己所需要的对象。<a id="more"></a>

</li>
</ul>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li>
<li>细胞分裂。在这个过程中，细胞核分裂产生两个新的细胞核，其中每个都有与原来细胞完全相同的染色体和DNA</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="原型模式-1"><a href="#原型模式-1" class="headerlink" title="原型模式"></a>原型模式</h3><p>有时，我们需要原原本本地为对象创建一个副本。举例来说，假设你想创建一个应用来存储、分享、编辑(比如，修改、添加注释及删除)食谱。用户Bob找到一份蛋糕食谱，在做了一些改变后，觉得自己做的蛋糕非常美味，想要与朋友Alice分享这个食谱。但是该如何分享食谱呢? 如果在与Alice分享之后，Bob想对食谱做进一步的试验，Alice手里的食谱也能跟着变化吗? Bob能够持有蛋糕食谱的两个副本吗? 对蛋糕食谱进行的试验性变更不应该对原本美味蛋糕的食谱造成影响。</p>
<p>这样的问题可以通过让用户对同一份食谱持有多个独立的副本来解决。每个副本被称为一个克隆，是某个时间点原有对象的一个完全副本。这里时间是一个重要因素。因为它会影响克隆所包含的内容。例如，如果Bob在对蛋糕食谱做改进以臻完美之前就与Alice分享了，那么Alice就绝不可能像Bob那样烘烤出自己的美味蛋糕，只能按照Bob原来找到的食谱烘烤蛋糕。</p>
<p>注意引用与副本之间的区别。如果Bob和Alice持有的是同一个蛋糕食谱对象的两个引用，那么Bob对食谱做的任何改变，对于Alice的食谱版本都是可见的，反之亦然。我们想要的是Bob和Alice各自持有自己的副本，这样他们可以各自做变更而不会影响对方的食谱。实际上Bob需要蛋糕食谱的两个副本: 美味版本和试验版本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span>:</span></span><br><span class="line"></span><br><span class="line">    value = <span class="string">&#x27;default&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clone</span>(<span class="params">self， **attrs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Clone a prototype and update inner attributes dictionary&quot;&quot;&quot;</span></span><br><span class="line">        obj = copy.deepcopy(self)</span><br><span class="line">        obj.__dict__.update(attrs)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrototypeDispatcher</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._objects = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_objects</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Get all objects&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._objects</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register_object</span>(<span class="params">self， name， obj</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Register an object&quot;&quot;&quot;</span></span><br><span class="line">        self._objects[name] = obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unregister_object</span>(<span class="params">self， name</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Unregister an object&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">del</span> self._objects[name]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    dispatcher = PrototypeDispatcher()</span><br><span class="line">    prototype = Prototype()</span><br><span class="line"></span><br><span class="line">    d = prototype.clone()</span><br><span class="line">    a = prototype.clone(value=<span class="string">&#x27;a-value&#x27;</span>， category=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    b = prototype.clone(value=<span class="string">&#x27;b-value&#x27;</span>， is_checked=<span class="literal">True</span>)</span><br><span class="line">    dispatcher.register_object(<span class="string">&#x27;objecta&#x27;</span>， a)</span><br><span class="line">    dispatcher.register_object(<span class="string">&#x27;objectb&#x27;</span>， b)</span><br><span class="line">    dispatcher.register_object(<span class="string">&#x27;default&#x27;</span>， d)</span><br><span class="line">    print([&#123;n: p.value&#125; <span class="keyword">for</span> n， p <span class="keyword">in</span> dispatcher.get_objects().items()])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="comment">### OUTPUT ###</span></span><br><span class="line"><span class="comment"># [&#123;&#x27;objectb&#x27;: &#x27;b-value&#x27;&#125;， &#123;&#x27;default&#x27;: &#x27;default&#x27;&#125;， &#123;&#x27;objecta&#x27;: &#x27;a-value&#x27;&#125;]</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Proxy_Pattern/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。好处是系统可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。</li>
<li>虚拟（Virtual）代理（图片延迟加载的例子）：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。使用虚拟代理模式的好处就是代理对象可以在必要的时候才将被代理的对象加载；代理可以对加载的过程加以必要的优化。当一个模块的加载十分耗费资源的情况下，虚拟代理的好处就非常明显。</li>
<li>保护代理（Protection Proxy ）控制对原始对象的访问。保护代理用于对象应该有不同 的访问权限的时候</li>
<li>智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jurisdiction</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;权限类&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level1</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;权限等级1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level2</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;权限等级2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level3</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;权限等级3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">level4</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;权限等级4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.user = name</span><br><span class="line">        self._jurisdiction = Jurisdiction()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leve</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.user == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self._jurisdiction.level1()</span><br><span class="line">        <span class="keyword">elif</span> self.user == <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self._jurisdiction.level2()</span><br><span class="line">        <span class="keyword">elif</span> self.user == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self._jurisdiction.level3()</span><br><span class="line">        <span class="keyword">elif</span> self.user == <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self._jurisdiction.level4()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;无此权限&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test = Proxy(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    test.leve()</span><br><span class="line">    test.user = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    test.leve()</span><br><span class="line">    test.user = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">    test.leve()</span><br><span class="line">    test.user = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">    test.leve()</span><br><span class="line">    test.user = <span class="string">&#x27;e&#x27;</span></span><br><span class="line">    test.leve()</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">-----------------------</span></span><br><span class="line"><span class="string">权限等级1</span></span><br><span class="line"><span class="string">权限等级2</span></span><br><span class="line"><span class="string">权限等级3</span></span><br><span class="line"><span class="string">权限等级4</span></span><br><span class="line"><span class="string">无此权限</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Singleton_Pattern/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>一个全局使用的类频繁地创建与销毁。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="使用函数装饰器实现单例"><a href="#使用函数装饰器实现单例" class="headerlink" title="使用函数装饰器实现单例"></a>使用函数装饰器实现单例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">cls</span>):</span></span><br><span class="line">    _instance = &#123;&#125; <span class="comment"># 使用不可变的类地址作为键，其实例作为值，每次创造实例时，首先查看该类是否存在实例，存在的话直接返回该实例即可，否则新建一个实例并存放在字典中。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>():</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> _instance:</span><br><span class="line">            _instance[cls] = cls()</span><br><span class="line">        <span class="keyword">return</span> _instance[cls]</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">    </span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cls1 = Cls()</span><br><span class="line">cls2 = Cls()</span><br><span class="line">print(id(cls1) == id(cls2))</span><br></pre></td></tr></table></figure>

<h3 id="使用类装饰器实现单例"><a href="#使用类装饰器实现单例" class="headerlink" title="使用类装饰器实现单例"></a>使用类装饰器实现单例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, cls</span>):</span></span><br><span class="line">        self._cls = cls</span><br><span class="line">        self._instance = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self._cls <span class="keyword">not</span> <span class="keyword">in</span> self._instance:</span><br><span class="line">            self._instance[self._cls] = self._cls()</span><br><span class="line">        <span class="keyword">return</span> self._instance[self._cls]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法一</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls2</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cls1 = Cls2()</span><br><span class="line">cls2 = Cls2()</span><br><span class="line">print(id(cls1) == id(cls2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls3</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Cls3 = Singleton(Cls3)</span><br><span class="line">cls3 = Cls3()</span><br><span class="line">cls4 = Cls3()</span><br><span class="line">print(id(cls3) == id(cls4))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用-new-创建单例"><a href="#使用-new-创建单例" class="headerlink" title="使用 __new__ 创建单例"></a>使用 <code>__new__</code> 创建单例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Single</span>(<span class="params">object</span>):</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kw</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = object.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">single1 = Single()</span><br><span class="line">single2 = Single()</span><br><span class="line">print(id(single1) == id(single2))</span><br></pre></td></tr></table></figure>

<h3 id="使用-元类metaclass-创建单例"><a href="#使用-元类metaclass-创建单例" class="headerlink" title="使用 元类metaclass 创建单例"></a>使用 元类<code>metaclass</code> 创建单例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params">type</span>):</span></span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> cls._instances:</span><br><span class="line">            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instances[cls]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cls4</span>(<span class="params">metaclass=Singleton</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">cls1 = Cls4()</span><br><span class="line">cls2 = Cls4()</span><br><span class="line">print(id(cls1) == id(cls2))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式python实现</title>
    <url>/2019/07/04/design_pattern/python/State_Pattern/</url>
    <content><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。  </li>
<li>2、自动售货机有不同的状态，并根据我们放入的钱币数量作出不同反应。根据我们的选择和放入的钱币，机器会执行以下操作。拒绝我们的选择，因为请求的货物已售罄; 拒绝我们的选择，因为放入的钱币不足; 递送货物，且不找零，因为放入的钱币恰好足够; 递送货物，并找零。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base state. This is to share functionality&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Scan the dial to the next station&quot;&quot;&quot;</span></span><br><span class="line">        self.pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.pos == len(self.stations):</span><br><span class="line">            self.pos = <span class="number">0</span></span><br><span class="line">        print(<span class="string">u&quot;Scanning... Station is %s %s&quot;</span> %</span><br><span class="line">              (self.stations[self.pos], self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AmState</span>(<span class="params">State</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radio</span>):</span></span><br><span class="line">        self.radio = radio</span><br><span class="line">        self.stations = [<span class="string">&quot;1250&quot;</span>, <span class="string">&quot;1380&quot;</span>, <span class="string">&quot;1510&quot;</span>]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.name = <span class="string">&quot;AM&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toggle_amfm</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">u&quot;Switching to FM&quot;</span>)</span><br><span class="line">        self.radio.state = self.radio.fmstate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FmState</span>(<span class="params">State</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radio</span>):</span></span><br><span class="line">        self.radio = radio</span><br><span class="line">        self.stations = [<span class="string">&quot;81.3&quot;</span>, <span class="string">&quot;89.1&quot;</span>, <span class="string">&quot;103.9&quot;</span>]</span><br><span class="line">        self.pos = <span class="number">0</span></span><br><span class="line">        self.name = <span class="string">&quot;FM&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toggle_amfm</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">u&quot;Switching to AM&quot;</span>)</span><br><span class="line">        self.radio.state = self.radio.amstate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Radio</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A radio.     It has a scan button, and an AM/FM toggle switch.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;We have an AM state and an FM state&quot;&quot;&quot;</span></span><br><span class="line">        self.amstate = AmState(self)</span><br><span class="line">        self.fmstate = FmState(self)</span><br><span class="line">        self.state = self.amstate</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toggle_amfm</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.state.toggle_amfm()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.state.scan()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Test our radio out</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    radio = Radio()</span><br><span class="line">    actions = [radio.scan] * <span class="number">2</span> + [radio.toggle_amfm] + [radio.scan] * <span class="number">2</span></span><br><span class="line">    actions *= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> action <span class="keyword">in</span> actions:</span><br><span class="line">        action()</span><br><span class="line"></span><br><span class="line"><span class="comment">### OUTPUT ###</span></span><br><span class="line"><span class="comment"># Scanning... Station is 1380 AM</span></span><br><span class="line"><span class="comment"># Scanning... Station is 1510 AM</span></span><br><span class="line"><span class="comment"># Switching to FM</span></span><br><span class="line"><span class="comment"># Scanning... Station is 89.1 FM</span></span><br><span class="line"><span class="comment"># Scanning... Station is 103.9 FM</span></span><br><span class="line"><span class="comment"># Scanning... Station is 81.3 FM</span></span><br><span class="line"><span class="comment"># Scanning... Station is 89.1 FM</span></span><br><span class="line"><span class="comment"># Switching to AM</span></span><br><span class="line"><span class="comment"># Scanning... Station is 1250 AM</span></span><br><span class="line"><span class="comment"># Scanning... Station is 1380 AM</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Strategy_Pattern/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>就是能够把一系列“可互换的”算法封装起来，并根据用户需求来选择其中一种。<br>我们可以通过这种模式将一个父类中会变化的部分提取并封装起来，以便此后可以轻易地改变或者扩展这部分，而不影响其他部分。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 </li>
<li>2、一个系统需要动态地在几种算法中选择一种。 </li>
<li>3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="策略模式-1"><a href="#策略模式-1" class="headerlink" title="策略模式"></a>策略模式</h3><p>模拟一款游戏，里面有各种各样的鸭子，这里我们只设计两种，一种是会飞的鸭子，另一种是会叫的鸭子。</p>
<p>在策略模式中，有几种不同的行为就定义几个不同的接口，这里我们把会飞、不会飞、会用羽毛飞等统一称为一种行为，即飞行行为；把会呱呱叫、会哇哇叫等统一称为另一种行为，即会叫的行为。</p>
<p>首先，定义第一种行为接口，飞行行为接口，飞行行为下的不同种类都实现这个接口，以表示不同的飞行行为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBehavior</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;所有飞行行为都必须实现该类的fly方法&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyDuckWithWings</span>(<span class="params">FlyBehavior</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;会用羽毛飞的鸭子继承飞行行为类，实现飞行接口&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;老子有羽毛，老子会飞，你们会么。2333333。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyDuckNoWay</span>(<span class="params">FlyBehavior</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;不会飞的鸭子，继承飞行行为类，实现飞行接口&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我不会飞，坐在角落里诅咒你们掉下来。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>接着定义鸭叫这个行为接口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuackBehavior</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;呱呱叫的行为接口类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuckQuackGua</span>(<span class="params">QuackBehavior</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;只会呱呱叫的鸭子&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;看见美鸭，我会呱呱叫。呱呱呱......&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuckQuackWa</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;只会哇哇叫的鸭子&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;看见帅鸭，我会哇哇叫。哇哇哇......&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这两种行为类定义完成，并有行为子类定义完成之后，就要定义鸭子类型了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;鸭子对象&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 为了简单说明，在这里直接放置两个参数，如果大家想要更好的实现，可以使用set方法进行设置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fly_duck, quack_duck</span>):</span></span><br><span class="line">        self.fly_duck = fly_duck</span><br><span class="line">        self.quack_duck = quack_duck</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.fly_duck.fly()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.quack_duck.quack()</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fly_gua_duck = Duck(FlyDuckWithWings(), DuckQuackGua())  <span class="comment"># 创建一个会飞会呱的鸭子</span></span><br><span class="line">    fly_gua_duck.fly()</span><br><span class="line">    fly_gua_duck.quack()</span><br><span class="line"></span><br><span class="line">    no_fly_wa_duck = Duck(FlyDuckNoWay(), DuckQuackWa())  <span class="comment"># 创建一个不会飞，只会哇哇叫的鸭子</span></span><br><span class="line">    no_fly_wa_duck.fly()</span><br><span class="line">    no_fly_wa_duck.quack()</span><br></pre></td></tr></table></figure>

<p>在上面，我们测试时，使用了类的实例。我们继续精简一下，使用静态方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyBehavior</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;所有会飞的行为都必须继承该类，并实现其fly方法&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>():</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyDuckWithWings</span>(<span class="params">FlyBehavior</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;会飞的鸭子继承会飞行为类，实现飞行接口&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>():</span></span><br><span class="line">        print(<span class="string">&quot;老子有羽毛，老子会飞，你们会么。2333333。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyDuckNoWay</span>(<span class="params">FlyBehavior</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;不会飞的鸭子，继承飞行行为类，实现飞行接口&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span>():</span></span><br><span class="line">        print(<span class="string">&quot;我不会飞，坐在角落里诅咒你们掉下来。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，我们在测试的时候，传入类就可以了，无需实例出一个对象来。</p>
<p>好像这种方式也不是很好，接下来，我们使用函数来实现这种行为。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;鸭子对象&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fly_duck, quack_duck</span>):</span></span><br><span class="line">        self.fly_duck = fly_duck</span><br><span class="line">        self.quack_duck = quack_duck</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fly_with_wings</span>():</span></span><br><span class="line">    print(<span class="string">&quot;老子有羽毛，老子会飞，你们会么。2333333。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fly_no_way</span>():</span></span><br><span class="line">    print(<span class="string">&quot;我不会飞，坐在角落里诅咒你们掉下来。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quack_gua</span>():</span></span><br><span class="line">    print(<span class="string">&quot;看见美鸭，我会呱呱叫。呱呱呱......&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quack_wa</span>():</span></span><br><span class="line">    print(<span class="string">&quot;看见帅鸭，我会哇哇叫。哇哇哇......&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fly_gua_duck = Duck(fly_with_wings(), quack_gua())  <span class="comment"># 创建一个会飞会呱的鸭子</span></span><br><span class="line">    fly_gua_duck.fly</span><br><span class="line">    fly_gua_duck.quack</span><br><span class="line"></span><br><span class="line">    no_fly_wa_duck = Duck(fly_no_way(), quack_wa())</span><br><span class="line">    no_fly_wa_duck.fly</span><br><span class="line">    no_fly_wa_duck.quack</span><br></pre></td></tr></table></figure>
<p>继续精简。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;鸭子对象&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fly_duck, quack_duck</span>):</span></span><br><span class="line">        self.fly_duck = fly_duck</span><br><span class="line">        self.quack_duck = quack_duck</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fly_with_wings</span>():</span></span><br><span class="line">    print(<span class="string">&quot;老子有羽毛，老子会飞，你们会么。2333333。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fly_no_way</span>():</span></span><br><span class="line">    print(<span class="string">&quot;我不会飞，坐在角落里诅咒你们掉下来。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quack_gua</span>():</span></span><br><span class="line">    print(<span class="string">&quot;看见美鸭，我会呱呱叫。呱呱呱......&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quack_wa</span>():</span></span><br><span class="line">    print(<span class="string">&quot;看见帅鸭，我会哇哇叫。哇哇哇......&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fly_gua_duck = Duck(fly_with_wings, quack_gua)  <span class="comment"># 创建一个会飞会呱的鸭子</span></span><br><span class="line">    fly_gua_duck.fly_duck()</span><br><span class="line">    fly_gua_duck.quack_duck()</span><br><span class="line">    no_fly_wa_duck = Duck(fly_no_way, quack_wa)</span><br><span class="line">    no_fly_wa_duck.fly_duck()</span><br><span class="line">    no_fly_wa_duck.quack_duck()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>模板模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Template_Pattern/</url>
    <content><![CDATA[<h1 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>1、有多个子类共有的方法，且逻辑相同。 </li>
<li>2、重要的、复杂的方法，可以考虑作为模板方法。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="模板模式-1"><a href="#模板模式-1" class="headerlink" title="模板模式"></a>模板模式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 茶的制作方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepare_recipe</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 在下边实现具体步骤</span></span><br><span class="line">        self.boil_water()</span><br><span class="line">        self.brew_tea_bag()</span><br><span class="line">        self.pour_in_cup()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">boil_water</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Boiling water&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brew_tea_bag</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Steeping the tea&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pour_in_cup</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Pouring into cup&quot;</span>)</span><br><span class="line"><span class="comment"># 咖啡的制作方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepare_recipe</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 在下边实现具体步骤</span></span><br><span class="line">        self.boil_water()</span><br><span class="line">        self.brew_coffee_grinds()</span><br><span class="line">        self.pour_in_cup()</span><br><span class="line">        self.add_sugar_and_milk()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">boil_water</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Boiling water&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brew_coffee_grinds</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Dripping Coffee through filter&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pour_in_cup</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Pouring into cup&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_sugar_and_milk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Adding Sugar and Milk&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模板模式改后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeineBeverage</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prepare_recipe</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 新的实现方法</span></span><br><span class="line">        self.boil_water()</span><br><span class="line">        self.brew() </span><br><span class="line">        self.pour_in_cup()</span><br><span class="line">        self.add_condiments()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">boil_water</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Boiling water&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brew</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 需要在子类实现</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pour_in_cup</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Pouring into cup&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_condiments</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 这里其实是个钩子方法，子类可以视情况选择是否覆盖</span></span><br><span class="line">        <span class="comment"># 钩子方法是一个可选方法，也可以让钩子方法作为某些条件触发后的动作</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 茶的制作方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span>(<span class="params">CoffeineBeverage</span>):</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brew</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 父类中声明了 raise NotImplementedError，这里必须要实现此方法</span></span><br><span class="line">        print(<span class="string">&quot;Steeping the tea&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Tea 不需要 add_condiments 方法，所以这里不需要实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 咖啡的制作方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span>(<span class="params">CoffeineBeverage</span>):</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brew</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 父类中声明了 raise NotImplementedError，这里必须要实现此方法</span></span><br><span class="line">        print(<span class="string">&quot;Dripping Coffee through filter&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_condiments</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Adding Sugar and Milk&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式python实现</title>
    <url>/2019/07/04/design_pattern/python/Visitor_Pattern/</url>
    <content><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<a id="more"></a>

<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><ul>
<li>1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 </li>
<li>2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="访问者模式-1"><a href="#访问者模式-1" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>你要处理由大量不同类型的对象组成的复杂数据结构，每一个对象都需要进行不同的处理。 比如，遍历一个树形结构，然后根据每个节点的相应状态执行不同的操作。</p>
<p>这里遇到的问题在编程领域中是很普遍的，有时候会构建一个由大量不同对象组成的数据结构。 假设你要写一个表示数学表达式的程序，那么你可能需要定义如下的类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnaryOperator</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, operand</span>):</span></span><br><span class="line">        self.operand = operand</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryOperator</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span>(<span class="params">BinaryOperator</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>(<span class="params">BinaryOperator</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mul</span>(<span class="params">BinaryOperator</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Div</span>(<span class="params">BinaryOperator</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Negate</span>(<span class="params">UnaryOperator</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br></pre></td></tr></table></figure>

<p>然后利用这些类构建嵌套数据结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Representation of 1 + 2 * (3 - 4) / 5</span></span><br><span class="line">t1 = Sub(Number(<span class="number">3</span>), Number(<span class="number">4</span>))</span><br><span class="line">t2 = Mul(Number(<span class="number">2</span>), t1)</span><br><span class="line">t3 = Div(t2, Number(<span class="number">5</span>))</span><br><span class="line">t4 = Add(Number(<span class="number">1</span>), t3)</span><br></pre></td></tr></table></figure>
<p>这样做的问题是对于每个表达式，每次都要重新定义一遍，有没有一种更通用的方式让它支持所有的数字和操作符呢。 这里我们使用访问者模式可以达到这样的目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeVisitor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        methname = <span class="string">&#x27;visit_&#x27;</span> + type(node).__name__</span><br><span class="line">        meth = getattr(self, methname, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> meth <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            meth = self.generic_visit</span><br><span class="line">        <span class="keyword">return</span> meth(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generic_visit</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;No &#123;&#125; method&#x27;</span>.format(<span class="string">&#x27;visit_&#x27;</span> + type(node).__name__))</span><br></pre></td></tr></table></figure>
<p>为了使用这个类，可以定义一个类继承它并且实现各种<code> visit_Name()</code> 方法，其中Name是node类型。 例如，如果你想求表达式的值，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evaluator</span>(<span class="params">NodeVisitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Number</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Add</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) + self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Sub</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) - self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Mul</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) * self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Div</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.visit(node.left) / self.visit(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Negate</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">return</span> -node.operand</span><br><span class="line"></span><br><span class="line"><span class="comment"># e = Evaluator()</span></span><br><span class="line"><span class="comment"># e.visit(t4) # 0.6</span></span><br></pre></td></tr></table></figure>

<p>作为一个不同的例子，下面定义一个类在一个栈上面将一个表达式转换成多个操作序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCode</span>(<span class="params">NodeVisitor</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_code</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.instructions = []</span><br><span class="line">        self.visit(node)</span><br><span class="line">        <span class="keyword">return</span> self.instructions</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Number</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.instructions.append((<span class="string">&#x27;PUSH&#x27;</span>, node.value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binop</span>(<span class="params">self, node, instruction</span>):</span></span><br><span class="line">        self.visit(node.left)</span><br><span class="line">        self.visit(node.right)</span><br><span class="line">        self.instructions.append((instruction,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Add</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.binop(node, <span class="string">&#x27;ADD&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Sub</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.binop(node, <span class="string">&#x27;SUB&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Mul</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.binop(node, <span class="string">&#x27;MUL&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Div</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.binop(node, <span class="string">&#x27;DIV&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unaryop</span>(<span class="params">self, node, instruction</span>):</span></span><br><span class="line">        self.visit(node.operand)</span><br><span class="line">        self.instructions.append((instruction,))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit_Negate</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.unaryop(node, <span class="string">&#x27;NEG&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># s = StackCode()</span></span><br><span class="line"><span class="comment"># s.generate_code(t4)</span></span><br><span class="line"><span class="comment"># [(&#x27;PUSH&#x27;, 1), (&#x27;PUSH&#x27;, 2), (&#x27;PUSH&#x27;, 3), (&#x27;PUSH&#x27;, 4), (&#x27;SUB&#x27;,),</span></span><br><span class="line">(<span class="string">&#x27;MUL&#x27;</span>,), (<span class="string">&#x27;PUSH&#x27;</span>, <span class="number">5</span>), (<span class="string">&#x27;DIV&#x27;</span>,), (<span class="string">&#x27;ADD&#x27;</span>,)]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>设计模式python实现</tag>
      </tags>
  </entry>
  <entry>
    <title>38.报数</title>
    <url>/2019/07/04/leetcode/38/</url>
    <content><![CDATA[<p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。</p>
<a id="more"></a>

<p>其前五项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure>
<p><code>1</code> 被读作  “<code>one 1</code>“  (“<code>一个一</code>“) , 即 <code>11</code>。<br><code>11</code> 被读作 “<code>two 1s</code>“ (“<code>两个一</code>“）, 即 <code>21</code>。<br><code>21</code> 被读作 “<code>one 2</code>“,  “<code>one 1</code>“ （”<code>一个二</code>“ ,  “<code>一个一</code>“) , 即 <code>1211</code>。</p>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。</p>
<p>注意：整数顺序将表示为一个字符串。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rlt []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			rlt = <span class="built_in">append</span>(rlt, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> i == <span class="number">1</span> &#123;</span><br><span class="line">			rlt = <span class="built_in">append</span>(rlt, <span class="string">&quot;11&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			preintstring := rlt[i<span class="number">-1</span>]</span><br><span class="line">			<span class="keyword">var</span> nextintstring <span class="keyword">string</span></span><br><span class="line">			temp := <span class="keyword">string</span>(preintstring[<span class="number">0</span>])</span><br><span class="line">			index := <span class="number">0</span></span><br><span class="line">			<span class="keyword">for</span> i, v := <span class="keyword">range</span> preintstring &#123;</span><br><span class="line">				<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">				countDiffNum := <span class="number">1</span></span><br><span class="line">				<span class="keyword">if</span> <span class="keyword">string</span>(v) != temp &#123;</span><br><span class="line">					countDiffNum = i - index</span><br><span class="line">					index = i</span><br><span class="line">					nextintstring += strconv.Itoa(countDiffNum) + <span class="keyword">string</span>(temp)</span><br><span class="line">					temp = <span class="keyword">string</span>(v)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> i == <span class="built_in">len</span>(preintstring)<span class="number">-1</span> &#123;</span><br><span class="line">					countDiffNum = i - index + <span class="number">1</span></span><br><span class="line">					index = i</span><br><span class="line">					nextintstring += strconv.Itoa(countDiffNum) + <span class="keyword">string</span>(temp)</span><br><span class="line">					temp = <span class="keyword">string</span>(v)</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			rlt = <span class="built_in">append</span>(rlt, nextintstring)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rlt[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>tags</title>
    <url>/2019/07/04/golang/useful_tags/</url>
    <content><![CDATA[<h1 id="tags-标签在golang-中有什么作用？"><a href="#tags-标签在golang-中有什么作用？" class="headerlink" title="tags 标签在golang 中有什么作用？"></a>tags 标签在golang 中有什么作用？</h1><p>字段标记允许您将元信息附加到可以使用反射获取的字段上。通常，它用于提供有关如何将结构域编码为另一种格式（或从另一种格式存储（或从数据库中检索））的转换信息，但是您可以使用它存储想要存储的任何元信息，这些元信息既可以用于另一种包装或供您自己使用。</p>
<a id="more"></a>

<blockquote>
<p><code>key</code> 通常表示包，<code>json</code>这个<code>key</code>就表示<code>encoding/json</code>这个包</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot; xml:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果在 <code>tag</code>中传递多个信息的<code>value</code>，通常使用<code>,</code>进行分隔，</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot; xml:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常用破折号 <code>-</code> 表示将字段从<code>value</code>中排除</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:&quot;-,&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用反射访问自定义标签"><a href="#使用反射访问自定义标签" class="headerlink" title="使用反射访问自定义标签"></a>使用反射访问自定义标签</h1><p>可以使用反射<code>reflect</code>来访问结构字段的标记值。基本上，我们需要获取<code>Type</code>的结构，然后可以使用<code>Type.Field(i int)</code>或<code>Type.FieldByName(name string)</code>查询字段。这些方法返回的值<code>StructField</code>描述/表示一个<code>struct</code>字段；并且<code>StructField.Tag</code>是<code>StructTag</code>描述/表示标记值的类型值。</p>
<p>以前我们谈论过“惯例”。这种约定意味着，如果你遵循它，你可以使用<code>StructTag.Get(key string)</code>它解析变量的值，并返回该方法<code>&quot;value&quot;</code>的<code>key</code>指定。该公约实施/内置到这个<code>Get()</code>方法。如果您不遵循约定，<code>Get()</code>将无法解析<code>key:&quot;value&quot;</code>对并找到您要查找的内容。这也不是问题，但是您需要实现自己的解析逻辑。</p>
<p>还有<code>StructTag.Lookup()</code>（在Go 1.7中添加了），它类似于，<code>Get()</code>但是将不包含给定键的标签与将空字符串与给定键相关联的标签区分开”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name  <span class="keyword">string</span> <span class="string">`mytag:&quot;MyName&quot;`</span></span><br><span class="line">    Email <span class="keyword">string</span> <span class="string">`mytag:&quot;MyEmail&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := User&#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;bob@mycompany.com&quot;</span>&#125;</span><br><span class="line">t := reflect.TypeOf(u)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, fieldName := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Email&quot;</span>&#125; &#123;</span><br><span class="line">    field, found := t.FieldByName(fieldName)</span><br><span class="line">    <span class="keyword">if</span> !found &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\nField: User.%s\n&quot;</span>, fieldName)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\tWhole tag value : %q\n&quot;</span>, field.Tag)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;\tValue of &#x27;mytag&#x27;: %q\n&quot;</span>, field.Tag.Get(<span class="string">&quot;mytag&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Field: User.Name</span><br><span class="line">    Whole tag value : <span class="string">&quot;mytag:\&quot;MyName\&quot;&quot;</span></span><br><span class="line">    Value of <span class="string">&#x27;mytag&#x27;</span>: <span class="string">&quot;MyName&quot;</span></span><br><span class="line"></span><br><span class="line">Field: User.Email</span><br><span class="line">    Whole tag value : <span class="string">&quot;mytag:\&quot;MyEmail\&quot;&quot;</span></span><br><span class="line">    Value of <span class="string">&#x27;mytag&#x27;</span>: <span class="string">&quot;MyEmail&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>slice 与 interface 之间的转换</title>
    <url>/2019/07/04/golang/type_converting_slices_of_interfaces/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>4.寻找两个有序数组的中位数</title>
    <url>/2019/07/04/leetcode/4/</url>
    <content><![CDATA[<p>给定两个大小为 m 和 n 的有序数组 <code>nums1</code> 和 <code>nums2</code>。</p>
<p>请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p>
<p>你可以假设<code>nums1</code> 和 <code>nums2</code> 不会同时为空。</p>
<a id="more"></a>

<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line">则中位数是 2.0</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line">则中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>


<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMedianSortedArrays</span><span class="params">(nums1 []<span class="keyword">int</span>, nums2 []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    all := <span class="built_in">append</span>(nums1, nums2...)</span><br><span class="line">    sort.Ints(all)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(all)%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    a := all[<span class="built_in">len</span>(all)/<span class="number">2</span>]</span><br><span class="line">    b := all[<span class="built_in">len</span>(all)/<span class="number">2</span><span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float64</span>(a) + <span class="keyword">float64</span>(b)) / <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(all[(<span class="built_in">len</span>(all)<span class="number">-1</span>)/<span class="number">2</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>利用多线程在Go中更快地读取大文件</title>
    <url>/2019/07/04/golang/read_large_files_faster/</url>
    <content><![CDATA[<h1 id="利用多线程在Go中更快地读取大文件"><a href="#利用多线程在Go中更快地读取大文件" class="headerlink" title="利用多线程在Go中更快地读取大文件"></a>利用多线程在Go中更快地读取大文件</h1><p>如何计算具有4gb RAM的50gb文件中单词的出现次数。窍门是不将整个文件加载到内存中，而是在继续移动文件指针时继续处理每个单词。这样，我们可以用最少的内存资源轻松处理整个文件。</p>
<p>现在的后续问题是我们如何使用多线程来加快此过程？解决方案是我们在文件的不同部分保留多个指针，并且每个线程同时读取文件的块。</p>
<p>最后，结果可以合并。</p>
<a id="more"></a>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>假设文件的大小为1GB。5个线程中的每个线程将处理200MB。连续指针将从上一个指针的最后一个读取字节的字节开始读取。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mb = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line"><span class="keyword">const</span> gb = <span class="number">1024</span> * mb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// A waitgroup to wait for all go-routines to finish.</span></span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This channel is used to send every read word in various go-routines.</span></span><br><span class="line">	channel := <span class="built_in">make</span>(<span class="keyword">chan</span> (<span class="keyword">string</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A dictionary which stores the count of unique words.</span></span><br><span class="line">	dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int64</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Done is a channel to signal the main thread that all the words have been</span></span><br><span class="line">	<span class="comment">// entered in the dictionary.</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> (<span class="keyword">bool</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read all incoming words from the channel and add them to the dictionary.</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> s := <span class="keyword">range</span> channel &#123;</span><br><span class="line">			dict[s]++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Signal the main thread that all the words have entered the dictionary.</span></span><br><span class="line">		done &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Current signifies the counter for bytes of the file.</span></span><br><span class="line">	<span class="keyword">var</span> current <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Limit signifies the chunk size of file to be processed by every thread.</span></span><br><span class="line">	<span class="keyword">var</span> limit <span class="keyword">int64</span> = <span class="number">500</span> * mb</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			read(current, limit, <span class="string">&quot;gameofthrones.txt&quot;</span>, channel)</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%d thread has been completed \n&quot;</span>, i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Increment the current by 1+(last byte read by previous thread).</span></span><br><span class="line">		current += limit + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for all go routines to complete.</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(channel)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for dictionary to process all the words.</span></span><br><span class="line">	&lt;-done</span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(offset <span class="keyword">int64</span>, limit <span class="keyword">int64</span>, fileName <span class="keyword">string</span>, channel <span class="keyword">chan</span> (<span class="keyword">string</span>)</span>)</span> &#123;</span><br><span class="line">	file, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Move the pointer of the file to the start of designated chunk.</span></span><br><span class="line">	file.Seek(offset, <span class="number">0</span>)</span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This block of code ensures that the start of chunk is a new word. If</span></span><br><span class="line">	<span class="comment">// a character is encountered at the given position it moves a few bytes till</span></span><br><span class="line">	<span class="comment">// the end of the word.</span></span><br><span class="line">	<span class="keyword">if</span> offset != <span class="number">0</span> &#123;</span><br><span class="line">		_, err = reader.ReadBytes(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;EOF&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cummulativeSize <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// Break if read size has exceed the chunk size.</span></span><br><span class="line">		<span class="keyword">if</span> cummulativeSize &gt; limit &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		b, err := reader.ReadBytes(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Break if end of file is encountered.</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cummulativeSize += <span class="keyword">int64</span>(<span class="built_in">len</span>(b))</span><br><span class="line">		s := strings.TrimSpace(<span class="keyword">string</span>(b))</span><br><span class="line">		<span class="keyword">if</span> s != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="comment">// Send the read word in the channel to enter into dictionary.</span></span><br><span class="line">			channel &lt;- s</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在这里，我们还必须处理边缘情况。如果块的开头不是新单词的开头怎么办。类似地，如果块的结尾不是块的结尾怎么办。</p>
<p>我们通过将块的末尾扩展到单词的末尾并将连续块的开头移到下一个单词的开头来处理此问题。</p>
<p>我们正在使用渠道将各个线程读取的所有单词统一到一个字典中。同步。Waitgroup可用于线程同步，并确保所有线程都已完成文件读取</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>与串行方式相比，可以观察到性能提高了一倍，同时处理1GB文件所需的时间减少了一半。</p>
<p>我们之所以无法获得5倍的性能（即线程数），是因为尽管goroutine是轻量级的线程，但读取文件的过程需要一个完整os级CPU内核的资源。它没有睡眠时间。因此，在双核系统上，它只能有效地使文件处理性能提高一倍。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>413. 等差数列划分</title>
    <url>/2019/07/04/leetcode/413/</url>
    <content><![CDATA[<p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p>
<a id="more"></a>

<p>例如，以下数列为等差数列:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 3, 5, 7, 9</span><br><span class="line">7, 7, 7, 7</span><br><span class="line">3, -1, -5, -9</span><br></pre></td></tr></table></figure>
<p>以下数列不是等差数列。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 1, 2, 5, 7</span><br></pre></td></tr></table></figure>

<p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p>
<p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p>
<p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p>
<p>函数要返回数组 A 中所有为等差数组的子数组个数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</span><br></pre></td></tr></table></figure>


<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(A)== <span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	res :=<span class="number">0</span></span><br><span class="line">	add :=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">2</span>;i&lt;<span class="built_in">len</span>(A);i++&#123;</span><br><span class="line">		<span class="keyword">if</span> A[i<span class="number">-1</span>]-A[i]==A[i<span class="number">-2</span>]-A[i<span class="number">-1</span>]&#123;</span><br><span class="line">			add+=<span class="number">1</span></span><br><span class="line">			res+=add</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			add=<span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>5.最长回文子串</title>
    <url>/2019/07/04/leetcode/5/</url>
    <content><![CDATA[<p>给定一个字符串<code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<a id="more"></a>

<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        str_length = len(s)</span><br><span class="line">        max_length = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(str_length):</span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">1</span> <span class="keyword">and</span> s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>] == s[i-max_length<span class="number">-1</span>: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                start = i - max_length - <span class="number">1</span></span><br><span class="line">                max_length += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i - max_length &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i-max_length: i+<span class="number">1</span>] == s[i-max_length: i+<span class="number">1</span>][::<span class="number">-1</span>]:</span><br><span class="line">                start = i - max_length</span><br><span class="line">                max_length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> s[start: start + max_length]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2019/07/04/network/http_status_code/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="http-状态码对应表"><a href="#http-状态码对应表" class="headerlink" title="http 状态码对应表"></a><center>http 状态码对应表</center></h1><table>
<thead>
<tr>
<th>状态码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td align="left">客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</td>
</tr>
<tr>
<td>101</td>
<td align="left">服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 　　只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</td>
</tr>
<tr>
<td>102</td>
<td align="left">由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</td>
</tr>
<tr>
<td>200</td>
<td align="left">请求已成功，请求所希望的响应头或数据体将随此响应返回。</td>
</tr>
<tr>
<td>201</td>
<td align="left">请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</td>
</tr>
<tr>
<td>202</td>
<td align="left">服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 　　返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td>
</tr>
<tr>
<td>203</td>
<td align="left">服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</td>
</tr>
<tr>
<td>204</td>
<td align="left">服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 　　如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 　　由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</td>
</tr>
<tr>
<td>205</td>
<td align="left">服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 　　与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</td>
</tr>
<tr>
<td>206</td>
<td align="left">服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 　　该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 　　响应必须包含如下的头部域： 　　Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 　　Date 　　ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 　　Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 　　假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 　　任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。</td>
</tr>
<tr>
<td>207</td>
<td align="left">由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</td>
</tr>
<tr>
<td>300</td>
<td align="left">被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 　　除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 　　如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</td>
</tr>
<tr>
<td>301</td>
<td align="left">被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 　　新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</td>
</tr>
<tr>
<td>302</td>
<td align="left">请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 　　注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</td>
</tr>
<tr>
<td>303</td>
<td align="left">对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 　　新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 　　注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</td>
</tr>
<tr>
<td>304</td>
<td align="left">如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 　　该响应必须包含以下的头信息： 　　Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 　　ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 　　Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 　　假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 　　假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 　　假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</td>
</tr>
<tr>
<td>305</td>
<td align="left">被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 　　注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</td>
</tr>
<tr>
<td>306</td>
<td align="left">在最新版的规范中，306状态码已经不再被使用。</td>
</tr>
<tr>
<td>307</td>
<td align="left">请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 　　新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 　　如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</td>
</tr>
<tr>
<td>400</td>
<td align="left">1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 　　2、请求参数有误。</td>
</tr>
<tr>
<td>401</td>
<td align="left">当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</td>
</tr>
<tr>
<td>402</td>
<td align="left">该状态码是为了将来可能的需求而预留的。</td>
</tr>
<tr>
<td>403</td>
<td align="left">服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</td>
</tr>
<tr>
<td>404</td>
<td align="left">请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</td>
</tr>
<tr>
<td>405</td>
<td align="left">请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 　　鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</td>
</tr>
<tr>
<td>406</td>
<td align="left">请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 　　除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</td>
</tr>
<tr>
<td>407</td>
<td align="left">与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</td>
</tr>
<tr>
<td>408</td>
<td align="left">请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</td>
</tr>
<tr>
<td>409</td>
<td align="left">由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 　　冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</td>
</tr>
<tr>
<td>410</td>
<td align="left">被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 　　410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</td>
</tr>
<tr>
<td>411</td>
<td align="left">服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</td>
</tr>
<tr>
<td>412</td>
<td align="left">服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</td>
</tr>
<tr>
<td>413</td>
<td align="left">服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 　　如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</td>
</tr>
<tr>
<td>414</td>
<td align="left">请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 　　本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 　　重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 　　客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</td>
</tr>
<tr>
<td>415</td>
<td align="left">对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</td>
</tr>
<tr>
<td>416</td>
<td align="left">如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 　　假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。</td>
</tr>
<tr>
<td>417</td>
<td align="left">在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</td>
</tr>
<tr>
<td>421</td>
<td align="left">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td align="left">从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</td>
</tr>
<tr>
<td>422</td>
<td align="left">请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 　　当前资源被锁定。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>424</td>
<td align="left">由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</td>
</tr>
<tr>
<td>425</td>
<td align="left">在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</td>
</tr>
<tr>
<td>426</td>
<td align="left">客户端应当切换到TLS/1.0。（RFC 2817）</td>
</tr>
<tr>
<td>449</td>
<td align="left">由微软扩展，代表请求应当在执行完适当的操作后进行重试。</td>
</tr>
<tr>
<td>500</td>
<td align="left">服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</td>
</tr>
<tr>
<td>501</td>
<td align="left">服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</td>
</tr>
<tr>
<td>502</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</td>
</tr>
<tr>
<td>503</td>
<td align="left">由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 　　注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</td>
</tr>
<tr>
<td>504</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 　　注意：某些代理服务器在DNS查询超时时会返回400或者500错误</td>
</tr>
<tr>
<td>505</td>
<td align="left">服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</td>
</tr>
<tr>
<td>506</td>
<td align="left">由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</td>
</tr>
<tr>
<td>507</td>
<td align="left">服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</td>
</tr>
<tr>
<td>509</td>
<td align="left">服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</td>
</tr>
<tr>
<td>510</td>
<td align="left">获取资源所需要的策略并没有没满足。（RFC 2774）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>编写django脚本，使用django的数据库连接</title>
    <url>/2019/07/04/python/django_script/</url>
    <content><![CDATA[<p>针对django的项目，想编写脚本针对数据进行批量处理，通过导入以下几个包，即可编写python脚本来通过django的数据库连接操作</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line">    sys.path.append(<span class="string">&quot;&#123;工程目录&#125;&quot;</span>)</span><br><span class="line">    os.environ.setdefault(<span class="string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="string">&quot;saplatform.settings&quot;</span>)</span><br><span class="line">    django.setup()</span><br><span class="line">    <span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line">    <span class="comment"># User数据操作</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层协议模型、TCP/IP四层模型</title>
    <url>/2019/07/04/network/OSI_seven_layer/</url>
    <content><![CDATA[<h1 id="OSI七层协议模型、TCP-IP四层模型"><a href="#OSI七层协议模型、TCP-IP四层模型" class="headerlink" title="OSI七层协议模型、TCP/IP四层模型"></a>OSI七层协议模型、TCP/IP四层模型</h1><a id="more"></a>

<h3 id="OSI七层和TCP-IP四层的关系"><a href="#OSI七层和TCP-IP四层的关系" class="headerlink" title="OSI七层和TCP/IP四层的关系"></a>OSI七层和TCP/IP四层的关系</h3><ol>
<li>OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</li>
<li>OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。</li>
<li>OSI是一种理论下的模型，而TCP/IP已被广泛使用，成为网络互联事实上的标准。</li>
</ol>
<blockquote>
<p>TCP：transmission control protocol 传输控制协议<br>UDP：user data protocol 用户数据报协议</p>
</blockquote>
<table>
    <thead>
        <tr>
            <th>OSI 七层网络模型 </th>
            <th>TCP/IP 四层概念模型 </th>
            <th> </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>应用层（Application）</td>
            <td rowspan="3">应用层 </td>
            <td>HTTP、TFTP, FTP, NFS, WAIS、SMTP </td>
        </tr>
        <tr>
            <td>表示层（Presentation）</td>
            <td>Telnet, Rlogin, SNMP, Gopher </td>
        </tr>
        <tr>
            <td>会话层（Session）</td>
            <td>SMTP, DNS </td>
        </tr>
        <tr>
            <td>传输层（Transport）</td>
            <td>传输层 </td>
            <td> TCP, UDP</td>
        </tr>
        <tr>
            <td>网络层（Network）</td>
            <td> 网络层</td>
            <td> IP, ICMP, ARP, RARP, AKP, UUCP</td>
        </tr>
        <tr>
            <td>数据链路层（Data Link）</td>
            <td rowspan="2">数据链路层 </td>
            <td> FDDI, Ethernet, Arpanet, PDN, SLIP, PPP</td>
        </tr>
        <tr>
            <td>物理层（Physical）</td>
            <td>IEEE 802.1A, IEEE 802.2到IEEE 802.11 </td>
        </tr>
    </tbody>
</table>


<h3 id="OSI七层协议模型"><a href="#OSI七层协议模型" class="headerlink" title="OSI七层协议模型"></a>OSI七层协议模型</h3><p>七层结构记忆方法：应、表、会、传、网、数、物</p>
<p>应用层协议需要掌握的是：HTTP（Hyper text transfer protocol）、FTP（file transfer protocol）、SMTP（simple mail transfer rotocol）、POP3（post office protocol 3）、IMAP4（Internet mail access protocol）</p>
<p><img src="/images/network/%E5%9B%BE1.jpeg" alt="图 1 "></p>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><p><img src="/images/network/%E5%9B%BE2.jpeg" alt="图 2 "></p>
<h4 id="数据包说明"><a href="#数据包说明" class="headerlink" title="数据包说明"></a>数据包说明</h4><p><img src="/images/network/%E5%9B%BE3.gif" alt="图 3 "><br><img src="/images/network/%E5%9B%BE4.jpeg" alt="图 4 "></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2019/07/04/linux/git/</url>
    <content><![CDATA[<blockquote>
<p>Git常用命令集合，Fork于<a class="link"   href="https://github.com/git-tips/tips" >tips<i class="fas fa-external-link-alt"></i></a>项目</p>
</blockquote>
<p>Git是一个 “分布式版本管理工具”，简单的理解版本管理工具：大家在写东西的时候都用过 “回撤” 这个功能，但是回撤只能回撤几步，假如想要找回我三天之前的修改，光用 “回撤” 是找不回来的。而 “版本管理工具” 能记录每次的修改，只要提交到版本仓库，你就可以找到之前任何时刻的状态（文本状态）。</p>
<p>下面的内容就是列举了常用的 Git 命令和一些小技巧，可以通过 “页面内查找” 的方式进行快速查询：<code>Ctrl/Command+f</code>。</p>
<a id="more"></a>

<h2 id="开卷必读"><a href="#开卷必读" class="headerlink" title="开卷必读"></a>开卷必读</h2><p><em>如果之前未使用过 Git，可以学习 <a class="link"   href="http://rogerdudler.github.io/git-guide/index.zh.html" >Git 小白教程<i class="fas fa-external-link-alt"></i></a>入门</em></p>
<ol>
<li><strong>一定要先测试命令的效果后</strong>，再用于工作环境中，以防造成不能弥补的后果！<strong>到时候别拿着砍刀来找我</strong></li>
<li>所有的命令都在<code>git version 2.7.4 (Apple Git-66)</code>下测试通过</li>
<li>统一概念：<ul>
<li>工作区：改动（增删文件和内容）</li>
<li>暂存区：输入命令：<code>git add 改动的文件名</code>，此次改动就放到了 ‘暂存区’</li>
<li>本地仓库(简称：本地)：输入命令：<code>git commit 此次修改的描述</code>，此次改动就放到了 ’本地仓库’，每个 commit，我叫它为一个 ‘版本’。</li>
<li>远程仓库(简称：远程)：输入命令：<code>git push 远程仓库</code>，此次改动就放到了 ‘远程仓库’（GitHub 等)</li>
<li>commit-id：输出命令：<code>git log</code>，最上面那行 <code>commit xxxxxx</code>，后面的字符串就是 commit-id</li>
</ul>
</li>
<li>如果喜欢这个项目，欢迎 Star、提交 Pr、<a class="link"   href="https://github.com/521xueweihan/git-tips/issues" >反馈问题<i class="fas fa-external-link-alt"></i></a>😊</li>
</ol>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%B1%95%E7%A4%BA%E5%B8%AE%E5%8A%A9%E4%BF%A1%E6%81%AF">展示帮助信息</a></li>
<li><a href="#%E5%9B%9E%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E7%8A%B6%E6%80%81">回到远程仓库的状态</a></li>
<li><a href="#%E9%87%8D%E8%AE%BE%E7%AC%AC%E4%B8%80%E4%B8%AAcommit">重设第一个commit</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E4%B8%8D%E5%90%8C">展示工作区和暂存区的不同</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E6%9A%82%E5%AD%98%E5%8C%BA%E5%92%8C%E6%9C%80%E8%BF%91%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%8D%E5%90%8C">展示暂存区和最近版本的不同</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E6%9A%82%E5%AD%98%E5%8C%BA%E5%B7%A5%E4%BD%9C%E5%8C%BA%E5%92%8C%E6%9C%80%E8%BF%91%E7%89%88%E6%9C%AC%E7%9A%84%E4%B8%8D%E5%90%8C">展示暂存区、工作区和最近版本的不同</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E5%88%86%E6%94%AF%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF">快速切换分支上一个分支</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%B7%B2%E7%BB%8F%E5%90%88%E5%B9%B6%E5%88%B0-master-%E7%9A%84%E5%88%86%E6%94%AF">删除已经合并到 master 的分支</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E6%83%85%E5%86%B5">展示本地分支关联远程仓库的情况</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">关联远程分支</a></li>
<li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">列出所有远程分支</a></li>
<li><a href="#%E5%88%97%E5%87%BA%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">列出本地和远程分支</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">创建并切换到本地分支</a></li>
<li><a href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">从远程分支中创建并切换到本地分支</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">删除本地分支</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF">删除远程分支</a></li>
<li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">重命名本地分支</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%A0%87%E7%AD%BE">查看标签</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%A0%87%E7%AD%BE%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF">查看标签详细信息</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE">本地创建标签</a></li>
<li><a href="#%E6%8E%A8%E9%80%81%E6%A0%87%E7%AD%BE%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">推送标签到远程仓库</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%9C%AC%E5%9C%B0%E6%A0%87%E7%AD%BE">删除本地标签</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE">删除远程标签</a></li>
<li><a href="#%E5%88%87%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%AA%E6%A0%87%E7%AD%BE">切回到某个标签</a></li>
<li><a href="#%E6%94%BE%E5%BC%83%E5%B7%A5%E4%BD%9C%E5%8C%BA%E7%9A%84%E4%BF%AE%E6%94%B9">放弃工作区的修改</a></li>
<li><a href="#%E6%81%A2%E5%A4%8D%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%87%E4%BB%B6">恢复删除的文件</a></li>
<li><a href="#%E4%BB%A5%E6%96%B0%E5%A2%9E%E4%B8%80%E4%B8%AA-commit-%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%98%E5%8E%9F%E6%9F%90%E4%B8%80%E4%B8%AA-commit-%E7%9A%84%E4%BF%AE%E6%94%B9">以新增一个 commit 的方式还原某一个 commit 的修改</a></li>
<li><a href="#%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%AA-commit-%E7%9A%84%E7%8A%B6%E6%80%81%E5%B9%B6%E5%88%A0%E9%99%A4%E5%90%8E%E9%9D%A2%E7%9A%84-commit">回到某个 commit 的状态，并删除后面的 commit</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E4%B8%8A%E4%B8%80%E4%B8%AA-commit-%E7%9A%84%E6%8F%8F%E8%BF%B0">修改上一个 commit 的描述</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B-commit-%E5%8E%86%E5%8F%B2">查看 commit 历史</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E6%9C%AC%E5%9C%B0%E6%9B%B4%E6%96%B0%E8%BF%87-head-%E7%9A%84-git-%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95">显示本地更新过 HEAD 的 git 命令记录</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E4%BD%9C%E8%80%85%E5%90%8D">修改作者名</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84-url">修改远程仓库的 url</a></li>
<li><a href="#%E5%A2%9E%E5%8A%A0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">增加远程仓库</a></li>
<li><a href="#%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93">列出所有远程仓库</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E4%B8%A4%E4%B8%AA%E6%98%9F%E6%9C%9F%E5%86%85%E7%9A%84%E6%94%B9%E5%8A%A8">查看两个星期内的改动</a></li>
<li><a href="#%E6%8A%8A-A-%E5%88%86%E6%94%AF%E7%9A%84%E6%9F%90%E4%B8%80%E4%B8%AA-commit-%E6%94%BE%E5%88%B0-B-%E5%88%86%E6%94%AF%E4%B8%8A">把 A 分支的某一个 commit，放到 B 分支上</a></li>
<li><a href="#%E7%BB%99-git-%E5%91%BD%E4%BB%A4%E8%B5%B7%E5%88%AB%E5%90%8D">给 git 命令起别名</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E5%BD%93%E5%89%8D%E7%9A%84%E4%BF%AE%E6%94%B9%E4%BD%86%E4%B8%8D%E7%94%A8%E6%8F%90%E4%BA%A4-commit">存储当前的修改，但不用提交 commit</a></li>
<li><a href="#%E4%BF%9D%E5%AD%98%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81%E5%8C%85%E6%8B%AC-untracked-%E7%9A%84%E6%96%87%E4%BB%B6">保存当前状态，包括 untracked 的文件</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89-stashes">展示所有 stashes</a></li>
<li><a href="#%E5%9B%9E%E5%88%B0%E6%9F%90%E4%B8%AA-stash-%E7%9A%84%E7%8A%B6%E6%80%81">回到某个 stash 的状态</a></li>
<li><a href="#%E5%9B%9E%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA-stash-%E7%9A%84%E7%8A%B6%E6%80%81%E5%B9%B6%E5%88%A0%E9%99%A4%E8%BF%99%E4%B8%AA-stash">回到最后一个 stash 的状态，并删除这个 stash</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%89%80%E6%9C%89%E7%9A%84-stash">删除所有的 stash</a></li>
<li><a href="#%E4%BB%8E-stash-%E4%B8%AD%E6%8B%BF%E5%87%BA%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9">从 stash 中拿出某个文件的修改</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89-tracked-%E7%9A%84%E6%96%87%E4%BB%B6">展示所有 tracked 的文件</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89-untracked-%E7%9A%84%E6%96%87%E4%BB%B6">展示所有 untracked 的文件</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6">展示所有忽略的文件</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4-untracked-%E7%9A%84%E6%96%87%E4%BB%B6">强制删除 untracked 的文件</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E5%88%A0%E9%99%A4-untracked-%E7%9A%84%E7%9B%AE%E5%BD%95">强制删除 untracked 的目录</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E7%AE%80%E5%8C%96%E7%9A%84-commit-%E5%8E%86%E5%8F%B2">展示简化的 commit 历史</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%98%AF%E8%B0%81%E5%86%99%E7%9A%84">查看某段代码是谁写的</a></li>
<li><a href="#%E6%8A%8A%E6%9F%90%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF%E5%88%B0%E5%AF%BC%E5%87%BA%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6">把某一个分支到导出成一个文件</a></li>
<li><a href="#%E4%BB%8E%E5%8C%85%E4%B8%AD%E5%AF%BC%E5%85%A5%E5%88%86%E6%94%AF">从包中导入分支</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C-rebase-%E4%B9%8B%E5%89%8D%E8%87%AA%E5%8A%A8-stash">执行 rebase 之前自动 stash</a></li>
<li><a href="#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%A0%B9%E6%8D%AE-ID-%E6%8B%89%E4%B8%8B%E6%9F%90%E4%B8%80%E7%8A%B6%E6%80%81-%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF">从远程仓库根据 ID，拉下某一状态，到本地分支</a></li>
<li><a href="#%E8%AF%A6%E7%BB%86%E5%B1%95%E7%A4%BA%E4%B8%80%E8%A1%8C%E4%B8%AD%E7%9A%84%E4%BF%AE%E6%94%B9">详细展示一行中的修改</a></li>
<li><a href="#%E6%B8%85%E9%99%A4-gitignore-%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E6%96%87%E4%BB%B6">清除 <code>.gitignore</code> 文件中记录的文件</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89-alias-%E5%92%8C-configs">展示所有 alias 和 configs</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E5%BF%BD%E7%95%A5%E7%9A%84%E6%96%87%E4%BB%B6">展示忽略的文件</a></li>
<li><a href="#commit-%E5%8E%86%E5%8F%B2%E4%B8%AD%E6%98%BE%E7%A4%BA-Branch1-%E6%9C%89%E7%9A%84%E4%BD%86%E6%98%AF-Branch2-%E6%B2%A1%E6%9C%89-commit">commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</a></li>
<li><a href="#%E5%9C%A8-commit-log-%E4%B8%AD%E6%98%BE%E7%A4%BA-GPG-%E7%AD%BE%E5%90%8D">在 commit log 中显示 GPG 签名</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE">删除全局设置</a></li>
<li><a href="#%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%88%87%E6%8D%A2%E5%88%B0%E6%96%B0%E5%88%86%E6%94%AF%E4%B8%8A%E5%90%8C%E6%97%B6%E8%BF%99%E4%B8%AA%E5%88%86%E6%94%AF%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95-commit">新建并切换到新分支上，同时这个分支没有任何 commit</a></li>
<li><a href="#%E5%B1%95%E7%A4%BA%E4%BB%BB%E6%84%8F%E5%88%86%E6%94%AF%E6%9F%90%E4%B8%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9">展示任意分支某一文件的内容</a></li>
<li><a href="#clone-%E4%B8%8B%E6%9D%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8D%95%E4%B8%80%E5%88%86%E6%94%AF">clone 下来指定的单一分支</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E6%94%B9%E5%8A%A8">忽略某个文件的改动</a></li>
<li><a href="#%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E7%9A%84%E6%9D%83%E9%99%90%E5%8F%98%E5%8C%96">忽略文件的权限变化</a></li>
<li><a href="#%E4%BB%A5%E6%9C%80%E5%90%8E%E6%8F%90%E4%BA%A4%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%88%97%E5%87%BA%E6%89%80%E6%9C%89-Git-%E5%88%86%E6%94%AF">以最后提交的顺序列出所有 Git 分支</a></li>
<li><a href="#%E5%9C%A8-commit-log-%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">在 commit log 中查找相关内容</a></li>
<li><a href="#%E6%8A%8A%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%8C%87%E5%AE%9A-file-%E6%94%BE%E5%88%B0%E5%B7%A5%E4%BD%9C%E5%8C%BA%E4%B8%AD">把暂存区的指定 file 放到工作区中</a></li>
<li><a href="#%E5%BC%BA%E5%88%B6%E6%8E%A8%E9%80%81">强制推送</a></li>
<li><a href="#%E4%B8%80%E5%9B%BE%E8%AF%A6%E8%A7%A3">一图详解</a></li>
<li><a href="#%E8%81%94%E7%B3%BB%E6%88%91">联系我</a></li>
</ul>
<h2 id="展示帮助信息"><a href="#展示帮助信息" class="headerlink" title="展示帮助信息"></a>展示帮助信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">help</span> -g</span><br></pre></td></tr></table></figure>
<p>The command output as below:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The common Git guides are:</span><br><span class="line">   attributes          Defining attributes per path</span><br><span class="line">   cli                 Git command-line interface and conventions</span><br><span class="line">   core-tutorial       A Git core tutorial for developers</span><br><span class="line">   cvs-migration       Git for CVS users</span><br><span class="line">   diffcore            Tweaking diff output</span><br><span class="line">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class="line">   glossary            A Git Glossary</span><br><span class="line">   hooks               Hooks used by Git</span><br><span class="line">   ignore              Specifies intentionally untracked files to ignore</span><br><span class="line">   modules             Defining submodule properties</span><br><span class="line">   namespaces          Git namespaces</span><br><span class="line">   repository-layout    Git Repository Layout</span><br><span class="line">   revisions           Specifying revisions and ranges for Git</span><br><span class="line">   tutorial            A tutorial introduction to Git</span><br><span class="line">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class="line">   workflows           An overview of recommended workflows with Git</span><br><span class="line"></span><br><span class="line">&#39;git help -a&#39; and &#39;git help -g&#39; list available subcommands and some concept guides. See &#39;git help &lt;command&gt;&#39; or &#39;git help &lt;concept&gt;&#39; to read about a specific subcommand or concept.</span><br></pre></td></tr></table></figure>

<h2 id="回到远程仓库的状态"><a href="#回到远程仓库的状态" class="headerlink" title="回到远程仓库的状态"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch --all &amp;&amp; git reset --hard origin/master</span><br></pre></td></tr></table></figure>

<h2 id="重设第一个-commit"><a href="#重设第一个-commit" class="headerlink" title="重设第一个 commit"></a>重设第一个 commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的 commit</strong>，这样就可以重新提交第一个 commit 了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git update-ref -d HEAD</span><br></pre></td></tr></table></figure>

<h2 id="展示工作区和暂存区的不同"><a href="#展示工作区和暂存区的不同" class="headerlink" title="展示工作区和暂存区的不同"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的 different (不同)。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>

<p>还可以展示本地仓库中任意两个 commit 之间的文件变动：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git diff &lt;commit-id&gt; &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="展示暂存区和最近版本的不同"><a href="#展示暂存区和最近版本的不同" class="headerlink" title="展示暂存区和最近版本的不同"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本 (commit) 的 different (不同)。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>

<h2 id="展示暂存区、工作区和最近版本的不同"><a href="#展示暂存区、工作区和最近版本的不同" class="headerlink" title="展示暂存区、工作区和最近版本的不同"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本 (commit) 的 different (不同)。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git diff HEAD</span><br></pre></td></tr></table></figure>

<h2 id="快速切换分支上一个分支"><a href="#快速切换分支上一个分支" class="headerlink" title="快速切换分支上一个分支"></a>快速切换分支上一个分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -</span><br></pre></td></tr></table></figure>

<h2 id="删除已经合并到-master-的分支"><a href="#删除已经合并到-master-的分支" class="headerlink" title="删除已经合并到 master 的分支"></a>删除已经合并到 master 的分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch --merged master | grep -v <span class="string">&#x27;^\*\|  master&#x27;</span> | xargs -n 1 git branch -d</span><br></pre></td></tr></table></figure>

<h2 id="展示本地分支关联远程仓库的情况"><a href="#展示本地分支关联远程仓库的情况" class="headerlink" title="展示本地分支关联远程仓库的情况"></a>展示本地分支关联远程仓库的情况</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure>

<h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>关联之后，<code>git branch -vv</code> 就可以展示关联的远程分支名了，同时推送到远程仓库直接：<code>git push</code>，不需要指定远程仓库了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -u origin/mybranch</span><br></pre></td></tr></table></figure>

<p>或者在 push 时加上 <code>-u</code> 参数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin/mybranch -u</span><br></pre></td></tr></table></figure>

<h2 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h2><p>-r 参数相当于：remote</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure>

<h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a 参数相当于：all</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="从远程分支中创建并切换到本地分支"><a href="#从远程分支中创建并切换到本地分支" class="headerlink" title="从远程分支中创建并切换到本地分支"></a>从远程分支中创建并切换到本地分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;local-branchname&gt;</span><br></pre></td></tr></table></figure>

<h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin --delete &lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin :&lt;remote-branchname&gt;</span><br></pre></td></tr></table></figure>

<h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -m &lt;new-branch-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
<p>展示当前分支的最近的 tag</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git describe --tags --abbrev=0</span><br></pre></td></tr></table></figure>

<h2 id="查看标签详细信息"><a href="#查看标签详细信息" class="headerlink" title="查看标签详细信息"></a>查看标签详细信息</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -ln</span><br></pre></td></tr></table></figure>

<h2 id="本地创建标签"><a href="#本地创建标签" class="headerlink" title="本地创建标签"></a>本地创建标签</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag &lt;version-number&gt;</span><br></pre></td></tr></table></figure>

<p>默认 tag 是打在最近的一次 commit 上，如果需要指定 commit 打 tag：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git tag -a &lt;version-number&gt; -m <span class="string">&quot;v1.0 发布(描述)&quot;</span> &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin &lt;local-version-number&gt;</span><br></pre></td></tr></table></figure>

<p>一次性推送所有标签，同步到远程仓库：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure>

<h2 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tag-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><p>删除远程标签需要<strong>先删除本地标签</strong>，再执行下面的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tag-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="切回到某个标签"><a href="#切回到某个标签" class="headerlink" title="切回到某个标签"></a>切回到某个标签</h2><p>一般上线之前都会打 tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b branch_name tag_name</span><br></pre></td></tr></table></figure>

<h2 id="放弃工作区的修改"><a href="#放弃工作区的修改" class="headerlink" title="放弃工作区的修改"></a>放弃工作区的修改</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout &lt;file-name&gt;</span><br></pre></td></tr></table></figure>

<p>放弃所有修改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure>

<h2 id="恢复删除的文件"><a href="#恢复删除的文件" class="headerlink" title="恢复删除的文件"></a>恢复删除的文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rev-list -n 1 HEAD -- &lt;file_path&gt; <span class="comment">#得到 deleting_commit</span></span><br><span class="line"></span><br><span class="line">git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; <span class="comment">#回到删除文件 deleting_commit 之前的状态</span></span><br></pre></td></tr></table></figure>

<h2 id="以新增一个-commit-的方式还原某一个-commit-的修改"><a href="#以新增一个-commit-的方式还原某一个-commit-的修改" class="headerlink" title="以新增一个 commit 的方式还原某一个 commit 的修改"></a>以新增一个 commit 的方式还原某一个 commit 的修改</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git revert &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="回到某个-commit-的状态，并删除后面的-commit"><a href="#回到某个-commit-的状态，并删除后面的-commit" class="headerlink" title="回到某个 commit 的状态，并删除后面的 commit"></a>回到某个 commit 的状态，并删除后面的 commit</h2><p>和 revert 的区别：reset 命令会抹去某个 commit id 之后的所有 commit</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset &lt;commit-id&gt;  <span class="comment">#默认就是-mixed参数。</span></span><br><span class="line"></span><br><span class="line">git reset –mixed HEAD^  <span class="comment">#回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。</span></span><br><span class="line"></span><br><span class="line">git reset –soft HEAD~3  <span class="comment">#回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可  </span></span><br><span class="line"></span><br><span class="line">git reset –hard &lt;commit-id&gt;  <span class="comment">#彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</span></span><br></pre></td></tr></table></figure>

<h2 id="修改上一个-commit-的描述"><a href="#修改上一个-commit-的描述" class="headerlink" title="修改上一个 commit 的描述"></a>修改上一个 commit 的描述</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<h2 id="查看-commit-历史"><a href="#查看-commit-历史" class="headerlink" title="查看 commit 历史"></a>查看 commit 历史</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h2 id="查看某段代码是谁写的"><a href="#查看某段代码是谁写的" class="headerlink" title="查看某段代码是谁写的"></a>查看某段代码是谁写的</h2><p>blame 的意思为‘责怪’，你懂的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git blame &lt;file-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="显示本地更新过-HEAD-的-git-命令记录"><a href="#显示本地更新过-HEAD-的-git-命令记录" class="headerlink" title="显示本地更新过 HEAD 的 git 命令记录"></a>显示本地更新过 HEAD 的 git 命令记录</h2><p>每次更新了 HEAD 的 git 命令比如 commint、amend、cherry-pick、reset、revert 等都会被记录下来（不限分支），就像 shell 的 history 一样。<br>这样你可以 reset 到任何一次更新了 HEAD 的操作之后，而不仅仅是回到当前分支下的某个 commit 之后的状态。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<h2 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit --amend --author=<span class="string">&#x27;Author Name &lt;email@address.com&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="修改远程仓库的-url"><a href="#修改远程仓库的-url" class="headerlink" title="修改远程仓库的 url"></a>修改远程仓库的 url</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote set-url origin &lt;URL&gt;</span><br></pre></td></tr></table></figure>

<h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;remote-url&gt;</span><br></pre></td></tr></table></figure>

<h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<h2 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git whatchanged --since=<span class="string">&#x27;2 weeks ago&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="把-A-分支的某一个-commit，放到-B-分支上"><a href="#把-A-分支的某一个-commit，放到-B-分支上" class="headerlink" title="把 A 分支的某一个 commit，放到 B 分支上"></a>把 A 分支的某一个 commit，放到 B 分支上</h2><p>这个过程需要 <code>cherry-pick</code> 命令，<a class="link"   href="http://sg552.iteye.com/blog/1300713#bc2367928" >参考<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;</span><br></pre></td></tr></table></figure>

<h2 id="给-git-命令起别名"><a href="#给-git-命令起别名" class="headerlink" title="给 git 命令起别名"></a>给 git 命令起别名</h2><p>简化命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global <span class="built_in">alias</span>.&lt;handle&gt; &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line">比如：git status 改成 git st，这样可以简化命令</span><br><span class="line"></span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>

<h2 id="存储当前的修改，但不用提交-commit"><a href="#存储当前的修改，但不用提交-commit" class="headerlink" title="存储当前的修改，但不用提交 commit"></a>存储当前的修改，但不用提交 commit</h2><p>详解可以参考<a class="link"   href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" >廖雪峰老师的 git 教程<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>

<h2 id="保存当前状态，包括-untracked-的文件"><a href="#保存当前状态，包括-untracked-的文件" class="headerlink" title="保存当前状态，包括 untracked 的文件"></a>保存当前状态，包括 untracked 的文件</h2><p>untracked 文件：新建的文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash -u</span><br></pre></td></tr></table></figure>

<h2 id="展示所有-stashes"><a href="#展示所有-stashes" class="headerlink" title="展示所有 stashes"></a>展示所有 stashes</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<h2 id="回到某个-stash-的状态"><a href="#回到某个-stash-的状态" class="headerlink" title="回到某个 stash 的状态"></a>回到某个 stash 的状态</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash apply &lt;stash@&#123;n&#125;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="回到最后一个-stash-的状态，并删除这个-stash"><a href="#回到最后一个-stash-的状态，并删除这个-stash" class="headerlink" title="回到最后一个 stash 的状态，并删除这个 stash"></a>回到最后一个 stash 的状态，并删除这个 stash</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="删除所有的-stash"><a href="#删除所有的-stash" class="headerlink" title="删除所有的 stash"></a>删除所有的 stash</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure>

<h2 id="从-stash-中拿出某个文件的修改"><a href="#从-stash-中拿出某个文件的修改" class="headerlink" title="从 stash 中拿出某个文件的修改"></a>从 stash 中拿出某个文件的修改</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout &lt;stash@&#123;n&#125;&gt; -- &lt;file-path&gt;</span><br></pre></td></tr></table></figure>

<h2 id="展示所有-tracked-的文件"><a href="#展示所有-tracked-的文件" class="headerlink" title="展示所有 tracked 的文件"></a>展示所有 tracked 的文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git ls-files -t</span><br></pre></td></tr></table></figure>

<h2 id="展示所有-untracked-的文件"><a href="#展示所有-untracked-的文件" class="headerlink" title="展示所有 untracked 的文件"></a>展示所有 untracked 的文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git ls-files --others</span><br></pre></td></tr></table></figure>

<h2 id="展示所有忽略的文件"><a href="#展示所有忽略的文件" class="headerlink" title="展示所有忽略的文件"></a>展示所有忽略的文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git ls-files --others -i --exclude-standard</span><br></pre></td></tr></table></figure>

<h2 id="强制删除-untracked-的文件"><a href="#强制删除-untracked-的文件" class="headerlink" title="强制删除 untracked 的文件"></a>强制删除 untracked 的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的 untracked 文件。<code>clean</code> 命令，<strong>注意两点</strong>：</p>
<ol>
<li>clean 后，删除的文件无法找回</li>
<li>不会影响 tracked 的文件的改动，只会删除 untracked 的文件</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git clean &lt;file-name&gt; -f</span><br></pre></td></tr></table></figure>

<h2 id="强制删除-untracked-的目录"><a href="#强制删除-untracked-的目录" class="headerlink" title="强制删除 untracked 的目录"></a>强制删除 untracked 的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除 untracked 的文件。详情见上一条</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git clean &lt;directory-name&gt; -df</span><br></pre></td></tr></table></figure>

<h2 id="展示简化的-commit-历史"><a href="#展示简化的-commit-历史" class="headerlink" title="展示简化的 commit 历史"></a>展示简化的 commit 历史</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline --graph --decorate --all</span><br></pre></td></tr></table></figure>

<h2 id="把某一个分支到导出成一个文件"><a href="#把某一个分支到导出成一个文件" class="headerlink" title="把某一个分支到导出成一个文件"></a>把某一个分支到导出成一个文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git bundle create &lt;file&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="从包中导入分支"><a href="#从包中导入分支" class="headerlink" title="从包中导入分支"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面 <code>git bundle create</code> 命令导出的内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="执行-rebase-之前自动-stash"><a href="#执行-rebase-之前自动-stash" class="headerlink" title="执行 rebase 之前自动 stash"></a>执行 rebase 之前自动 stash</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rebase --autostash</span><br></pre></td></tr></table></figure>

<h2 id="从远程仓库根据-ID，拉下某一状态，到本地分支"><a href="#从远程仓库根据-ID，拉下某一状态，到本地分支" class="headerlink" title="从远程仓库根据 ID，拉下某一状态，到本地分支"></a>从远程仓库根据 ID，拉下某一状态，到本地分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="详细展示一行中的修改"><a href="#详细展示一行中的修改" class="headerlink" title="详细展示一行中的修改"></a>详细展示一行中的修改</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git diff --word-diff</span><br></pre></td></tr></table></figure>

<h2 id="清除-gitignore-文件中记录的文件"><a href="#清除-gitignore-文件中记录的文件" class="headerlink" title="清除 gitignore 文件中记录的文件"></a>清除 gitignore 文件中记录的文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git clean -X -f</span><br></pre></td></tr></table></figure>

<h2 id="展示所有-alias-和-configs"><a href="#展示所有-alias-和-configs" class="headerlink" title="展示所有 alias 和 configs"></a>展示所有 alias 和 configs</h2><p><strong>注意：</strong> config 分为：当前目录（local）和全局（golbal）的 config，默认为当前目录的 config</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --list (当前目录)</span><br><span class="line">git config --global --list (全局)</span><br></pre></td></tr></table></figure>

<h2 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git status --ignored</span><br></pre></td></tr></table></figure>

<h2 id="commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit"><a href="#commit-历史中显示-Branch1-有的，但是-Branch2-没有-commit" class="headerlink" title="commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit"></a>commit 历史中显示 Branch1 有的，但是 Branch2 没有 commit</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> Branch1 ^Branch2</span><br></pre></td></tr></table></figure>

<h2 id="在-commit-log-中显示-GPG-签名"><a href="#在-commit-log-中显示-GPG-签名" class="headerlink" title="在 commit log 中显示 GPG 签名"></a>在 commit log 中显示 GPG 签名</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --show-signature</span><br></pre></td></tr></table></figure>

<h2 id="删除全局设置"><a href="#删除全局设置" class="headerlink" title="删除全局设置"></a>删除全局设置</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> &lt;entry-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="新建并切换到新分支上，同时这个分支没有任何-commit"><a href="#新建并切换到新分支上，同时这个分支没有任何-commit" class="headerlink" title="新建并切换到新分支上，同时这个分支没有任何 commit"></a>新建并切换到新分支上，同时这个分支没有任何 commit</h2><p>相当于保存修改，但是重写 commit 历史</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout --orphan &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="展示任意分支某一文件的内容"><a href="#展示任意分支某一文件的内容" class="headerlink" title="展示任意分支某一文件的内容"></a>展示任意分支某一文件的内容</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git show &lt;branch-name&gt;:&lt;file-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="clone-下来指定的单一分支"><a href="#clone-下来指定的单一分支" class="headerlink" title="clone 下来指定的单一分支"></a>clone 下来指定的单一分支</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git</span><br></pre></td></tr></table></figure>

<h2 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git update-index --assume-unchanged path/to/file</span><br></pre></td></tr></table></figure>

<p>恢复 track 指定文件的改动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git update-index --no-assume-unchanged path/to/file</span><br></pre></td></tr></table></figure>

<h2 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config core.fileMode <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="以最后提交的顺序列出所有-Git-分支"><a href="#以最后提交的顺序列出所有-Git-分支" class="headerlink" title="以最后提交的顺序列出所有 Git 分支"></a>以最后提交的顺序列出所有 Git 分支</h2><p>最新的放在最上面</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git for-each-ref --sort=-committerdate --format=<span class="string">&#x27;%(refname:short)&#x27;</span> refs/heads/</span><br></pre></td></tr></table></figure>

<h2 id="在-commit-log-中查找相关内容"><a href="#在-commit-log-中查找相关内容" class="headerlink" title="在 commit log 中查找相关内容"></a>在 commit log 中查找相关内容</h2><p>通过 grep 查找，given-text：所需要查找的字段</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --grep=<span class="string">&#x27;&lt;given-text&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="把暂存区的指定-file-放到工作区中"><a href="#把暂存区的指定-file-放到工作区中" class="headerlink" title="把暂存区的指定 file 放到工作区中"></a>把暂存区的指定 file 放到工作区中</h2><p>不添加参数，默认是 <code>-mixed</code></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push -f &lt;remote-name&gt; &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网卡Bond</title>
    <url>/2019/07/04/linux/bond/</url>
    <content><![CDATA[<h2 id="什么是bond？"><a href="#什么是bond？" class="headerlink" title="什么是bond？"></a>什么是bond？</h2><p>所谓bond，是一种通过把多个物理网卡绑定成一个逻辑网卡实现网卡冗余、负载均衡、提高带宽，从而实现网络性能高可用高可靠的技术。</p>
<a id="more"></a>

<h2 id="bond的七种模型："><a href="#bond的七种模型：" class="headerlink" title="bond的七种模型："></a>bond的七种模型：</h2><blockquote>
<p>mod0：（balance-rr，平衡轮循环策略，提供负载均衡和容错能力），数据包传输是依次传输，第一个包从网卡1传输，第二个包从网卡2传输，第三个包从网卡3…….，一直循环直到传输完最后一个数据包。这种模式的bond有一个不完善的地方，如果一个数据包从不同的网卡传输，而中途再经过不同的链路，当客户端接受到数据包的时候，数据包就可能出现无序到达的情况，而无序到达的数据包需要重新发送，这样网络的性能便会大大下降。</p>
</blockquote>
<blockquote>
<p>mod1：（active-backup，主备策略，提供冗余能力），只有一个网卡被使用，当一个网卡宕了之后，马上由备网卡接替主网卡的工作，为了避免交换机发生混乱，逻辑网卡的mac地址是唯一的。这种模型的bond可提高网络的可用性，但是它的资源利用率低，只有1/网卡个数（N）。</p>
</blockquote>
<blockquote>
<p>mod2：（balance-xor，平衡策略，提供负载均衡和容错能力）—不是很明白实现原理与算法，有哪位大神知道的话，可以在下面留言，让小弟也开开眼界。</p>
</blockquote>
<blockquote>
<p>mod3：（broadcast，广播策略，提供容错能力）每一个备网卡传输每个数据包。</p>
</blockquote>
<blockquote>
<p>mod4：（802.3ad，动态链路聚合），创建聚合组，聚合组中的每个备网卡共享同样的速率和双工，必要条件是交换机需要支持802.3ad以及需要ethtool的支持</p>
</blockquote>
<blockquote>
<p>mod5：（balance-tlb，适配器传输负载均衡），在每个网卡上根据当前的压力负载分配流量，如果正在工作的网卡宕了，另外的网卡接管宕机的网卡的mac地址。必要条件是：需要ethtool的支持。</p>
</blockquote>
<blockquote>
<p>mod6：（balance-alb，适配器适应负载均衡），该模式包含了balance-tlb模式，同时加上针对IPV4流量的接收负载均衡(receive load balance, rlb)，而且不需要任何switch(交换机)的支持。接收负载均衡是通过ARP协商实现的。bonding驱动截获本机发送的ARP应答，并把源硬件地址改写为bond中某个slave的唯一硬件地址，从而使得不同的对端使用不同的硬件地址进行通信。</p>
</blockquote>
<h3 id="实验（mod0为例，其他mod大同小异）"><a href="#实验（mod0为例，其他mod大同小异）" class="headerlink" title="实验（mod0为例，其他mod大同小异）"></a>实验（mod0为例，其他mod大同小异）</h3><p>创建逻辑网卡的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建逻辑网卡的配置文件</span></span><br><span class="line">[root@bond network-scripts]# catifcfg-bond0   </span><br><span class="line"></span><br><span class="line">DEVICE=bond0</span><br><span class="line"></span><br><span class="line">BOOTPROTO=static</span><br><span class="line"></span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line">IPADDR=192.168.31.100</span><br><span class="line"></span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"></span><br><span class="line">NETWORK=192.168.31.0</span><br><span class="line"></span><br><span class="line">GATEWAY=192.168.31.1</span><br><span class="line"></span><br><span class="line">BROADCAST=192.168.31.255</span><br><span class="line"></span><br><span class="line">BONDING_OPTS=&quot;mode=0  miimon=200&quot;  #mode指定模式，miimon为探测的时间间隔(毫秒) </span><br><span class="line"></span><br><span class="line">USERCTL=no     #是否允许非root用户控制该设备  yes|no</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改物理网卡的配置文件</span></span><br><span class="line">[root@bond network-scripts]# catifcfg-eno16780032</span><br><span class="line">DEVICE=eno16780032</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">MASTER=bond0    #指定master为bond0</span><br><span class="line">SLAVE=yes            #是否为附属</span><br><span class="line">USERCTL=no</span><br><span class="line"></span><br><span class="line">[root@bond network-scripts]# catifcfg-eno33561344</span><br><span class="line">DEVICE=eno33561344</span><br><span class="line">BOOTPROTO=none</span><br><span class="line">MASTER=bond0   </span><br><span class="line">SLAVE=yes</span><br><span class="line">USERCTL=no</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bond0是通过bonding的驱动来配置的，所以我们还需要为bond0这块网卡添加驱动支持，将这个驱动添加到 /etc/modprobe.d/ 这个目录下</span></span><br><span class="line">[root@bond ~]# cat/etc/modprobe.d/bonding.conf</span><br><span class="line">alias bond0 bonding</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">加载bonding模块</span></span><br><span class="line">[root@bond ~]# modprobe  bonding</span><br><span class="line">[root@bond ~]# lsmod |grep bonding</span><br><span class="line">bonding               136705  0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重启网络</span></span><br><span class="line">[root@bond ~]# systemctl restart network</span><br><span class="line">Job for network.service failed because thecontrol process exited with error code. See &quot;systemctl statusnetwork.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line"> </span><br><span class="line">bond network[10418]:Bringing up interface bond0:  Error:Connection activation failed: No suitable device found for this connection.</span><br><span class="line">bond network[10418]:Bringing up interface eno16780032: Error: Connection activation failed: Master device bond0 unmanaged ornot available for activation</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果发现有如上报错，需要关闭NetworkManager。</span></span><br><span class="line">参考（https://access.redhat.com/discussions/2162171）</span><br><span class="line">[root@bond ~]# systemctl stopNetworkManager</span><br><span class="line">[root@bond ~]# systemctl disabledNetworkManager</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">验证       仔细观察发现物理网卡的mac地址和逻辑网卡的mac地址一样</span></span><br><span class="line">[root@bond ~]# ip add show</span><br><span class="line">3: eno16780032: &lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&gt;mtu 1500 qdisc mq master bond0 state UP qlen1000</span><br><span class="line">   link/ether 00:0c:29:bc:7d:41 brdff:ff:ff:ff:ff:ff</span><br><span class="line">   inet6 fe80::20c:29ff:febc:7d41/64 scopelink</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">4: eno33561344: &lt;BROADCAST,MULTICAST,SLAVE,UP,LOWER_UP&gt;mtu 1500 qdisc mq master bond0 state UP qlen1000</span><br><span class="line">   link/ether 00:0c:29:bc:7d:41 brdff:ff:ff:ff:ff:ff</span><br><span class="line">   inet6 fe80::20c:29ff:febc:7d41/64 scopelink</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">5: bond0:&lt;BROADCAST,MULTICAST,MASTER,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP</span><br><span class="line">   link/ether 00:0c:29:bc:7d:41 brdff:ff:ff:ff:ff:ff</span><br><span class="line">   inet 192.168.31.100/24 brd 192.168.31.255 scope global bond0</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">   inet6 fe80::20c:29ff:febc:7d41/64 scopelink tentative dadfailed</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看逻辑网口设备的信息</span></span><br><span class="line">[root@bond ~]# cat /proc/net/bonding/bond0</span><br><span class="line">Ethernet Channel Bonding Driver: v3.7.1(April 27, 2011)</span><br><span class="line"> </span><br><span class="line">Bonding Mode: load balancing (round-robin)    #模式为负载均衡</span><br><span class="line">MII Status: up      #状态为up</span><br><span class="line">MII Polling Interval (ms): 200     #侦测间隔为200ms</span><br><span class="line">Up Delay (ms): 0     #启动延迟为0ms</span><br><span class="line">Down Delay (ms): 0   #关闭延迟为0ms</span><br><span class="line"> </span><br><span class="line">Slave Interface: eno16780032</span><br><span class="line">MII Status: up     #状态up</span><br><span class="line">Speed: 10000 Mbps    #速率为10000</span><br><span class="line">Duplex: full       #全双工</span><br><span class="line">Link Failure Count: 0   </span><br><span class="line">Permanent HW addr: 00:0c:29:bc:7d:41  </span><br><span class="line">Slave queue ID: 0</span><br><span class="line"> </span><br><span class="line">Slave Interface: eno33561344</span><br><span class="line">MII Status: up</span><br><span class="line">Speed: 10000 Mbps</span><br><span class="line">Duplex: full</span><br><span class="line">Link Failure Count: 0</span><br><span class="line">Permanent HW addr: 00:0c:29:bc:7d:4b</span><br><span class="line">Slave queue ID: 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>从外部访问Kubernetes中的Pod</title>
    <url>/2019/07/04/k8s/pod_network_outside/</url>
    <content><![CDATA[<h1 id="从外部访问Kubernetes中的Pod"><a href="#从外部访问Kubernetes中的Pod" class="headerlink" title="从外部访问Kubernetes中的Pod"></a>从外部访问Kubernetes中的Pod</h1><p>kubernetes的几种网络模式</p>
<a id="more"></a>

<h2 id="hostNetwork"><a href="#hostNetwork" class="headerlink" title="hostNetwork"></a>hostNetwork</h2><p>如果在Pod中使用<code>hostNetwork:true</code>配置的话，在这种pod中运行的应用程序可以直接看到pod启动的主机的网络接口。在主机的所有网络接口上都可以访问到该应用程序。以下是使用主机网络的pod的示例定义：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure>
<p>注意每次启动这个Pod的时候都可能被调度到不同的节点上，所有外部访问Pod的IP也是变化的，而且调度Pod的时候还需要考虑是否与宿主机上的端口冲突，因此一般情况下除非您知道需要某个特定应用占用特定宿主机上的特定端口时才使用hostNetwork: true的方式。</p>
<p>这种Pod的网络模式有一个用处就是可以将网络插件包装在Pod中然后部署在每个宿主机上，这样该Pod就可以控制该宿主机上的所有网络。</p>
<h2 id="hostPort"><a href="#hostPort" class="headerlink" title="hostPort"></a>hostPort</h2><p>这是一种直接定义Pod网络的方式。</p>
<p><code>hostPort</code>是直接将容器的端口与所调度的节点上的端口路由，这样用户就可以通过宿主机的IP加上来访问Pod了，如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">influxdb</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8086</span></span><br><span class="line">          <span class="attr">hostPort:</span> <span class="number">8086</span></span><br></pre></td></tr></table></figure>
<p>这样做有个缺点，因为Pod重新调度的时候该Pod被调度到的宿主机可能会变动，这样就变化了，用户必须自己维护一个Pod与所在宿主机的对应关系。</p>
<p>这种网络方式可以用来做<code>nginx Ingress</code>controller。外部流量都需要通过kubenretes node节点的80和443端口。</p>
<h2 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h2><p>NodePort在kubenretes里是一个广泛应用的服务暴露方式。Kubernetes中的service默认情况下都是使用的<code>ClusterIP</code>这种类型，这样的service会产生一个ClusterIP，这个IP只能在集群内部访问，要想让外部能够直接访问service，需要将service type修改为 <code>nodePort</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">influxdb</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8086</span></span><br></pre></td></tr></table></figure>

<p>同时还可以给service指定一个<code>nodePort</code>值，范围是<code>30000-32767</code>，这个值在API server的配置文件中，用<code>--service-node-port-range</code>定义。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">influxdb</span></span><br></pre></td></tr></table></figure>
<p>集群外就可以使用kubernetes任意一个节点的IP加上30000端口访问该服务了。kube-proxy会自动将流量以round-robin的方式转发给该service的每一个pod。</p>
<p>这种服务暴露方式，无法让你指定自己想要的应用常用端口，不过可以在集群上再部署一个反向代理作为流量入口。</p>
<h2 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h2><p><code>LoadBalancer</code> 只能在service上定义。这是公有云提供的负载均衡器，如AWS、Azure、CloudStack、GCE等。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8086</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">influxdb</span></span><br></pre></td></tr></table></figure>

<p>内部可以使用ClusterIP加端口来访问服务，如19.97.121.42:8086。</p>
<p>外部可以用以下两种方式访问该服务：</p>
<p>使用任一节点的IP加30051端口访问该服务<br>使用<code>EXTERNAL-IP</code>来访问，这是一个VIP，是云供应商提供的负载均衡器IP，如10.13.242.236:8086。</p>
<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>Ingress是自kubernetes1.1版本后引入的资源类型。必须要部署Ingress controller才能创建Ingress资源，Ingress controller是以一种插件的形式提供。Ingress controller 是部署在Kubernetes之上的Docker容器。它的Docker镜像包含一个像nginx或HAProxy的负载均衡器和一个控制器守护进程。控制器守护程序从Kubernetes接收所需的Ingress配置。它会生成一个nginx或HAProxy配置文件，并重新启动负载平衡器进程以使更改生效。换句话说，Ingress controller是由Kubernetes管理的负载均衡器。</p>
<p>Kubernetes Ingress提供了负载平衡器的典型特性：HTTP路由，粘性会话，SSL终止，SSL直通，TCP和UDP负载平衡等。目前并不是所有的Ingress controller都实现了这些功能，需要查看具体的Ingress controller文档。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">influxdb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">influxdb.kube.example.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">influxdb</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">8086</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性算法</title>
    <url>/2019/07/04/principles/raft/</url>
    <content><![CDATA[<h1 id="寻找一种易于理解的一致性算法（扩展版）"><a href="#寻找一种易于理解的一致性算法（扩展版）" class="headerlink" title="寻找一种易于理解的一致性算法（扩展版）"></a>寻找一种易于理解的一致性算法（扩展版）</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性。同时它通过实施一个更强的一致性来减少需要考虑的状态的数量。从一个用户研究的结果可以证明，对于学生而言，Raft 算法比 Paxos 算法更加容易学习。Raft 算法还包括一个新的机制来允许集群成员的动态改变，它利用重叠的大多数来保证安全性。</p>
<a id="more"></a>

<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><p>一致性算法允许一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作下去。正因为如此，一致性算法在构建可信赖的大规模软件系统中扮演着重要的角色。在过去的 10 年里，Paxos  算法统治着一致性算法这一领域：绝大多数的实现都是基于 Paxos 或者受其影响。同时 Paxos 也成为了教学领域里讲解一致性问题时的示例。</p>
<p>但是不幸的是，尽管有很多工作都在尝试降低它的复杂性，但是 Paxos 算法依然十分难以理解。并且，Paxos 自身的算法结构需要进行大幅的修改才能够应用到实际的系统中。这些都导致了工业界和学术界都对 Paxos 算法感到十分头疼。</p>
<p>和 Paxos 算法进行过努力之后，我们开始寻找一种新的一致性算法，可以为构建实际的系统和教学提供更好的基础。我们的做法是不寻常的，我们的首要目标是可理解性：我们是否可以在实际系统中定义一个一致性算法，并且能够比 Paxos 算法以一种更加容易的方式来学习。此外，我们希望该算法方便系统构建者的直觉的发展。不仅一个算法能够工作很重要，而且能够显而易见的知道为什么能工作也很重要。</p>
<p>Raft 一致性算法就是这些工作的结果。在设计 Raft 算法的时候，我们使用一些特别的技巧来提升它的可理解性，包括算法分解（Raft 主要被分成了领导人选举，日志复制和安全三个模块）和减少状态机的状态（相对于 Paxos，Raft 减少了非确定性和服务器互相处于非一致性的方式）。一份针对两所大学 43 个学生的研究表明 Raft 明显比 Paxos 算法更加容易理解。在这些学生同时学习了这两种算法之后，和 Paxos 比起来，其中 33 个学生能够回答有关于 Raft 的问题。</p>
<p>Raft 算法在许多方面和现有的一致性算法都很相似（主要是 Oki 和 Liskov 的 Viewstamped Replication），但是它也有一些独特的特性：</p>
<ul>
<li><strong>强领导者</strong>：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。</li>
<li><strong>领导选举</strong>：Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。</li>
<li><strong>成员关系调整</strong>：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法下，处于调整过程中的两种不同的配置集群中大多数机器会有重叠，这就使得集群在成员变换的时候依然可以继续工作。</li>
</ul>
<p>我们相信，Raft 算法不论出于教学目的还是作为实践项目的基础都是要比 Paxos 或者其他一致性算法要优异的。它比其他算法更加简单，更加容易理解；它的算法描述足以实现一个现实的系统；它有好多开源的实现并且在很多公司里使用；它的安全性已经被证明；它的效率和其他算法比起来也不相上下。</p>
<p>接下来，这篇论文会介绍以下内容：复制状态机问题（第 2 节），讨论 Paxos 的优点和缺点（第 3 节），讨论我们为了可理解性而采取的方法（第 4 节），阐述 Raft 一致性算法（第 5-8 节），评价 Raft 算法（第 9 节），以及一些相关的工作（第 10 节）。</p>
<h2 id="2-复制状态机"><a href="#2-复制状态机" class="headerlink" title="2 复制状态机"></a>2 复制状态机</h2><p>一致性算法是从复制状态机的背景下提出的（参考英文原文引用37）。在这种方法中，一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。复制状态机在分布式系统中被用于解决很多容错的问题。例如，大规模的系统中通常都有一个集群领导者，像 GFS、HDFS 和 RAMCloud，典型应用就是一个独立的的复制状态机去管理领导选举和存储配置信息并且在领导人宕机的情况下也要存活下来。比如 Chubby 和 ZooKeeper。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE1.png" alt="图 1 "></p>
<blockquote>
<p>图 1 ：复制状态机的结构。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。</p>
</blockquote>
<p>复制状态机通常都是基于复制日志实现的，如图 1。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。</p>
<p>保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。</p>
<p>实际系统中使用的一致性算法通常含有以下特性：</p>
<ul>
<li>安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。</li>
<li>可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。</li>
<li>不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。</li>
<li>通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。</li>
</ul>
<h2 id="3-Paxos-算法的问题"><a href="#3-Paxos-算法的问题" class="headerlink" title="3 Paxos 算法的问题"></a>3 Paxos 算法的问题</h2><p>在过去的 10 年里，Leslie Lamport 的 Paxos 算法几乎已经成为一致性的代名词：Paxos 是在课程教学中最经常使用的算法，同时也是大多数一致性算法实现的起点。Paxos 首先定义了一个能够达成单一决策一致的协议，比如单条的复制日志项。我们把这一子集叫做单决策 Paxos。然后通过组合多个 Paxos 协议的实例来促进一系列决策的达成。Paxos 保证安全性和活性，同时也支持集群成员关系的变更。Paxos 的正确性已经被证明，在通常情况下也很高效。</p>
<p>不幸的是，Paxos 有两个明显的缺点。第一个缺点是 Paxos 算法特别的难以理解。完整的解释是出了名的不透明；通过极大的努力之后，也只有少数人成功理解了这个算法。因此，有了几次用更简单的术语来解释 Paxos 的尝试。尽管这些解释都只关注了单决策的子集问题，但依然很具有挑战性。在 2012 年 NSDI 的会议中的一次调查显示，很少有人对 Paxos 算法感到满意，甚至在经验老道的研究者中也是如此。我们自己也尝试去理解 Paxos；我们一直没能理解 Paxos 直到我们读了很多对 Paxos 的简化解释并且设计了我们自己的算法之后，这一过程花了近一年时间。</p>
<p>我们假设 Paxos 的不透明性来自它选择单决策问题作为它的基础。单决策 Paxos 是晦涩微妙的，它被划分成了两种没有简单直观解释和无法独立理解的情景。因此，这导致了很难建立起直观的感受为什么单决策 Paxos 算法能够工作。构成多决策 Paxos 增加了很多错综复杂的规则。我们相信，在多决策上达成一致性的问题（一份日志而不是单一的日志记录）能够被分解成其他的方式并且更加直接和明显。</p>
<p>Paxos算法的第二个问题就是它没有提供一个足够好的用来构建一个现实系统的基础。一个原因是还没有一种被广泛认同的多决策问题的算法。Lamport 的描述基本上都是关于单决策 Paxos 的；他简要描述了实施多决策 Paxos 的方法，但是缺乏很多细节。当然也有很多具体化 Paxos 的尝试，但是他们都互相不一样，和 Paxos 的概述也不同。例如 Chubby 这样的系统实现了一个类似于 Paxos 的算法，但是大多数的细节并没有被公开。</p>
<p>而且，Paxos 算法的结构也不是十分易于构建实践的系统；单决策分解也会产生其他的结果。例如，独立的选择一组日志条目然后合并成一个序列化的日志并没有带来太多的好处，仅仅增加了不少复杂性。围绕着日志来设计一个系统是更加简单高效的；新日志条目以严格限制的顺序增添到日志中去。另一个问题是，Paxos 使用了一种对等的点对点的方式作为它的核心（尽管它最终提议了一种弱领导人的方法来优化性能）。在只有一个决策会被制定的简化世界中是很有意义的，但是很少有现实的系统使用这种方式。如果有一系列的决策需要被制定，首先选择一个领导人，然后让他去协调所有的决议，会更加简单快速。</p>
<p>因此，实际的系统中很少有和 Paxos 相似的实践。每一种实现都是从 Paxos 开始研究，然后发现很多实现上的难题，再然后开发了一种和 Paxos 明显不一样的结构。这样是非常费时和容易出错的，并且理解 Paxos 的难度使得这个问题更加糟糕。Paxos 算法在理论上被证明是正确可行的，但是现实的系统和 Paxos 差别是如此的大，以至于这些证明没有什么太大的价值。下面来自 Chubby 实现非常典型：</p>
<blockquote>
<p>在Paxos算法描述和实现现实系统中间有着巨大的鸿沟。最终的系统建立在一种没有经过证明的算法之上。</p>
</blockquote>
<p>由于以上问题，我们认为 Paxos 算法既没有提供一个良好的基础给实践的系统，也没有给教学很好的帮助。基于一致性问题在大规模软件系统中的重要性，我们决定看看我们是否可以设计一个拥有更好特性的替代 Paxos 的一致性算法。Raft算法就是这次实验的结果。</p>
<h2 id="4-为了可理解性的设计"><a href="#4-为了可理解性的设计" class="headerlink" title="4 为了可理解性的设计"></a>4 为了可理解性的设计</h2><p>设计 Raft 算法我们有几个初衷：它必须提供一个完整的实际的系统实现基础，这样才能大大减少开发者的工作；它必须在任何情况下都是安全的并且在大多数的情况下都是可用的；并且它的大部分操作必须是高效的。但是我们最重要也是最大的挑战是可理解性。它必须保证对于普遍的人群都可以十分容易的去理解。另外，它必须能够让人形成直观的认识，这样系统的构建者才能够在现实中进行必然的扩展。</p>
<p>在设计 Raft 算法的时候，有很多的点需要我们在各种备选方案中进行选择。在这种情况下，我们评估备选方案基于可理解性原则：解释各个备选方案有多大的难度（例如，Raft 的状态空间有多复杂，是否有微妙的暗示）？对于一个读者而言，完全理解这个方案和暗示是否容易？</p>
<p>我们意识到对这种可理解性分析上具有高度的主观性；尽管如此，我们使用了两种通常适用的技术来解决这个问题。第一个技术就是众所周知的问题分解：只要有可能，我们就将问题分解成几个相对独立的，可被解决的、可解释的和可理解的子问题。例如，Raft 算法被我们分成领导人选举，日志复制，安全性和角色改变几个部分。</p>
<p>我们使用的第二个方法是通过减少状态的数量来简化需要考虑的状态空间，使得系统更加连贯并且在可能的时候消除不确定性。特别的，所有的日志是不允许有空洞的，并且 Raft 限制了日志之间变成不一致状态的可能。尽管在大多数情况下我们都试图去消除不确定性，但是也有一些情况下不确定性可以提升可理解性。尤其是，随机化方法增加了不确定性，但是他们有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。我们使用随机化去简化 Raft 中领导人选举算法。</p>
<h2 id="5-Raft-一致性算法"><a href="#5-Raft-一致性算法" class="headerlink" title="5 Raft 一致性算法"></a>5 Raft 一致性算法</h2><p>Raft 是一种用来管理章节 2 中描述的复制日志的算法。图 2 为了参考之用，总结这个算法的简略版本，图 3 列举了这个算法的一些关键特性。图中的这些元素会在剩下的章节逐一介绍。</p>
<p>Raft 通过选举一个高贵的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并且当保证安全性的时候告诉其他的服务器应用日志条目到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可以宕机，可以和其他服务器失去连接，这时一个新的领导人会被选举出来。</p>
<p>通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论：</p>
<ul>
<li><strong>领导选举</strong>：一个新的领导人需要被选举出来，当现存的领导人宕机的时候（章节 5.2）</li>
<li><strong>日志复制</strong>：领导人必须从客户端接收日志然后复制到集群中的其他节点，并且强制要求其他节点的日志保持和自己相同。</li>
<li><strong>安全性</strong>：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到一个额外的选举机制（5.2 节）上的限制。</li>
</ul>
<p>在展示一致性算法之后，这一章节会讨论可用性的一些问题和计时在系统的作用。</p>
<p><strong>状态</strong>：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>所有服务器上持久存在的</th>
</tr>
</thead>
<tbody><tr>
<td>currentTerm</td>
<td>服务器最后一次知道的任期号（初始化为 0，持续递增）</td>
</tr>
<tr>
<td>votedFor</td>
<td>在当前获得选票的候选人的 Id</td>
</tr>
<tr>
<td>log[]</td>
<td>日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>状态</th>
<th>所有服务器上经常变的</th>
</tr>
</thead>
<tbody><tr>
<td>commitIndex</td>
<td>已知的最大的已经被提交的日志条目的索引值</td>
</tr>
<tr>
<td>lastApplied</td>
<td>最后被应用到状态机的日志条目索引值（初始化为 0，持续递增）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>状态</th>
<th>在领导人里经常改变的 （选举后重新初始化）</th>
</tr>
</thead>
<tbody><tr>
<td>nextIndex[]</td>
<td>对于每一个服务器，需要发送给他的下一个日志条目的索引值（初始化为领导人最后索引值加一）</td>
</tr>
<tr>
<td>matchIndex[]</td>
<td>对于每一个服务器，已经复制给他的日志的最高索引值</td>
</tr>
</tbody></table>
<p><strong>附加日志 RPC</strong>：</p>
<p>由领导人负责调用来复制日志指令；也会用作heartbeat</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>领导人的任期号</td>
</tr>
<tr>
<td>leaderId</td>
<td>领导人的 Id，以便于跟随者重定向请求</td>
</tr>
<tr>
<td>prevLogIndex</td>
<td>新的日志条目紧随之前的索引值</td>
</tr>
<tr>
<td>prevLogTerm</td>
<td>prevLogIndex 条目的任期号</td>
</tr>
<tr>
<td>entries[]</td>
<td>准备存储的日志条目（表示心跳时为空；一次性发送多个是为了提高效率）</td>
</tr>
<tr>
<td>leaderCommit</td>
<td>领导人已经提交的日志的索引值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>当前的任期号，用于领导人去更新自己</td>
</tr>
<tr>
<td>success</td>
<td>跟随者包含了匹配上 prevLogIndex 和 prevLogTerm 的日志时为真</td>
</tr>
</tbody></table>
<p>接收者实现：</p>
<ol>
<li>如果 <code>term &lt; currentTerm</code> 就返回 false （5.1 节）</li>
<li>如果日志在 prevLogIndex 位置处的日志条目的任期号和 prevLogTerm 不匹配，则返回 false （5.3 节）</li>
<li>如果已经存在的日志条目和新的产生冲突（索引值相同但是任期号不同），删除这一条和之后所有的 （5.3 节）</li>
<li>附加日志中尚未存在的任何新条目</li>
<li>如果 <code>leaderCommit &gt; commitIndex</code>，令 commitIndex 等于 leaderCommit 和 新日志条目索引值中较小的一个</li>
</ol>
<p><strong>请求投票 RPC</strong>：</p>
<p>由候选人负责调用用来征集选票（5.2 节）</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>候选人的任期号</td>
</tr>
<tr>
<td>candidateId</td>
<td>请求选票的候选人的 Id</td>
</tr>
<tr>
<td>lastLogIndex</td>
<td>候选人的最后日志条目的索引值</td>
</tr>
<tr>
<td>lastLogTerm</td>
<td>候选人最后日志条目的任期号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>当前任期号，以便于候选人去更新自己的任期号</td>
</tr>
<tr>
<td>voteGranted</td>
<td>候选人赢得了此张选票时为真</td>
</tr>
</tbody></table>
<p>接收者实现：</p>
<ol>
<li>如果<code>term &lt; currentTerm</code>返回 false （5.2 节）</li>
<li>如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节）</li>
</ol>
<p><strong>所有服务器需遵守的规则</strong>：</p>
<p>所有服务器：</p>
<ul>
<li>如果<code>commitIndex &gt; lastApplied</code>，那么就 lastApplied 加一，并把<code>log[lastApplied]</code>应用到状态机中（5.3 节）</li>
<li>如果接收到的 RPC 请求或响应中，任期号<code>T &gt; currentTerm</code>，那么就令 currentTerm 等于 T，并切换状态为跟随者（5.1 节）</li>
</ul>
<p>跟随者（5.2 节）：</p>
<ul>
<li>响应来自候选人和领导者的请求</li>
<li>如果在超过选举超时时间的情况之前都没有收到领导人的心跳，或者是候选人请求投票的，就自己变成候选人</li>
</ul>
<p>候选人（5.2 节）：</p>
<ul>
<li>在转变成候选人后就立即开始选举过程<ul>
<li>自增当前的任期号（currentTerm）</li>
<li>给自己投票</li>
<li>重置选举超时计时器</li>
<li>发送请求投票的 RPC 给其他所有服务器</li>
</ul>
</li>
<li>如果接收到大多数服务器的选票，那么就变成领导人</li>
<li>如果接收到来自新的领导人的附加日志 RPC，转变成跟随者</li>
<li>如果选举过程超时，再次发起一轮选举</li>
</ul>
<p>领导人：</p>
<ul>
<li>一旦成为领导人：发送空的附加日志 RPC（心跳）给其他所有的服务器；在一定的空余时间之后不停的重复发送，以阻止跟随者超时（5.2 节）</li>
<li>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节）</li>
<li>如果对于一个跟随者，最后日志条目的索引值大于等于 nextIndex，那么：发送从 nextIndex 开始的所有日志条目：<ul>
<li>如果成功：更新相应跟随者的 nextIndex 和 matchIndex</li>
<li>如果因为日志不一致而失败，减少 nextIndex 重试</li>
</ul>
</li>
<li>如果存在一个满足<code>N &gt; commitIndex</code>的 N，并且大多数的<code>matchIndex[i] ≥ N</code>成立，并且<code>log[N].term == currentTerm</code>成立，那么令 commitIndex 等于这个 N （5.3 和 5.4 节）</li>
</ul>
<p><img src="/images/arithmetic/raft-%E5%9B%BE2.png" alt="图 2 "></p>
<blockquote>
<p>图 2：一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）。</p>
</blockquote>
<table>
<thead>
<tr>
<th>特性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>选举安全特性</td>
<td>对于一个给定的任期号，最多只会有一个领导人被选举出来（5.2 节）</td>
</tr>
<tr>
<td>领导人只附加原则</td>
<td>领导人绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）</td>
</tr>
<tr>
<td>日志匹配原则</td>
<td>如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同（5.3 节）</td>
</tr>
<tr>
<td>领导人完全特性</td>
<td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）</td>
</tr>
<tr>
<td>状态机安全特性</td>
<td>如果一个领导人已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志（5.4.3 节）</td>
</tr>
</tbody></table>
<p><img src="/images/arithmetic/raft-%E5%9B%BE3.png" alt="图 3 "></p>
<blockquote>
<p>图 3：Raft 在任何时候都保证以上的各个特性。</p>
</blockquote>
<h3 id="5-1-Raft-基础"><a href="#5-1-Raft-基础" class="headerlink" title="5.1 Raft 基础"></a>5.1 Raft 基础</h3><p>一个 Raft 集群包含若干个服务器节点；通常是 5 个，这允许整个系统容忍 2 个节点的失效。在任何时刻，每一个服务器节点都处于这三个状态之一：领导人、跟随者或者候选人。在通常情况下，系统中只有一个领导人并且其他的节点全部都是跟随者。跟随者都是被动的：他们不会发送任何请求，只是简单的响应来自领导者或者候选人的请求。领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。第三种状态，候选人，是用来在 5.2 节描述的选举新领导人时使用。图 4 展示了这些状态和他们之间的转换关系；这些转换关系会在接下来进行讨论。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE4.png" alt="图 4 "></p>
<blockquote>
<p>图 4：服务器状态。跟随者只响应来自其他服务器的请求。如果跟随者接收不到消息，那么他就会变成候选人并发起一次选举。获得集群中大多数选票的候选人将成为领导者。在一个任期内，领导人一直都会是领导人直到自己宕机了。</p>
</blockquote>
<p><img src="/images/arithmetic/raft-%E5%9B%BE5.png" alt="图 5"></p>
<blockquote>
<p>图 5：时间被划分成一个个的任期，每个任期开始都是一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。</p>
</blockquote>
<p>Raft 把时间分割成任意长度的<strong>任期</strong>，如图 5。任期用连续的整数标记。每一段任期从一次<strong>选举</strong>开始，就像章节 5.2 描述的一样，一个或者多个候选人尝试成为领导者。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导者。</p>
<p>不同的服务器节点可能多次观察到任期之间的转换，但在某些情况下，一个节点也可能观察不到任何一次选举或者整个任期全程。任期在 Raft 算法中充当逻辑时钟的作用，这会允许服务器节点查明一些过期的信息比如陈旧的领导者。每一个节点存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号；如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。如果一个候选人或者领导者发现自己的任期号过期了，那么他会立即恢复成跟随者状态。如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。</p>
<p>Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（RequestVote） RPCs 由候选人在选举期间发起（章节  5.2），然后附加条目（AppendEntries）RPCs 由领导人发起，用来复制日志和提供一种心跳机制（章节 5.3）。第 7 节为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。</p>
<h3 id="5-2-领导人选举"><a href="#5-2-领导人选举" class="headerlink" title="5.2 领导人选举"></a>5.2 领导人选举</h3><p>Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。一个服务器节点继续保持着跟随者状态只要他从领导人或者候选者处接收到有效的 RPCs。领导者周期性的向所有跟随者发送心跳包（即不包含日志项内容的附加日志项 RPCs）来维持自己的权威。如果一个跟随者在一段时间里没有接收到任何消息，也就是<strong>选举超时</strong>，那么他就会认为系统中没有可用的领导者,并且发起选举以选出新的领导者。</p>
<p>要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人会继续保持着当前状态直到以下三件事情之一发生：(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导者，(c) 一段时间之后没有任何一个获胜的人。这些结果会分别的在下面的段落里进行讨论。</p>
<p>当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则（注意：5.4 节在投票上增加了一点额外的限制）。要求大多数选票的规则确保了最多只会有一个候选人赢得此次选举（图 3 中的选举安全性）。一旦候选人赢得选举，他就立即成为领导人。然后他会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。</p>
<p>在等待投票的时候，候选人可能会从其他的服务器接收到声明它是领导人的附加日志项 RPC。如果这个领导人的任期号（包含在此次的 RPC中）不小于候选人当前的任期号，那么候选人会承认领导人合法并回到跟随者状态。 如果此次 RPC 中的任期号比自己小，那么候选人就会拒绝这次的 RPC 并且继续保持候选人状态。</p>
<p>第三种可能的结果是候选人既没有赢得选举也没有输：如果有多个跟随者同时成为候选人，那么选票可能会被瓜分以至于没有候选人可以赢得大多数人的支持。当这种情况发生的时候，每一个候选人都会超时，然后通过增加当前任期号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。</p>
<p>Raft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，选举超时时间是从一个固定的区间（例如 150-300 毫秒）随机选择。这样可以把服务器都分散开以至于在大多数情况下只有一个服务器会选举超时；然后他赢得选举并在其他服务器超时之前发送心跳包。同样的机制被用在选票瓜分的情况下。每一个候选人在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。9.3 节展示了这种方案能够快速的选出一个领导人。</p>
<p>领导人选举这个例子，体现了可理解性原则是如何指导我们进行方案设计的。起初我们计划使用一种排名系统：每一个候选人都被赋予一个唯一的排名，供候选人之间竞争时进行选择。如果一个候选人发现另一个候选人拥有更高的排名，那么他就会回到跟随者状态，这样高排名的候选人能够更加容易的赢得下一次选举。但是我们发现这种方法在可用性方面会有一点问题（如果高排名的服务器宕机了，那么低排名的服务器可能会超时并再次进入候选人状态。而且如果这个行为发生得足够快，则可能会导致整个选举过程都被重置掉）。我们针对算法进行了多次调整，但是每次调整之后都会有新的问题。最终我们认为随机重试的方法是更加明显和易于理解的。</p>
<h3 id="5-3-日志复制"><a href="#5-3-日志复制" class="headerlink" title="5.3 日志复制"></a>5.3 日志复制</h3><p>一旦一个领导人被选举出来，他就开始为客户端提供服务。客户端的每一个请求都包含一条被复制状态机执行的指令。领导人把这条指令作为一条新的日志条目附加到日志中去，然后并行的发起附加条目 RPCs 给其他的服务器，让他们复制这条日志条目。当这条日志条目被安全的复制（下面会介绍），领导人会应用这条日志条目到它的状态机中然后把执行的结果返回给客户端。如果跟随者崩溃或者运行缓慢，再或者网络丢包，领导人会不断的重复尝试附加日志条目 RPCs （尽管已经回复了客户端）直到所有的跟随者都最终存储了所有的日志条目。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE6.png" alt="图 6"></p>
<blockquote>
<p>图 6：日志由有序序号标记的条目组成。每个条目都包含创建时的任期号（图中框中的数字），和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候，就认为是可以提交了。</p>
</blockquote>
<p>日志以图 6 展示的方式组织。每一个日志条目存储一条状态机指令和从领导人收到这条指令时的任期号。日志中的任期号用来检查是否出现不一致的情况，同时也用来保证图 3 中的某些性质。每一条日志条目同时也都有一个整数索引值来表明它在日志中的位置。</p>
<p>领导人来决定什么时候把日志条目应用到状态机中是安全的；这种日志条目被称为<strong>已提交</strong>。Raft 算法保证所有已提交的日志条目都是持久化的并且最终会被所有可用的状态机执行。在领导人将创建的日志条目复制到大多数的服务器上的时候，日志条目就会被提交（例如在图 6 中的条目 7）。同时，领导人的日志中之前的所有日志条目也都会被提交，包括由其他领导人创建的条目。5.4 节会讨论某些当在领导人改变之后应用这条规则的隐晦内容，同时他也展示了这种提交的定义是安全的。领导人跟踪了最大的将会被提交的日志项的索引，并且索引值会被包含在未来的所有附加日志 RPCs （包括心跳包），这样其他的服务器才能最终知道领导人的提交位置。一旦跟随者知道一条日志条目已经被提交，那么他也会将这个日志条目应用到本地的状态机中（按照日志的顺序）。</p>
<p>我们设计了 Raft 的日志机制来维护一个不同服务器的日志之间的高层次的一致性。这么做不仅简化了系统的行为也使得更加可预计，同时他也是安全性保证的一个重要组件。Raft 维护着以下的特性，这些同时也组成了图 3 中的日志匹配特性：</p>
<ul>
<li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们存储了相同的指令。</li>
<li>如果在不同的日志中的两个条目拥有相同的索引和任期号，那么他们之前的所有日志条目也全部相同。</li>
</ul>
<p>第一个特性来自这样的一个事实，领导人最多在一个任期里在指定的一个日志索引位置创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。第二个特性由附加日志 RPC 的一个简单的一致性检查所保证。在发送附加日志 RPC 的时候，领导人会把新的日志条目紧接着之前的条目的索引位置和任期号包含在里面。如果跟随者在它的日志中找不到包含相同索引位置和任期号的条目，那么他就会拒绝接收新的日志条目。一致性检查就像一个归纳步骤：一开始空的日志状态肯定是满足日志匹配特性的，然后一致性检查保护了日志匹配特性当日志扩展的时候。因此，每当附加日志 RPC 返回成功时，领导人就知道跟随者的日志一定是和自己相同的了。</p>
<p>在正常的操作中，领导人和跟随者的日志保持一致性，所以附加日志 RPC 的一致性检查从来不会失败。然而，领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。图 7 展示了跟随者的日志可能和新的领导人不同的方式。跟随者可能会丢失一些在新的领导人中有的日志条目，他也可能拥有一些领导人没有的日志条目，或者两者都发生。丢失或者多出日志条目可能会持续多个任期。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE7.png" alt="图 7"></p>
<blockquote>
<p>图 7：当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。例如，场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p>
</blockquote>
<p>在 Raft 算法中，领导人处理不一致是通过强制跟随者直接复制自己的日志来解决了。这意味着在跟随者中的冲突的日志条目会被领导人的日志覆盖。5.4 节会阐述如何通过增加一些限制来使得这样的操作是安全的。</p>
<p>要使得跟随者的日志进入和自己一致的状态，领导人必须找到最后两者达成一致的地方，然后删除从那个点之后的所有日志条目，发送自己的日志给跟随者。所有的这些操作都在进行附加日志 RPCs 的一致性检查时完成。领导人针对每一个跟随者维护了一个 <strong>nextIndex</strong>，这表示下一个需要发送给跟随者的日志条目的索引地址。当一个领导人刚获得权力的时候，他初始化所有的 nextIndex 值为自己的最后一条日志的index加1（图 7 中的 11）。如果一个跟随者的日志和领导人不一致，那么在下一次的附加日志 RPC 时的一致性检查就会失败。在被跟随者拒绝之后，领导人就会减小 nextIndex 值并进行重试。最终 nextIndex 会在某个位置使得领导人和跟随者的日志达成一致。当这种情况发生，附加日志 RPC 就会成功，这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志。一旦附加日志 RPC 成功，那么跟随者的日志就会和领导人保持一致，并且在接下来的任期里一直继续保持。</p>
<p>如果需要的话，算法可以通过减少被拒绝的附加日志 RPCs 的次数来优化。例如，当附加日志 RPC 的请求被拒绝的时候，跟随者可以包含冲突的条目的任期号和自己存储的那个任期的最早的索引地址。借助这些信息，领导人可以减小 nextIndex 越过所有那个任期冲突的所有日志条目；这样就变成每个任期需要一次附加条目 RPC 而不是每个条目一次。在实践中，我们十分怀疑这种优化是否是必要的，因为失败是很少发生的并且也不大可能会有这么多不一致的日志。</p>
<p>通过这种机制，领导人在获得权力的时候就不需要任何特殊的操作来恢复一致性。他只需要进行正常的操作，然后日志就能自动的在回复附加日志 RPC 的一致性检查失败的时候自动趋于一致。领导人从来不会覆盖或者删除自己的日志（图 3 的领导人只附加特性）。</p>
<p>日志复制机制展示出了第 2 节中形容的一致性特性：Raft 能够接受，复制并应用新的日志条目只要大部分的机器是工作的；在通常的情况下，新的日志条目可以在一次 RPC 中被复制给集群中的大多数机器；并且单个的缓慢的跟随者不会影响整体的性能。</p>
<h3 id="5-4-安全性"><a href="#5-4-安全性" class="headerlink" title="5.4 安全性"></a>5.4 安全性</h3><p>前面的章节里描述了 Raft 算法是如何选举和复制日志的。然而，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。例如，一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。</p>
<p>这一节通过在领导选举的时候增加一些限制来完善 Raft 算法。这一限制保证了任何的领导人对于给定的任期号，都拥有了之前任期的所有被提交的日志条目（图 3 中的领导人完整特性）。增加这一选举时的限制，我们对于提交时的规则也更加清晰。最终，我们将展示对于领导人完整特性的简要证明，并且说明领导人是如何领导复制状态机的做出正确行为的。</p>
<h4 id="5-4-1-选举限制"><a href="#5-4-1-选举限制" class="headerlink" title="5.4.1 选举限制"></a>5.4.1 选举限制</h4><p>在任何基于领导人的一致性算法中，领导人都必须存储所有已经提交的日志条目。在某些一致性算法中，例如 Viewstamped Replication，某个节点即使是一开始并没有包含所有已经提交的日志条目，它也能被选为领导者。这些算法都包含一些额外的机制来识别丢失的日志条目并把他们传送给新的领导人，要么是在选举阶段要么在之后很快进行。不幸的是，这种方法会导致相当大的额外的机制和复杂性。Raft 使用了一种更加简单的方法，它可以保证所有之前的任期号中已经提交的日志条目在选举的时候都会出现在新的领导人中，不需要传送这些日志条目给领导人。这意味着日志条目的传送是单向的，只从领导人传给跟随者，并且领导人从不会覆盖自身本地日志中已经存在的条目。</p>
<p>Raft 使用投票的方式来阻止一个候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果候选人的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。</p>
<p>Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</p>
<h4 id="5-4-2-提交之前任期内的日志条目"><a href="#5-4-2-提交之前任期内的日志条目" class="headerlink" title="5.4.2 提交之前任期内的日志条目"></a>5.4.2 提交之前任期内的日志条目</h4><p>如同 5.3 节介绍的那样，领导人知道一条当前任期内的日志记录是可以被提交的，只要它被存储到了大多数的服务器上。如果一个领导人在提交日志条目之前崩溃了，未来后续的领导人会继续尝试复制这条日志记录。然而，一个领导人不能断定一个之前任期里的日志条目被保存到大多数服务器上的时候就一定已经提交了。图 8 展示了一种情况，一条已经被存储到大多数节点上的老日志条目，也依然有可能会被未来的领导人覆盖掉。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE8.png" alt="图 8"></p>
<blockquote>
<p>图 8：如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交。在 (a) 中，S1 是领导者，部分的复制了索引位置 2 的日志条目。在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过 S3、S4 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。然后到 (c)，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。如果 S1 在 (d) 中又崩溃了，S5 可以重新被选举成功（通过来自 S2，S3 和 S4 的选票），然后覆盖了他们在索引 2 处的日志。反之，如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）。 这样在同一时刻就同时保证了，之前的所有老的日志条目就会被提交。</p>
</blockquote>
<p>为了消除图 8 里描述的情况，Raft 永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目通过计算副本数目可以被提交；一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。在某些情况下，领导人可以安全的知道一个老的日志条目是否已经被提交（例如，该条目是否存储到所有服务器上），但是 Raft 为了简化问题使用一种更加保守的方法。</p>
<p>当领导人复制之前任期里的日志时，Raft 会为所有日志保留原始的任期号, 这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。</p>
<h4 id="5-4-3-安全性论证"><a href="#5-4-3-安全性论证" class="headerlink" title="5.4.3 安全性论证"></a>5.4.3 安全性论证</h4><p>在给定了完整的 Raft 算法之后，我们现在可以更加精确的讨论领导人完整性特性（这一讨论基于 9.2 节的安全性证明）。我们假设领导人完全性特性是不存在的，然后我们推出矛盾来。假设任期 T 的领导人（领导人 T）在任期内提交了一条日志条目，但是这条日志条目没有被存储到未来某个任期的领导人的日志中。设大于 T 的最小任期 U 的领导人 U 没有这条日志条目。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE9.png" alt="图 9"></p>
<blockquote>
<p>图 9：如果 S1 （任期 T 的领导者）提交了一条新的日志在它的任期里，然后 S5 在之后的任期 U 里被选举为领导人，然后至少会有一个机器，如 S3，既拥有来自 S1 的日志，也给 S5 投票了。</p>
</blockquote>
<ol>
<li>在领导人 U 选举的时候一定没有那条被提交的日志条目（领导人从不会删除或者覆盖任何条目）。</li>
<li>领导人 T 复制这条日志条目给集群中的大多数节点，同时，领导人U 从集群中的大多数节点赢得了选票。因此，至少有一个节点（投票者、选民）同时接受了来自领导人T 的日志条目，并且给领导人U 投票了，如图 9。这个投票者是产生这个矛盾的关键。</li>
<li>这个投票者必须在给领导人 U 投票之前先接受了从领导人 T 发来的已经被提交的日志条目；否则他就会拒绝来自领导人 T 的附加日志请求（因为此时他的任期号会比 T 大）。</li>
<li>投票者在给领导人 U 投票时依然保存有这条日志条目，因为任何中间的领导人都包含该日志条目（根据上述的假设），领导人从不会删除条目，并且跟随者只有在和领导人冲突的时候才会删除条目。</li>
<li>投票者把自己选票投给领导人 U 时，领导人 U 的日志必须和投票者自己一样新。这就导致了两者矛盾之一。</li>
<li>首先，如果投票者和领导人 U 的最后一条日志的任期号相同，那么领导人 U 的日志至少和投票者一样长，所以领导人 U 的日志一定包含所有投票者的日志。这是另一处矛盾，因为投票者包含了那条已经被提交的日志条目，但是在上述的假设里，领导人 U 是不包含的。</li>
<li>除此之外，领导人 U 的最后一条日志的任期号就必须比投票人大了。此外，他也比 T 大，因为投票人的最后一条日志的任期号至少和 T 一样大（他包含了来自任期 T 的已提交的日志）。创建了领导人 U 最后一条日志的之前领导人一定已经包含了那条被提交的日志（根据上述假设，领导人 U 是第一个不包含该日志条目的领导人）。所以，根据日志匹配特性，领导人 U 一定也包含那条被提交的日志，这里产生矛盾。</li>
<li>这里完成了矛盾。因此，所有比 T 大的领导人一定包含了所有来自 T 的已经被提交的日志。</li>
<li>日志匹配原则保证了未来的领导人也同时会包含被间接提交的条目，例如图 8 (d) 中的索引 2。</li>
</ol>
<p>通过领导人完全特性，我们就能证明图 3 中的状态机安全特性，即如果服务器已经在某个给定的索引值应用了日志条目到自己的状态机里，那么其他的服务器不会应用一个不一样的日志到同一个索引值上。在一个服务器应用一条日志条目到他自己的状态机中时，他的日志必须和领导人的日志，在该条目和之前的条目上相同，并且已经被提交。现在我们来考虑在任何一个服务器应用一个指定索引位置的日志的最小任期；日志完全特性保证拥有更高任期号的领导人会存储相同的日志条目，所以之后的任期里应用某个索引位置的日志条目也会是相同的值。因此，状态机安全特性是成立的。</p>
<p>最后，Raft 要求服务器按照日志中索引位置顺序应用日志条目。和状态机安全特性结合起来看，这就意味着所有的服务器会应用相同的日志序列集到自己的状态机中，并且是按照相同的顺序。</p>
<h3 id="5-5-跟随者和候选人崩溃"><a href="#5-5-跟随者和候选人崩溃" class="headerlink" title="5.5 跟随者和候选人崩溃"></a>5.5 跟随者和候选人崩溃</h3><p>到目前为止，我们都只关注了领导人崩溃的情况。跟随者和候选人崩溃后的处理方式比领导人要简单的多，并且他们的处理方式是相同的。如果跟随者或者候选人崩溃了，那么后续发送给他们的 RPCs 都会失败。Raft 中处理这种失败就是简单的通过无限的重试；如果崩溃的机器重启了，那么这些 RPC 就会完整的成功。如果一个服务器在完成了一个 RPC，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。Raft 的 RPCs 都是幂等的，所以这样重试不会造成任何问题。例如一个跟随者如果收到附加日志请求但是他已经包含了这一日志，那么他就会直接忽略这个新的请求。</p>
<h3 id="5-6-时间和可用性"><a href="#5-6-时间和可用性" class="headerlink" title="5.6 时间和可用性"></a>5.6 时间和可用性</h3><p>Raft 的要求之一就是安全性不能依赖时间：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。但是，可用性（系统可以及时的响应客户端）不可避免的要依赖于时间。例如，如果消息交换比服务器故障间隔时间长，候选人将没有足够长的时间来赢得选举；没有一个稳定的领导人，Raft 将无法工作。</p>
<p>领导人选举是 Raft 中对时间要求最为关键的方面。Raft 可以选举并维持一个稳定的领导人,只要系统满足下面的时间要求：</p>
<blockquote>
<p>广播时间（broadcastTime）  &lt;&lt;  选举超时时间（electionTimeout） &lt;&lt;  平均故障间隔时间（MTBF）</p>
</blockquote>
<p>在这个不等式中，广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间；选举超时时间就是在 5.2 节中介绍的选举的超时时间限制；然后平均故障间隔时间就是对于一台服务器而言，两次故障之间的平均时间。广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态；通过随机化选举超时时间的方法，这个不等式也使得选票瓜分的情况变得不可能。选举超时时间应该要比平均故障间隔时间小上几个数量级，这样整个系统才能稳定的运行。当领导人崩溃后，整个系统会大约相当于选举超时的时间里不可用；我们希望这种情况在整个系统的运行中很少出现。</p>
<p>广播时间和平均故障间隔时间是由系统决定的，但是选举超时时间是我们自己选择的。Raft 的 RPCs 需要接收方将信息持久化的保存到稳定存储中去，所以广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术。因此，选举超时时间可能需要在 10 毫秒到 500 毫秒之间。大多数的服务器的平均故障间隔时间都在几个月甚至更长，很容易满足时间的需求。</p>
<h2 id="6-集群成员变化"><a href="#6-集群成员变化" class="headerlink" title="6 集群成员变化"></a>6 集群成员变化</h2><p>到目前为止，我们都假设集群的配置（加入到一致性算法的服务器集合）是固定不变的。但是在实践中，偶尔是会改变集群的配置的，例如替换那些宕机的机器或者改变复制级别。尽管可以通过暂停整个集群，更新所有配置，然后重启整个集群的方式来实现，但是在更改的时候集群会不可用。另外，如果存在手工操作步骤，那么就会有操作失误的风险。为了避免这样的问题，我们决定自动化配置改变并且将其纳入到 Raft 一致性算法中来。</p>
<p>为了让配置修改机制能够安全，那么在转换的过程中不能够存在任何时间点使得两个领导人同时被选举成功在同一个任期里。不幸的是，任何服务器直接从旧的配置直接转换到新的配置的方案都是不安全的。一次性自动的转换所有服务器是不可能的，所以在转换期间整个集群存在划分成两个独立的大多数群体的可能性（见图 10）。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE10.png" alt="图 10"></p>
<blockquote>
<p>图 10：直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在任何的时候进行转换。在这个例子中，集群配额从 3 台机器变成了 5 台。不幸的是，存在这样的一个时间点，两个不同的领导人在同一个任期里都可以被选举成功。一个是通过旧的配置，一个通过新的配置。</p>
</blockquote>
<p>为了保证安全性，配置更改必须使用两阶段方法。目前有很多种两阶段的实现。例如，有些系统在第一阶段停掉旧的配置所以集群就不能处理客户端请求；然后在第二阶段在启用新的配置。在 Raft 中，集群先切换到一个过渡的配置，我们称之为共同一致；一旦共同一致已经被提交了，那么系统就切换到新的配置上。共同一致是老配置和新配置的结合：</p>
<ul>
<li>日志条目被复制给集群中新、老配置的所有服务器。</li>
<li>新、旧配置的服务器都可以成为领导人。</li>
<li>达成一致（针对选举和提交）需要分别在两种配置上获得大多数的支持。</li>
</ul>
<p>共同一致允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换过程。此外，共同一致可以让集群在配置转换的过程人依然响应客户端的请求。</p>
<p>集群配置在复制日志中以特殊的日志条目来存储和通信；图 11 展示了配置转换的过程。当一个领导人接收到一个改变配置从 C-old 到 C-new 的请求，他会为了共同一致存储配置（图中的 C-old,new），以前面描述的日志条目和副本的形式。一旦一个服务器将新的配置日志条目增加到它的日志中，他就会用这个配置来做出未来所有的决定（服务器总是使用最新的配置，无论他是否已经被提交）。这意味着领导人要使用  C-old,new 的规则来决定日志条目 C-old,new 什么时候需要被提交。如果领导人崩溃了，被选出来的新领导人可能是使用 C-old 配置也可能是 C-old,new 配置，这取决于赢得选举的候选人是否已经接收到了 C-old,new 配置。在任何情况下， C-new 配置在这一时期都不会单方面的做出决定。</p>
<p>一旦 C-old,new 被提交，那么无论是 C-old 还是 C-new，在没有经过他人批准的情况下都不可能做出决定，并且领导人完全特性保证了只有拥有 C-old,new 日志条目的服务器才有可能被选举为领导人。这个时候，领导人创建一条关于 C-new 配置的日志条目并复制给集群就是安全的了。再者，每个服务器在见到新的配置的时候就会立即生效。当新的配置在 C-new 的规则下被提交，旧的配置就变得无关紧要，同时不使用新的配置的服务器就可以被关闭了。如图 11，C-old 和 C-new 没有任何机会同时做出单方面的决定；这保证了安全性。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE11.png" alt="图 11"></p>
<blockquote>
<p>图 11：一个配置切换的时间线。虚线表示已经被创建但是还没有被提交的条目，实线表示最后被提交的日志条目。领导人首先创建了 C-old,new 的配置条目在自己的日志中，并提交到 C-old,new 中（C-old 的大多数和  C-new 的大多数）。然后他创建 C-new 条目并提交到 C-new 中的大多数。这样就不存在  C-new 和 C-old 可以同时做出决定的时间点。</p>
</blockquote>
<p>在关于重新配置还有三个问题需要提出。第一个问题是，新的服务器可能初始化没有存储任何的日志条目。当这些服务器以这种状态加入到集群中，那么他们需要一段时间来更新追赶，这时还不能提交新的日志条目。为了避免这种可用性的间隔时间，Raft 在配置更新的时候使用了一种额外的阶段，在这个阶段，新的服务器以没有投票权身份加入到集群中来（领导人复制日志给他们，但是不考虑他们是大多数）。一旦新的服务器追赶上了集群中的其他机器，重新配置可以像上面描述的一样处理。</p>
<p>第二个问题是，集群的领导人可能不是新配置的一员。在这种情况下，领导人就会在提交了 C-new 日志之后退位（回到跟随者状态）。这意味着有这样的一段时间，领导人管理着集群，但是不包括他自己；他复制日志但是不把他自己算作是大多数之一。当 C-new 被提交时，会发生领导人过渡，因为这时是最早新的配置可以独立工作的时间点（将总是能够在 C-new 配置下选出新的领导人）。在此之前，可能只能从 C-old 中选出领导人。</p>
<p>第三个问题是，移除不在 C-new 中的服务器可能会扰乱集群。这些服务器将不会再接收到心跳，所以当选举超时，他们就会进行新的选举过程。他们会发送拥有新的任期号的请求投票 RPCs，这样会导致当前的领导人回退成跟随者状态。新的领导人最终会被选出来，但是被移除的服务器将会再次超时，然后这个过程会再次重复，导致整体可用性大幅降低。</p>
<p>为了避免这个问题，当服务器确认当前领导人存在时，服务器会忽略请求投票 RPCs。特别的，当服务器在当前最小选举超时时间内收到一个请求投票 RPC，他不会更新当前的任期号或者投出选票。这不会影响正常的选举，每个服务器在开始一次选举之前，至少等待一个最小选举超时时间。然而，这有利于避免被移除的服务器扰乱：如果领导人能够发送心跳给集群，那么他就不会被更大的任期号废黜。</p>
<h2 id="7-日志压缩"><a href="#7-日志压缩" class="headerlink" title="7 日志压缩"></a>7 日志压缩</h2><p>Raft 的日志在正常操作中不断的增长，但是在实际的系统中，日志不能无限制的增长。随着日志不断增长，他会占用越来越多的空间，花费越来越多的时间来重置。如果没有一定的机制去清除日志里积累的陈旧的信息，那么会带来可用性问题。</p>
<p>快照是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，然后到那个时间点之前的日志全部丢弃。快照技术被使用在 Chubby 和 ZooKeeper 中，接下来的章节会介绍 Raft 中的快照技术。</p>
<p>增量压缩的方法，例如日志清理或者日志结构合并树，都是可行的。这些方法每次只对一小部分数据进行操作，这样就分散了压缩的负载压力。首先，他们先选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。和简单操作整个数据集合的快照相比，需要增加复杂的机制来实现。状态机可以实现 LSM tree 使用和快照相同的接口，但是日志清除方法就需要修改 Raft 了。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE12.png" alt="图 12"></p>
<blockquote>
<p>图 12：一个服务器用新的快照替换了从 1 到 5 的条目，快照值存储了当前的状态。快照中包含了最后的索引位置和任期号。</p>
</blockquote>
<p>图 12 展示了 Raft 中快照的基础思想。每个服务器独立的创建快照，只包括已经被提交的日志。主要的工作包括将状态机的状态写入到快照中。Raft 也包含一些少量的元数据到快照中：<strong>最后被包含索引</strong>指的是被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志），<strong>最后被包含的任期</strong>指的是该条目的任期号。保留这些数据是为了支持快照后紧接着的第一个条目的附加日志请求时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。为了支持集群成员更新（第 6 节），快照中也将最后的一次配置作为最后一个条目存下来。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。</p>
<p>尽管通常服务器都是独立的创建快照，但是领导人必须偶尔的发送快照给一些落后的跟随者。这通常发生在当领导人已经丢弃了下一条需要发送给跟随者的日志条目的时候。幸运的是这种情况不是常规操作：一个与领导人保持同步的跟随者通常都会有这个条目。然而一个运行非常缓慢的跟随者或者新加入集群的服务器（第 6 节）将不会有这个条目。这时让这个跟随者更新到最新的状态的方式就是通过网络把快照发送给他们。</p>
<p><strong>安装快照 RPC</strong>：</p>
<p>由领导人调用以将快照的分块发送给跟随者。领导者总是按顺序发送分块。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>领导人的任期号</td>
</tr>
<tr>
<td>leaderId</td>
<td>领导人的 Id，以便于跟随者重定向请求</td>
</tr>
<tr>
<td>lastIncludedIndex</td>
<td>快照中包含的最后日志条目的索引值</td>
</tr>
<tr>
<td>lastIncludedTerm</td>
<td>快照中包含的最后日志条目的任期号</td>
</tr>
<tr>
<td>offset</td>
<td>分块在快照中的字节偏移量</td>
</tr>
<tr>
<td>data[]</td>
<td>原始数据</td>
</tr>
<tr>
<td>done</td>
<td>如果这是最后一个分块则为 true</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>结果</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>当前任期号（currentTerm），便于领导人更新自己</td>
</tr>
</tbody></table>
<p><strong>接收者实现</strong>：</p>
<ol>
<li>如果<code>term &lt; currentTerm</code>就立即回复</li>
<li>如果是第一个分块（offset 为 0）就创建一个新的快照</li>
<li>在指定偏移量写入数据</li>
<li>如果 done 是 false，则继续等待更多的数据</li>
<li>保存快照文件，丢弃具有较小索引的任何现有或部分快照</li>
<li>如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复</li>
<li>丢弃整个日志</li>
<li>使用快照重置状态机（并加载快照的集群配置）</li>
</ol>
<p><img src="/images/arithmetic/raft-%E5%9B%BE13.png" alt="图 13 "></p>
<blockquote>
<p>图 13：一个关于安装快照的简要概述。为了便于传输，快照都是被分成分块的；每个分块都给了跟随者生命的迹象，所以跟随者可以重置选举超时计时器。</p>
</blockquote>
<p>在这种情况下领导人使用一种叫做安装快照的新的 RPC 来发送快照给太落后的跟随者；见图 13。当跟随者通过这种  RPC 接收到快照时，他必须自己决定对于已经存在的日志该如何处理。通常快照会包含没有在接收者日志中存在的信息。在这种情况下，跟随者丢弃其整个日志；它全部被快照取代，并且可能包含与快照冲突的未提交条目。如果接收到的快照是自己日志的前面部分（由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是快照后面的条目仍然有效，必须保留。</p>
<p>这种快照的方式背离了 Raft 的强领导人原则，因为跟随者可以在不知道领导人情况下创建快照。但是我们认为这种背离是值得的。领导人的存在，是为了解决在达成一致性的时候的冲突，但是在创建快照的时候，一致性已经达成，这时不存在冲突了，所以没有领导人也是可以的。数据依然是从领导人传给跟随者，只是跟随者可以重新组织他们的数据了。</p>
<p>我们考虑过一种替代的基于领导人的快照方案，即只有领导人创建快照，然后发送给所有的跟随者。但是这样做有两个缺点。第一，发送快照会浪费网络带宽并且延缓了快照处理的时间。每个跟随者都已经拥有了所有产生快照需要的信息，而且很显然，自己从本地的状态中创建快照比通过网络接收别人发来的要经济。第二，领导人的实现会更加复杂。例如，领导人需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。</p>
<p>还有两个问题影响了快照的性能。首先，服务器必须决定什么时候应该创建快照。如果快照创建的过于频繁，那么就会浪费大量的磁盘带宽和其他资源；如果创建快照频率太低，他就要承受耗尽存储容量的风险，同时也增加了从日志重建的时间。一个简单的策略就是当日志大小达到一个固定大小的时候就创建一次快照。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。</p>
<p>第二个影响性能的问题就是写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作。解决方案是通过写时复制的技术，这样新的更新就可以被接收而不影响到快照。例如，具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。</p>
<h2 id="8-客户端交互"><a href="#8-客户端交互" class="headerlink" title="8 客户端交互"></a>8 客户端交互</h2><p>这一节将介绍客户端是如何和 Raft 进行交互的，包括客户端如何发现领导人和 Raft 是如何支持线性化语义的。这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p>
<p>Raft 中的客户端发送所有请求给领导人。当客户端启动的时候，他会随机挑选一个服务器进行通信。如果客户端第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供他最近接收到的领导人的信息（附加条目请求包含了领导人的网络地址）。如果领导人已经崩溃了，那么客户端的请求就会超时；客户端之后会再次重试随机挑选服务器的过程。</p>
<p>我们 Raft 的目标是要实现线性化语义（每一次操作立即执行，只执行一次，在他调用和收到回复之间）。但是，如上述，Raft 是可以执行同一条命令多次的：例如，如果领导人在提交了这条日志之后，但是在响应客户端之前崩溃了，那么客户端会和新的领导人重试这条指令，导致这条命令就被再次执行了。解决方案就是客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应。如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令。</p>
<p>只读的操作可以直接处理而不需要记录日志。但是，在不增加任何限制的情况下，这么做可能会冒着返回脏数据的风险，因为领导人响应客户端请求时可能已经被新的领导人作废了，但是他还不知道。线性化的读操作必须不能返回脏数据，Raft 需要使用两个额外的措施在不使用日志的情况下保证这一点。首先，领导人必须有关于被提交日志的最新信息。领导人完全特性保证了领导人一定拥有所有已经被提交的日志条目，但是在他任期开始的时候，他可能不知道那些是已经被提交的。为了知道这些信息，他需要在他的任期里提交一条日志条目。Raft 中通过领导人在任期开始的时候提交一个空白的没有任何操作的日志条目到日志中去来实现。第二，领导人在处理只读的请求之前必须检查自己是否已经被废黜了（他自己的信息已经变脏了如果一个更新的领导人被选举出来）。Raft 中通过让领导人在响应只读请求之前，先和集群中的大多数节点交换一次心跳信息来处理这个问题。可选的，领导人可以依赖心跳机制来实现一种租约的机制，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。</p>
<h2 id="9-算法实现和评估"><a href="#9-算法实现和评估" class="headerlink" title="9 算法实现和评估"></a>9 算法实现和评估</h2><p>我们已经为 RAMCloud 实现了 Raft 算法作为存储配置信息的复制状态机的一部分，并且帮助 RAMCloud 协调故障转移。这个 Raft 实现包含大约 2000 行 C++ 代码，其中不包括测试、注释和空行。这些代码是开源的。同时也有大约 25 个其他独立的第三方的基于这篇论文草稿的开源实现，针对不同的开发场景。同时，很多公司已经部署了基于 Raft 的系统。</p>
<p>这一节会从三个方面来评估 Raft 算法：可理解性、正确性和性能。</p>
<h3 id="9-1-可理解性"><a href="#9-1-可理解性" class="headerlink" title="9.1 可理解性"></a>9.1 可理解性</h3><p>为了和 Paxos 比较 Raft 算法的可理解能力，我们针对高层次的本科生和研究生，在斯坦福大学的高级操作系统课程和加州大学伯克利分校的分布式计算课程上，进行了一次学习的实验。我们分别拍了针对 Raft 和 Paxos 的视频课程，并准备了相应的小测验。Raft 的视频讲课覆盖了这篇论文的所有内容除了日志压缩；Paxos 讲课包含了足够的资料来创建一个等价的复制状态机，包括单决策 Paxos，多决策 Paxos，重新配置和一些实际系统需要的性能优化（例如领导人选举）。小测验测试一些对算法的基本理解和解释一些边角的示例。每个学生都是看完第一个视频，回答相应的测试，再看第二个视频，回答相应的测试。大约有一半的学生先进行 Paxos 部分，然后另一半先进行 Raft 部分，这是为了说明两者从第一部分的算法学习中获得的表现和经验的差异。我们计算参加人员的每一个小测验的得分来看参与者是否在 Raft 算法上更加容易理解。</p>
<p>我们尽可能的使得 Paxos 和 Raft 的比较更加公平。这个实验偏爱 Paxos 表现在两个方面：43 个参加者中有 15 个人在之前有一些  Paxos 的经验，并且 Paxos 的视频要长 14%。如表格 1 总结的那样，我们采取了一些措施来减轻这种潜在的偏见。我们所有的材料都可供审查。</p>
<table>
<thead>
<tr>
<th>关心</th>
<th>缓和偏见采取的手段</th>
<th>可供查看的材料</th>
</tr>
</thead>
<tbody><tr>
<td>相同的讲课质量</td>
<td>两者使用同一个讲师。Paxos 使用的是现在很多大学里经常使用的。Paxos 会长 14%。</td>
<td>视频</td>
</tr>
<tr>
<td>相同的测验难度</td>
<td>问题以难度分组，在两个测验里成对出现。</td>
<td>小测验</td>
</tr>
<tr>
<td>公平评分</td>
<td>使用评价量规。随机顺序打分，两个测验交替进行。</td>
<td>评价量规（rubric）</td>
</tr>
</tbody></table>
<blockquote>
<p>表 1：考虑到可能会存在的偏见，对于每种情况的解决方法，和相应的材料。</p>
</blockquote>
<p>参加者平均在 Raft 的测验中比 Paxos 高 4.9 分（总分 60，那么 Raft 的平均得分是 25.7，而 Paxos 是 20.8）；图 14 展示了每个参与者的得分。配置t-检验（又称student‘s t-test）表明，在 95% 的可信度下，真实的 Raft 分数分布至少比 Paxos 高 2.5 分。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE14.png" alt="图 14"></p>
<blockquote>
<p>图 14：一个散点图表示了 43 个学生在 Paxos 和 Raft 的小测验中的成绩。在对角线之上的点表示在 Raft 获得了更高分数的学生。</p>
</blockquote>
<p>我们也建立了一个线性回归模型来预测一个新的学生的测验成绩，基于以下三个因素：他们使用的是哪个小测验，之前对 Paxos 的经验，和学习算法的顺序。模型预测，对小测验的选择会产生 12.5 分的差别。这显著的高于之前的 4.9 分，因为很多学生在之前都已经有了对于 Paxos 的经验，这相当明显的帮助 Paxos，对 Raft 就没什么太大影响了。但是奇怪的是，模型预测对于先进行 Paxos 小测验的人而言，Raft的得分低了6.3分; 虽然我们不知道为什么，这似乎在统计上是有意义的。</p>
<p>我们同时也在测验之后调查了参与者，他们认为哪个算法更加容易实现和解释；这个的结果在图 15 上。压倒性的结果表明 Raft 算法更加容易实现和解释（41 人中的 33个）。但是，这种自己报告的结果不如参与者的成绩更加可信，并且参与者可能因为我们的 Raft 更加易于理解的假说而产生偏见。</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE15.png" alt="图 15"></p>
<blockquote>
<p>图 15：通过一个 5 分制的问题，参与者（左边）被问哪个算法他们觉得在一个高效正确的系统里更容易实现，右边被问哪个更容易向学生解释。</p>
</blockquote>
<p>关于 Raft 用户学习有一个更加详细的讨论。</p>
<h3 id="9-2-正确性"><a href="#9-2-正确性" class="headerlink" title="9.2 正确性"></a>9.2 正确性</h3><p>在第 5 节，我们已经制定了正式的规范，和对一致性机制的安全性证明。这个正式规范使用 TLA+ 规范语言使图 2 中总结的信息非常清晰。它长约400行，并作为证明的主题。同时对于任何想实现 Raft 的人也是十分有用的。我们通过 TLA 证明系统非常机械的证明了日志完全特性。然而，这个证明依赖的约束前提还没有被机械证明（例如，我们还没有证明规范的类型安全）。而且，我们已经写了一个非正式的证明关于状态机安全性是完备的，并且是相当清晰的（大约 3500 个词）。</p>
<h3 id="9-3-性能"><a href="#9-3-性能" class="headerlink" title="9.3 性能"></a>9.3 性能</h3><p>Raft 和其他一致性算法例如 Paxos 有着差不多的性能。在性能方面，最重要的关注点是，当领导人被选举成功时，什么时候复制新的日志条目。Raft 通过很少数量的消息包（一轮从领导人到集群大多数机器的消息）就达成了这个目的。同时，进一步提升 Raft 的性能也是可行的。例如，很容易通过支持批量操作和管道操作来提高吞吐量和降低延迟。对于其他一致性算法已经提出过很多性能优化方案；其中有很多也可以应用到 Raft 中来，但是我们暂时把这个问题放到未来的工作中去。</p>
<p>我们使用我们自己的 Raft 实现来衡量 Raft 领导人选举的性能并且回答两个问题。首先，领导人选举的过程收敛是否快速？第二，在领导人宕机之后，最小的系统宕机时间是多久？</p>
<p><img src="/images/arithmetic/raft-%E5%9B%BE16.png" alt="图 16"></p>
<blockquote>
<p>图 16：发现并替换一个已经崩溃的领导人的时间。上面的图考察了在选举超时时间上的随机化程度，下面的图考察了最小选举超时时间。每条线代表了 1000 次实验（除了 150-150 毫秒只试了 100 次），和相应的确定的选举超时时间。例如，150-155 毫秒意思是，选举超时时间从这个区间范围内随机选择并确定下来。这个实验在一个拥有 5 个节点的集群上进行，其广播时延大约是 15 毫秒。对于 9 个节点的集群，结果也差不多。</p>
</blockquote>
<p>为了衡量领导人选举，我们反复的使一个拥有五个节点的服务器集群的领导人宕机，并计算需要多久才能发现领导人已经宕机并选出一个新的领导人（见图 16）。为了构建一个最坏的场景，在每一的尝试里，服务器都有不同长度的日志，意味着有些候选人是没有成为领导人的资格的。另外，为了促成选票瓜分的情况，我们的测试脚本在终止领导人之前同步的发送了一次心跳广播（这大约和领导人在崩溃前复制一个新的日志给其他机器很像）。领导人均匀的随机的在心跳间隔里宕机，也就是最小选举超时时间的一半。因此，最小宕机时间大约就是最小选举超时时间的一半。</p>
<p>图 16 中上面的图表明，只需要在选举超时时间上使用很少的随机化就可以大大避免选票被瓜分的情况。在没有随机化的情况下，在我们的测试里，选举过程往往都需要花费超过 10 秒钟由于太多的选票瓜分的情况。仅仅增加 5 毫秒的随机化时间，就大大的改善了选举过程，现在平均的宕机时间只有 287 毫秒。增加更多的随机化时间可以大大改善最坏情况：通过增加 50 毫秒的随机化时间，最坏的完成情况（1000 次尝试）只要 513 毫秒。</p>
<p>图 16 中下面的图显示，通过减少选举超时时间可以减少系统的宕机时间。在选举超时时间为 12-24 毫秒的情况下，只需要平均 35 毫秒就可以选举出新的领导人（最长的一次花费了 152 毫秒）。然而，进一步降低选举超时时间的话就会违反 Raft 的时间不等式需求：在选举新领导人之前，领导人就很难发送完心跳包。这会导致没有意义的领导人改变并降低了系统整体的可用性。我们建议使用更为保守的选举超时时间，比如 150-300 毫秒；这样的时间不大可能导致没有意义的领导人改变，而且依然提供不错的可用性。</p>
<h2 id="10-相关工作"><a href="#10-相关工作" class="headerlink" title="10 相关工作"></a>10 相关工作</h2><p>已经有很多关于一致性算法的工作被发表出来，其中很多都可以归到下面的类别中：</p>
<ul>
<li>Lamport 关于 Paxos 的原始描述，和尝试描述的更清晰。</li>
<li>关于 Paxos 的更详尽的描述，补充遗漏的细节并修改算法，使得可以提供更加容易的实现基础。</li>
<li>实现一致性算法的系统，例如 Chubby，ZooKeeper 和 Spanner。对于 Chubby 和 Spanner 的算法并没有公开发表其技术细节，尽管他们都声称是基于 Paxos 的。ZooKeeper 的算法细节已经发表，但是和 Paxos 着实有着很大的差别。</li>
<li>Paxos 可以应用的性能优化。</li>
<li>Oki 和 Liskov 的 Viewstamped Replication（VR），一种和 Paxos 差不多的替代算法。原始的算法描述和分布式传输协议耦合在了一起，但是核心的一致性算法在最近的更新里被分离了出来。VR 使用了一种基于领导人的方法，和 Raft 有很多相似之处。</li>
</ul>
<p>Raft 和 Paxos 最大的不同之处就在于 Raft 的强领导特性：Raft 使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就可以使得算法更加容易理解。例如，在 Paxos 中，领导人选举和基本的一致性协议是正交的：领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求的。但是，这样就增加了多余的机制：Paxos 同时包含了针对基本一致性要求的两阶段提交协议和针对领导人选举的独立的机制。相比较而言，Raft 就直接将领导人选举纳入到一致性算法中，并作为两阶段一致性的第一步。这样就减少了很多机制。</p>
<p>像 Raft 一样，VR 和 ZooKeeper 也是基于领导人的，因此他们也拥有一些 Raft 的优点。但是，Raft 比 VR 和 ZooKeeper 拥有更少的机制因为 Raft 尽可能的减少了非领导人的功能。例如，Raft 中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。根据 ZooKeeper 公开的资料看，它的日志条目也是双向传输的，但是它的实现更像 Raft。</p>
<p>和上述我们提及的其他基于一致性的日志复制算法中，Raft 的消息类型更少。例如，我们数了一下 VR 和 ZooKeeper 使用的用来基本一致性需要和成员改变的消息数（排除了日志压缩和客户端交互，因为这些都比较独立且和算法关系不大）。VR 和 ZooKeeper 都分别定义了 10 中不同的消息类型，相对的，Raft 只有 4 中消息类型（两种 RPC 请求和对应的响应）。Raft 的消息都稍微比其他算法的要信息量大，但是都很简单。另外，VR 和 ZooKeeper 都在领导人改变时传输了整个日志；所以为了能够实践中使用，额外的消息类型就很必要了。</p>
<p>Raft 的强领导人模型简化了整个算法，但是同时也排斥了一些性能优化的方法。例如，平等主义 Paxos （EPaxos）在某些没有领导人的情况下可以达到很高的性能。平等主义 Paxos 充分发挥了在状态机指令中的交换性。任何服务器都可以在一轮通信下就提交指令，除非其他指令同时被提出了。然而，如果指令都是并发的被提出，并且互相之间不通信沟通，那么 EPaxos 就需要额外的一轮通信。因为任何服务器都可以提交指令，所以 EPaxos 在服务器之间的负载均衡做的很好，并且很容易在 WAN 网络环境下获得很低的延迟。但是，他在 Paxos 上增加了非常明显的复杂性。</p>
<p>一些集群成员变换的方法已经被提出或者在其他的工作中被实现，包括 Lamport 的原始的讨论，VR 和 SMART。我们选择使用共同一致的方法因为他对一致性协议的其他部分影响很小，这样我们只需要很少的一些机制就可以实现成员变换。Lamport 的基于 α 的方法之所以没有被 Raft 选择是因为它假设在没有领导人的情况下也可以达到一致性。和 VR 和 SMART 相比较，Raft 的重新配置算法可以在不限制正常请求处理的情况下进行；相比较的，VR 需要停止所有的处理过程，SMART 引入了一个和 α 类似的方法，限制了请求处理的数量。Raft 的方法同时也需要更少的额外机制来实现，和 VR、SMART 比较而言。</p>
<h2 id="11-结论"><a href="#11-结论" class="headerlink" title="11 结论"></a>11 结论</h2><p>算法的设计通常会把正确性，效率或者简洁作为主要的目标。尽管这些都是很有意义的目标，但是我们相信，可理解性也是一样的重要。在开发者把算法应用到实际的系统中之前，这些目标没有一个会被实现，这些都会必然的偏离发表时的形式。除非开发人员对这个算法有着很深的理解并且有着直观的感觉，否则将会对他们而言很难在实现的时候保持原有期望的特性。</p>
<p>在这篇论文中，我们尝试解决分布式一致性问题，但是一个广为接受但是十分令人费解的算法 Paxos 已经困扰了无数学生和开发者很多年了。我们创造了一种新的算法 Raft，显而易见的比 Paxos 要容易理解。我们同时也相信，Raft 也可以为实际的实现提供坚实的基础。把可理解性作为设计的目标改变了我们设计 Raft 的方式；随着设计的进展，我们发现自己重复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提升了 Raft 的可理解性，同时也使我们坚信其正确性。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>略</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
</search>
