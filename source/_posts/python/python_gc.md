---
title: python 的垃圾回收机制
date: 2019-07-05T10:03:48+08:00
toc: true
tags:
  - python
categories:
  - 技术文章
---

# python 的垃圾回收机制
<!--more-->

### 引用计数

##### PyObject

python里每一个东西都是对象，它们的核心就是一个结构体：PyObject

PyObject是每个对象必有的内容，其中`ob_refcnt`就是做为引用计数。当一个对象有新的引用时，它的`ob_refcnt`就会增加，当引用它的对象被删除，它的`ob_refcnt`就会减少

##### 引用计数的优缺点

> 优点：
> 简单实时,一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。

> 缺点：
> 维护引用计数消耗资源,会造成循环引用导致无法回收,造成内存泄露

##### 循环引用

```python
list1=[]
list2=[]
list1.append(list2)
list2.append(list1)
# list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。
```

### 标记清除

标记-清除机制，顾名思义，首先标记对象（垃圾检测），然后清除垃圾（垃圾回收)
![gc_1](/images/python/gc_1.png)

首先初始所有对象标记为白色，并确定根节点对象（这些对象是不会被删除），标记它们为黑色（表示对象有效）。

将有效对象引用的对象标记为灰色（表示对象可达，但它们所引用的对象还没检查），检查完灰色对象引用的对象后，将灰色标记为黑色。

重复直到不存在灰色节点为止。最后白色结点都是需要清除的对象。

### 分代回收

分代技术是一种典型的以空间换时间的技术，这也正是java里的关键技术。这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。

这样的思想，可以减少标记-清除机制所带来的额外操作。分代就是将回收对象分成数个代，每个代就是一个链表（集合），代进行标记-清除的时间与代内对象

存活时间成正比例关系。

从上面代码可以看出python里一共有三代，每个代的threshold值表示该代最多容纳对象的个数。默认情况下，当0代超过700,或1，2代超过10，垃圾回收机制将触发。

0代触发将清理所有三代，1代触发会清理1,2代，2代触发后只会清理自己。

